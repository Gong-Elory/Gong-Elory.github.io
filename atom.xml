<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>龚小样儿</title>
  <subtitle>写一些小事，做一些大事</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://gelory.me/"/>
  <updated>2016-12-11T04:12:14.963Z</updated>
  <id>http://gelory.me/</id>
  
  <author>
    <name>龚志强</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>百度贴吧你隐藏的动态访客真的看不见吗？</title>
    <link href="http://gelory.me/2016/12/11/%E7%99%BE%E5%BA%A6%E8%B4%B4%E5%90%A7%E4%BD%A0%E9%9A%90%E8%97%8F%E7%9A%84%E5%8A%A8%E6%80%81%E8%AE%BF%E5%AE%A2%E7%9C%9F%E7%9A%84%E7%9C%8B%E4%B8%8D%E8%A7%81%E5%90%97%EF%BC%9F/"/>
    <id>http://gelory.me/2016/12/11/百度贴吧你隐藏的动态访客真的看不见吗？/</id>
    <published>2016-12-11T03:44:49.000Z</published>
    <updated>2016-12-11T04:12:14.963Z</updated>
    
    <content type="html"><![CDATA[<p>百度贴吧你隐藏的动态访客真的看不见吗？非也，由于年久，百度贴吧一些问题不断地凸现出来，这篇文章将要讲解的是一个关乎广大贴吧用户都会在意的问题 – 信息安全。<br><a id="more"></a><br>或许是又要到年关了，程序员们都无心思查bug了。淘宝网的登录系统居然出现了随机bug（加入购物车就不断地登录，循环往复）。百度统计也在4.0版本更新后也成功的让一些常用功能失效（以我的暴脾气，肯定要到百度统计贴吧去讨个说法，或许是骂声一片，压力倍增，终于在上线不久后恢复正常）。腾讯产品我现在关注最多的就是王者荣耀了，然而光顾着挣钱了，游戏却抄的一点都不走心。拿来历史人物就用，感谢王者荣耀让我知道了花木兰是唐朝的守卫军，让我知道了荆轲是女的。咨询了一下律师，才发现高明的是用这些历史人物都不用担心版权，难道用三国演义的人物还要给罗贯中交版费吗？想来也是挺有道理。另外一个问题则是关于退赛惩罚的问题，为此专门和英雄联盟对比了一下。后者随意一个退赛轻则就是匹配队列优先级下降，让你每次匹配都要等个5分钟。重则就不用说了。然而企鹅家的亲生儿子可是赚钱的利器，如此爱用户以及用户手里的RMB的企鹅怎么可能让她亲爱的用户玩不了游戏，花不了钱呢？王者荣耀的惩罚机制我经历的最多也就只是禁赛几个小时而已。挂机成本如此之低，你能奈小学生何？不过这次的重点最终还是落到了百度的头上。<br>百度贴吧算是百度拿得出手的社交应用。然而由于产品有了一些年头，只顾去添加一些功能，却忘记梳理了原有功能的条理性和重复性。百度贴吧有隐藏自己动态的功能，当你设置了这个功能后，别人访问你的关注的贴吧，发的帖子是看不到任何东西的。相信一大批用户在早些年间已经设置了隐藏动态。</p>
<p>这样访客通过id直接访问就跳到了这个链接。</p>
<pre><code>http://tieba.baidu.com/home/achievement?un=用户ID&amp;fr=home
</code></pre><p><img src="http://oeqcvcrxo.bkt.clouddn.com/1.png" alt="百度贴吧你隐藏的动态访客真的看不见吗？图1"></p>
<p>显示如图所示，然而你的动态别人真的看不见吗？当然不是。早些年间或许真的看不到，但是粗心的百度在多次改版之后，留下的访问个人主页的入口越来越多，自己都忘记要将这些入口也设置访问权限了，于是乎就出现了这样的乌龙。我们通过下面这个入口进入你的贴吧个人主页，呈现的则是另一番景象。</p>
<pre><code>https://www.baidu.com/p/用户ID?from=tieba
</code></pre><p><img src="http://oeqcvcrxo.bkt.clouddn.com/2.png" alt="百度贴吧你隐藏的动态访客真的看不见吗？图2"><br>那么真的对于所有人都是这样的吗？于是继续做了深入调查，我写了一个爬虫（随便进入一个贴吧，获取用户ID，然后按照上述链接依次访问所有ID的个人主页抓取关注的贴吧名。），抓取成功率90%以上。结果表明，大部分的用户都被蒙骗了。</p>
<p>有人会问，谁能知道我的贴吧ID，我可是连身边人都不告诉的，然而事实证明，你的贴吧ID被知道的概率达5层。用过贴吧或者其他社交网站的都应该有过这样的经历：</p>
<pre><code>10106***@qq.com  楼主好人，楼主长命百岁

1557272**** 麻烦给我一份资料 蟹蟹
</code></pre><p>更有甚者，将自己的身份证号码，醒目都暴露在这种场合。实在是令人惊诧。（此人不点名）</p>
<p>针对贴吧权限问题一事，解决方案就是</p>
<pre><code>进入https://www.baidu.com/p/setting/privacy/tieba 重新设置权限，并点击保存。
进入https://www.baidu.com/p/setting/privacy/tieba 重新设置权限，并点击保存。
进入https://www.baidu.com/p/setting/privacy/tieba 重新设置权限，并点击保存。
</code></pre><p>那么针对信息泄露问题，想想自己暴露的隐私能不能尽量删除，避免被人利用。</p>
<p>另外我发现一个问题，我的QQ好友中，有人的爱奇艺账号也被攻破啦，并且被分享，赶紧查查看自己的这些账号是不是存在登录异常或者可疑记录。</p>
<p>因为有些情况，不得不公布联系方式，那么请妥善保管自己的隐私，谨慎发言，不要给予犯罪分子可乘之机。</p>
<hr>
<h2 id="小样有话说："><a href="#小样有话说：" class="headerlink" title="小样有话说："></a>小样有话说：</h2><center style="color:green;font-weight: Bold;border:1px dotted #999">今天就说到这里。也欢迎在文章底下评论，爆出更多的料。<br>也欢迎大家转发，让身边喜欢用贴吧的人都注意一下。</center>

<center><div style="border: 2px solid #999;border-top:none;border-left:none;width: 20px;height:20px;transform:rotate(45deg);"></div></center><br><center style="dispaly:block;width:300px;margin:0 auto"><span style="display:inline-block;float:left;width:100px;height:10px;border-top:1px solid #999;margin-top:15px;"></span><span><a href="https://github.com/Gong-Elory" target="_blank" rel="external">龚小样</a></span><span style=" display:inline-block;float:right;width:100px;height:10px;border-top:1px solid #999;margin-top:15px;"></span></center><br><center><span style="font-size:14px;line-height:14px;margin-top:0;">2016-12-11</span></center>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;百度贴吧你隐藏的动态访客真的看不见吗？非也，由于年久，百度贴吧一些问题不断地凸现出来，这篇文章将要讲解的是一个关乎广大贴吧用户都会在意的问题 – 信息安全。&lt;br&gt;
    
    </summary>
    
      <category term="用户体验" scheme="http://gelory.me/categories/%E7%94%A8%E6%88%B7%E4%BD%93%E9%AA%8C/"/>
    
    
      <category term="信息安全" scheme="http://gelory.me/tags/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"/>
    
      <category term="UX" scheme="http://gelory.me/tags/UX/"/>
    
  </entry>
  
  <entry>
    <title>JS中事件冒泡与事件捕获的定义与应用</title>
    <link href="http://gelory.me/2016/11/27/JS%E4%B8%AD%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1%E4%B8%8E%E4%BA%8B%E4%BB%B6%E6%8D%95%E8%8E%B7%E7%9A%84%E5%AE%9A%E4%B9%89%E4%B8%8E%E5%BA%94%E7%94%A8/"/>
    <id>http://gelory.me/2016/11/27/JS中事件冒泡与事件捕获的定义与应用/</id>
    <published>2016-11-27T14:02:19.000Z</published>
    <updated>2016-11-27T14:04:33.621Z</updated>
    
    <content type="html"><![CDATA[<p>事件流描述了从页面中接收事件的顺序。事件冒泡与事件捕获是两种完全不同的事件流顺序概念。分别出自IE与Netscape。<br><a id="more"></a></p>
<p>##事件冒泡<br>该事件流描述了事件开始时是有目标元素接收，然后逐级向上传播到不具体的节点（Document元素）。这是书中给的定义，晦涩难懂，我们用更形象的比喻来表述（虽然图片更直观，请容笔者偷个懒。）</p>
<p>比喻（讲个故事）：<br>天气冷了，在老家都会烤火炉。我们把事件比作烧柴火生的烟。点燃柴<code>[事件触发]</code>之后呢，烟先经过炉子<code>[当前元素]</code>冒到房子<code>[父元素]</code>里，把你熏成腊肉。然后又从房子里冒到大气中<code>[祖先元素...一直冒到Document对象结束]</code>，污染了空气。（有点可怕，哈哈！）</p>
<p>总结的说就是</p>
<blockquote>
<p>从触发事件的元素[目标元素]开始逐级向父元素-&gt;爷爷元素-&gt;太爷爷元素-&gt;猿人元素[Document对象]传播，然后终止。这就是冒泡过程.</p>
</blockquote>
<h2 id="事件捕获"><a href="#事件捕获" class="headerlink" title="事件捕获"></a>事件捕获</h2><p>该事件流描述了，当事件触发时，不具体的节点应该先收到事件，而最具体的事件最后接受事件。其用意在于事件到达预定目标时捕获它。</p>
<p>比喻（讲个故事）：<br>外面正在下着暴雨，我没有水喝。房子是破的。雨水先穿过云层，然后穿透我的破房子滴到了我的杯子里。哈哈，有水喝了。这里把水比作事件。云层相当于[Document对象……祖先元素],破房子[父元素],杯子[目标元素]。这是雨最后的归宿。</p>
<p>总结的说就是</p>
<blockquote>
<p>从猿人元素[Document对象]……-&gt;太爷爷元素-&gt;爷爷元素-&gt;父元素-&gt;目标元素传播，然后终止。这就是捕获过程.</p>
</blockquote>
<h2 id="DOM2级事件流规定"><a href="#DOM2级事件流规定" class="headerlink" title="DOM2级事件流规定"></a>DOM2级事件流规定</h2><p>为了考虑IE和Netscape的感受，DOM2级事件规定事件流包含三个阶段。事件捕获阶段-&gt;处于目标阶段-&gt;事件冒泡阶段。形成一个完美的<code>U</code>型。</p>
<h2 id="如何将事件处理程序添加到不同的阶段呢？"><a href="#如何将事件处理程序添加到不同的阶段呢？" class="headerlink" title="如何将事件处理程序添加到不同的阶段呢？"></a>如何将事件处理程序添加到不同的阶段呢？</h2><p>DOM2级事件添加事件处理程序的方法为addEventListener（）。这个方法有三个参数，分别为：事件类型，事件处理函数，以及最最最最最关键的<code>布尔值阶段选择参数</code>（这是我取得名）。<br>举个栗子：</p>
<pre><code>&lt;div id=&quot;father&quot;&gt;
    &lt;input type=&quot;button&quot; value=&quot;Click me&quot; id=&quot;myBtn&quot;/&gt;
&lt;/div&gt;
var btn = document.getElementById(&quot;myBtn&quot;);
btn.addEventListener(&quot;click&quot;,function(){
    alert(&quot;nothing&quot;);
    },false);
</code></pre><p>第三个参数，也就是我们的布尔值阶段选择参数。当其为true时，规定在<code>捕获阶段</code>调用事件处理程序。为false时，则在<code>冒泡阶段</code>调用事件处理程序.</p>
<p>上面的例子，在按钮被按下之后，触发了click事件，事件从input元素开始向上传播，看当前的元素是否有相应的事件处理程序。由于input绑定了事件处理程序，于是执行。然后向上访问div元素，看是否有事件处理程序。发现没有，于是继续向上访问document元素，发现还是没有，于是冒泡结束。</p>
<p>恩，没了。<br>没了？有人肯定要问：</p>
<blockquote>
<ul>
<li><p>问：你只说了DOM2级事件啊，DOM0呢，IE呢？不可能要求都用addEventListener方法吧?</p>
</li>
<li><p>答：我们都知道DOM0级绑定事件处理程序的方法是：<code>element.onclick = function（）{}；</code><br>没有设置阶段的参数，IE的是:<code>attachEvent(&quot;onclick&quot;,function(){});</code>也没有。首先说IE，冒泡事件流就是IE提出的概念啊，他怎么可以允许在他的浏览器中实现捕获阶段呢？这不是啪啪啪打脸吗？多以在IE中，绑定的事件都是在冒泡阶段执行的。而针对DOM0级等等，添加的事件在大部分情况下也是添加到事件流的冒泡阶段，因为这样可以最大限度的兼容各色浏览器。书上说：没什么特别需要，不建议在事件捕获阶段注册事件处理程序。</p>
</li>
</ul>
</blockquote>
<h2 id="冒泡的运用"><a href="#冒泡的运用" class="headerlink" title="冒泡的运用"></a>冒泡的运用</h2><h3 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h3><p>事件委托利用了事件冒泡的原理，只指定了一个时间处理程序，就可以管理某一类型的所有事件。<br>举个栗子：</p>
<pre><code>&lt;ul id=&quot;admin&quot;&gt;
    &lt;li id=&quot;eat&quot;&gt;eat&lt;/li&gt;
    &lt;li id=&quot;drink&quot;&gt;drink&lt;/li&gt;
    &lt;li id=&quot;sleep&quot;&gt;sleep&lt;/li&gt;
&lt;/ul&gt;
</code></pre><p>我现在想给每一个li标签注册一个click事件。这样我点击他的时候，显示在干嘛？<br>按照常规的方法：</p>
<pre><code>var eat = document.getElementById(&quot;eat&quot;);
var drink = document.getElementById(&quot;drink&quot;);
var sleep = document.getElementById(&quot;sleep&quot;);
btn.addEventListener(&quot;click&quot;,function(){
    alert(&quot;eat&quot;);
    },false);
drink.addEventListener(&quot;click&quot;,function(){
    alert(&quot;drink&quot;);
    },false); 
sleep.addEventListener(&quot;click&quot;,function(){
    alert(&quot;sleep&quot;);
    },false);
</code></pre><p>我要抱怨了，虽然是复制粘贴，但是真的好麻烦啊。三个都这么麻烦，要是有100个呢？我得摔电脑了。<br>用事件委托法：</p>
<pre><code>var admin = document.getElementById(&quot;admin&quot;);
btn.addEventListener(&quot;click&quot;,function(event){
    switch(event.target.id){
        case &quot;eat&quot;:
            alert(&quot;eat&quot;);
            break;
        case &quot;drink&quot;:
            alert(&quot;drink&quot;);
            break;
        case &quot;sleep&quot;:
            alert(&quot;sleep&quot;);
            break;
    }
},false);
</code></pre><p>我们可以看到，此时事件处理函数不是绑到li元素上面的，而是其父元素ul上。由于是冒泡阶段处理。当我们点击li时，先访问li有没有绑定事件处理函数，发现没有，于是向上访问ul，发现有，这时处理完上面的事件程序内的事情后，继续冒泡知道document终止。</p>
<h3 id="事件委托优点"><a href="#事件委托优点" class="headerlink" title="事件委托优点"></a>事件委托优点</h3><blockquote>
<ul>
<li>代码消耗低，尤其是需要大批量绑定click事件时体现出来的优越性。</li>
<li>事件处理程序数量会直接影响整个页面的整体运行性能。函数也是对象，对象需要占用内存，绑定的事件处理函数越多，占据的内存越大，这样可能会延迟整个页面的交互。</li>
<li>动态添加元素时，不需要单独为他绑定事件处理程序。用上面的例子来说：添加一个li后，不需要单独为他绑定，只需在现有的程序中添加相应判断机制即可。同样，删除某元素时，不用担心空事件处理程序占用内存的问题。</li>
</ul>
</blockquote>
<h2 id="如何阻止冒泡"><a href="#如何阻止冒泡" class="headerlink" title="如何阻止冒泡"></a>如何阻止冒泡</h2><p>任何事物都有两面性，有些时候我们并不希望冒泡。那该如何办？<br>上一篇博文<a href="http://gelory.me/2016/11/27/%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1%E4%B8%AD%E6%98%93%E6%B7%B7%E6%B7%86%E7%9A%84%E5%AE%9A%E4%B9%89%E4%B8%8E%E8%BF%90%E7%94%A8/">事件对象中易混淆的定义与运用</a>中讲到事件对象event。该对象中有一个方法可以阻止冒泡。它是stopPropagation（）。当然，哪里都少不了IE这个特殊分子。他的event对象中有这样一个属性代替上面的方法起到相同的作用。它是cancelBubble。默认false，表示允许事件冒泡。</p>
<p>当然为了兼容所有大部分的浏览器，建议这样重写阻止冒泡方法：</p>
<pre><code>function（event）{
    if(event.stopPropagation())
    {
        event.stopPropagation();
    }else{
        event.cancelBubble = true;
    }
}
</code></pre><center><div style="border: 2px solid #999;border-top:none;border-left:none;width: 20px;height:20px;transform:rotate(45deg);"></div></center><br><center style="dispaly:block;width:300px;margin:0 auto"><span style="display:inline-block;float:left;width:100px;height:10px;border-top:1px solid #999;margin-top:15px;"></span><span><a href="https://github.com/Gong-Elory" target="_blank" rel="external">龚小样</a></span><span style=" display:inline-block;float:right;width:100px;height:10px;border-top:1px solid #999;margin-top:15px;"></span></center><br><center><span style="font-size:14px;line-height:14px;margin-top:0;">2016-11-27</span></center>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;事件流描述了从页面中接收事件的顺序。事件冒泡与事件捕获是两种完全不同的事件流顺序概念。分别出自IE与Netscape。&lt;br&gt;
    
    </summary>
    
      <category term="JS" scheme="http://gelory.me/categories/JS/"/>
    
    
      <category term="JS" scheme="http://gelory.me/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>事件对象中易混淆的定义与运用</title>
    <link href="http://gelory.me/2016/11/27/%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1%E4%B8%AD%E6%98%93%E6%B7%B7%E6%B7%86%E7%9A%84%E5%AE%9A%E4%B9%89%E4%B8%8E%E8%BF%90%E7%94%A8/"/>
    <id>http://gelory.me/2016/11/27/事件对象中易混淆的定义与运用/</id>
    <published>2016-11-27T11:32:26.000Z</published>
    <updated>2016-11-27T14:09:14.160Z</updated>
    
    <content type="html"><![CDATA[<p>在学习js，jQuery的过程中遇到了几种标书对象的写法，他们看似作用相同，但其实还是有那么一些差异的。<br><a id="more"></a><br>在学习js，jQuery的过程中遇到了几种标书对象的写法，他们看似作用相同，但其实还是有那么一些差异的。</p>
<p>在指定时间处理程序的时候，我们常常会遇见这种形式</p>
<pre><code>&lt;div id=&quot;father&quot;&gt;
    &lt;input type=&quot;button&quot; value=&quot;Click me&quot; id=&quot;myBtn&quot;/&gt;
&lt;/div&gt;

var btn = document.getElementById(&quot;myBtn&quot;);
btn.onclick = function(event){
//注意下面这条语句中的event.target
    alert(event.target.id);
}
</code></pre><p>或者是这种：</p>
<pre><code>var btn = document.getElementById(&quot;myBtn&quot;);
btn.onclick = function(event){
//注意下面这条语句中的this
    alert(this.id);
}
</code></pre><p>又或者是在jquery中看见这种:</p>
<pre><code>$(&quot;#myBtn&quot;).click(function(){
//注意下面这条语句中的$(this)
    alert($(this).id);
});
</code></pre><p>无论用上面的哪种方式去点击，最后弹出的对话框中出现的都是—–“myBtn”<br>是不是因此可以下定论，他们就是指的同一样东西呢？<br>不一定</p>
<p>使用event.target首先得明白什么是事件对象</p>
<h2 id="事件对象定义"><a href="#事件对象定义" class="headerlink" title="事件对象定义"></a>事件对象定义</h2><p>在触发DOM上的某个事件后，会产生一个事件对象event（名字可以随便取），无论是采用什么事件处理方式都会向处理程序传入该对象。这个对象包含着所有与事件有关的信息。譬如导致事件的元素，事件类型等。</p>
<h3 id="事件处理程序种类"><a href="#事件处理程序种类" class="headerlink" title="事件处理程序种类"></a>事件处理程序种类</h3><p>HTML事件处理程序：</p>
<pre><code>&lt;input type=&quot;button&quot; value=&quot;Click me&quot; id=&quot;myBtn&quot; onclick=&quot;alert(event.type)&quot;/&gt;
</code></pre><p>DOM0级事件处理程序：</p>
<pre><code>btn.onclick = function(){
//do something
}
</code></pre><p>DOM2级事件处理程序:</p>
<pre><code>btn.addEventListener（&quot;click&quot;,function(){
//do something
});
</code></pre><p>IE事件处理程序:</p>
<pre><code>btn.attachEvent(&quot;onclick&quot;,function(){
    //do something
});
</code></pre><h2 id="event-target-this-this-的区别与联系"><a href="#event-target-this-this-的区别与联系" class="headerlink" title="event.target,this,$(this)的区别与联系"></a>event.target,this,$(this)的区别与联系</h2><h3 id="event-target"><a href="#event-target" class="headerlink" title="event.target"></a>event.target</h3><p>前面说到事件对象会包含所有关于事件有关的信息。而target正是其中的一项。target属性表示事件的目标元素。所以，上例中event.target指的就是input元素。常见的还有type，代表事件类型。上例中的event.type为click。还有一个与target类似的属性currentTarget。指的是其事件处理程序当前正在处理事件的那个元素。</p>
<h3 id="target与currentTarget"><a href="#target与currentTarget" class="headerlink" title="target与currentTarget"></a>target与currentTarget</h3><p>有人会感到疑惑，这两个不就是一样东西吗？为什么要用两个属性表示。常言道：存在即合理。其实这两个并不是指同一样东西。</p>
<blockquote>
<p>target：事件的实际目标。<br>currentTarget：正在处理事件的元素，我们可以说谁绑定了事件，这个属性就指向谁。</p>
</blockquote>
<p>重新搬回这个例子：</p>
<pre><code>&lt;div id=&quot;father&quot;&gt;
    &lt;input type=&quot;button&quot; value=&quot;Click me&quot; id=&quot;myBtn&quot;/&gt;
&lt;/div&gt;   
</code></pre><p>我们设置这样的处理程序</p>
<pre><code>var fath = document.getElementById(&quot;father&quot;);
fath.onclick = function(event){
//alert(event.currentTarget.id); 显示为 father。div元素的id
alert(event.Target.id); //显示为 myBtn。input元素的id
}
</code></pre><p>这回我们把单击事件处理程序绑定在input的父元素div元素上。此时单击按钮，由于事件冒泡的原因（关于事件冒泡，这篇文章有介绍：<a href="http://gelory.me/2016/11/27/JS%E4%B8%AD%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1%E4%B8%8E%E4%BA%8B%E4%BB%B6%E6%8D%95%E8%8E%B7%E7%9A%84%E5%AE%9A%E4%B9%89%E4%B8%8E%E5%BA%94%E7%94%A8/">JS中事件冒泡与事件捕获的定义与应用</a>），会触发父元素的事件处理程序。可以明显的看到target和currentTarget指向的元素不是同一个。</p>
<p>前者指向事件实际目标，这里是input实际出发的click事件，所以target指向他。而后者是处理事件的元素。因为事件处理程序绑定在div元素上，所以currentTarget指向div元素。实际上，还有一种表示法也是始终和currentTarget的值相等的，也就是—this。this很熟悉，我们对他的认识是他指的是调用当前函数的对象。用在这里也合乎情理。</p>
<h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><p>上节说道，currentTarget的值和this始终相等，指的是正在处理事件的元素，也就是我们绑定事件处理程序的那个元素。<br>因此 event.target与this的值不总是相等的。除非把事件处理程序绑定在实际触发事件的元素上。如上例：</p>
<pre><code>var btn = document.getElementById(&quot;myBtn&quot;);
btn.onclick = function(event){
//注意下面这条语句中的event.target
    alert(event.target.id);
}
</code></pre><p>input元素是实际出发click事件的元素，儿我们也将处理程序绑定在input元素上。因此，此时event.target与this相等。</p>
<h3 id="this-与this的区别"><a href="#this-与this的区别" class="headerlink" title="$(this)与this的区别"></a>$(this)与this的区别</h3><p>$(this)指的是jquery对象，而this指代的是DOM对象。就这么简单。需要注意的是，因为对象不同，他们拥有的属性不同，尽管他们都是指向某一元素。</p>
<blockquote>
<p>世界上总有一些特立独行的人，也有这样特例独行的浏览器，他就是IE。</p>
</blockquote>
<h2 id="IE中的事件对象"><a href="#IE中的事件对象" class="headerlink" title="IE中的事件对象"></a>IE中的事件对象</h2><p>要访问IE中的事件对象，取决于指定事件处理程序的方法。<br>使用DOM0级方法，此时event对象是作为window对象的属性存在的，因此访问event就这样做。</p>
<pre><code>btn.onclick = function(){
    var event = window.event;
    alert(event.target.id);
}
</code></pre><p>当然啦，IE也有它自己的事件处理程序：</p>
<pre><code>var btn = document.getElementById(&quot;myBtn&quot;);
btn.attachEvent(&quot;onclick&quot;,function(event){
    //do something
});
</code></pre><p>该方法与DOM0级的方法的区别在于事件处理程序的作用域。前者会在全局作用域下运行，后者在所属元素的作用域下运行。因此，前者的this指向的是window对象。</p>
<h3 id="IE中替代target的属性"><a href="#IE中替代target的属性" class="headerlink" title="IE中替代target的属性"></a>IE中替代target的属性</h3><p>前面说到，在IE中event是作为window的属性存在的，那么要像访问事件的目标。可以通过srcElement这个属性访问。</p>
<center><div style="border: 2px solid #999;border-top:none;border-left:none;width: 20px;height:20px;transform:rotate(45deg);"></div></center><br><center style="dispaly:block;width:300px;margin:0 auto"><span style="display:inline-block;float:left;width:100px;height:10px;border-top:1px solid #999;margin-top:15px;"></span><span><a href="https://github.com/Gong-Elory" target="_blank" rel="external">龚小样</a></span><span style=" display:inline-block;float:right;width:100px;height:10px;border-top:1px solid #999;margin-top:15px;"></span></center><br><center><span style="font-size:14px;line-height:14px;margin-top:0;">2016-11-27</span></center>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在学习js，jQuery的过程中遇到了几种标书对象的写法，他们看似作用相同，但其实还是有那么一些差异的。&lt;br&gt;
    
    </summary>
    
      <category term="JS" scheme="http://gelory.me/categories/JS/"/>
    
    
      <category term="JS" scheme="http://gelory.me/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>JS闭包</title>
    <link href="http://gelory.me/2016/11/18/JS%E9%97%AD%E5%8C%85/"/>
    <id>http://gelory.me/2016/11/18/JS闭包/</id>
    <published>2016-11-18T10:15:29.000Z</published>
    <updated>2016-11-18T12:26:53.725Z</updated>
    
    <content type="html"><![CDATA[<p>介绍闭包相关知识。<br><a id="more"></a></p>
<h2 id="闭包的定义"><a href="#闭包的定义" class="headerlink" title="闭包的定义"></a>闭包的定义</h2><p><strong>闭包是</strong>指有权访问另一个函数作用域中的变量的<strong>函数</strong>。我们常常通过在一个函数内部创建另外一个函数来形成闭包。</p>
<h2 id="作用域以及作用域链的回顾"><a href="#作用域以及作用域链的回顾" class="headerlink" title="作用域以及作用域链的回顾"></a>作用域以及作用域链的回顾</h2><p><a href="http://gelory.me/2016/11/06/JS%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83%E5%8F%8A%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84%E7%90%86%E8%A7%A3/">JS执行环境及作用域的理解</a>这篇文章对这些名词做了很好的解释，但是如果不代入使用环境的话，总觉得云里雾里，似懂非懂的样子。</p>
<p>当一个函数被调用的时候，就会创建一个<code>执行环境</code>（执行环境定义了变量和函数有权访问其他数据）以及相对应的<code>作用域链</code>（规定访问变量和函数的顺序）。然后使用arguments和其他命名参数来初始化函数的活动对象。</p>
<h2 id="变量对象与活动对象的区别与联系"><a href="#变量对象与活动对象的区别与联系" class="headerlink" title="变量对象与活动对象的区别与联系"></a>变量对象与活动对象的区别与联系</h2><p>其实变量对象与活动对象的关系是包含与被包含的关系。也就是说活动对象是变量对象的一部分。<br>活动对象正如其名，活动，表示一种状态，也可以称为活动的变量对象，其实活动这个名词也是翻译过来的。英文名叫<code>Activation Object</code>，意思是激活，我们也可以理解为正在用的意思。<br>用例子来解释：</p>
<pre><code>var a = 1;
function func(){
    var b =2;
    return a+b;
}
alert(func());
</code></pre><p>我们在全局环境下定义了变量a和函数func。当我们打开浏览器时，全局环境的执行环境就存在了。此时的变量对象包括a,func.<br><strong>在func函数创建之初</strong>，会预先创建一个包含全局变量对象的作用域链（scope chain），这个作用域链被保存在函数对象的scope属性中。<br><strong>当我们调用函数func时</strong>，会创建func的执行环境。然后复制scope属性中的对象（此时只有全局变量对象），构建执行环境的作用域链，之后把pub函数中的变量对象（包含this，arguments，b）放入执行环境中，该对象被推入到作用域链的前端。此时，执行环境的作用域链（本质是一个指针列表）包含两个变量对象（全局变量对象，pub函数的变量对象），而func函数的变量对象也就是活动对象。<br>我们可以说活动对象就是当前正在被执行或者被引用的变量对象。</p>
<h2 id="闭包案例解析"><a href="#闭包案例解析" class="headerlink" title="闭包案例解析"></a>闭包案例解析</h2><pre><code>var a = 1;
function func(){
    var b =2;
    return function(){
    alert(a+b);
}
var sonfunc = func();//创建函数
sonfunc();//调用函数
</code></pre><p>在一个函数（本例中的func）内部定义另外一个函数（本例中返回的函数），这就是闭包的常见形式.<br>当执行</p>
<pre><code>var sonfunc = func();//创建函数
</code></pre><p>这条语句时,引用了func函数，此时func函数的变量对象被称为活动对象。包括（this，arguments，b，内部function）。<br>当执行</p>
<pre><code>sonfunc();//调用函数
</code></pre><p>这条语句时，sonfunc（闭包）的变量对象被添加到其作用域链的最前端，其作用域链将包含本地活动对象（this，arguments），func活动对象（this，arguments，b，内部function）以及全局变量对象。</p>
<p>细心的人可能会发现：<br>此时执行的时函数sonfunc，而不是func，按照你刚才对活动对象的定义，<strong>活动对象就是当前正在被执行或者被引用的变量对象。</strong>那么为什么……<br>看到这里是不是恍然大悟，<strong>被引用</strong>，<strong>被引用</strong>，<strong>被引用</strong>，重要的事说三遍。没错，之所以把此时func函数的变量对象也称之为活动对象，就是因为他符合活动对象定义的第二个条件：被引用。</p>
<p>func函数执行完后，作用域链会被立即销毁，但是活动对象任然留在内存中，原因是sonfunc函数依旧在引用变量b。直到sonfunc被销毁后，func的活动对象才会被销毁。</p>
<h2 id="闭包优点"><a href="#闭包优点" class="headerlink" title="闭包优点"></a>闭包优点</h2><p>普通的函数执行完毕后，其活动对象就会被销毁，仅有全局变量被保存在内存中，但是如果包含闭包则不一样，他需要等闭包被销毁后，其活动对象才会被销毁。</p>
<h2 id="闭包缺点"><a href="#闭包缺点" class="headerlink" title="闭包缺点"></a>闭包缺点</h2><p>由于闭包会携带包含它的函数的作用域，因此会比其他函数更占用内存。</p>
<h2 id="闭包副作用案例分析"><a href="#闭包副作用案例分析" class="headerlink" title="闭包副作用案例分析"></a>闭包副作用案例分析</h2><pre><code>function cFunc(){
    var arr = new Array();
    for (var i =0 ; i&lt;10 ;i++)
    {
        arr[i] = function()
        {
            return i;
        }
    }
    return arr;
}
</code></pre><p>该函数本意是让每个数组元素返回自己的索引值。但是实际上背个数组元素的值都是10.<br>原因就是因为每个闭包引用的变量i是同一个变量对象。for执行完后,i的值为10，所以同步到每一个引用，i都是10，因此每个元素的值都是10.</p>
<p>让函数符合预期的改进方法</p>
<pre><code>function cFunc(){
    var arr = new Array();
    for (var i =0 ; i&lt;10 ;i++)
    {
        arr[i] = function(num)
        {
           //return num; 直接返回参数的方式
           return function(){
            return num;
            }//用闭包的方式
        }(i);//立即执行匿名函数的写法
    }
    return arr;
}
</code></pre><blockquote>
<p>闭包可以访问外部函数中的变量，但是只能取得外部函数变量的最终值。</p>
</blockquote>
<h2 id="匿名函数与闭包"><a href="#匿名函数与闭包" class="headerlink" title="匿名函数与闭包"></a>匿名函数与闭包</h2><p>上一节提到了匿名函数，书上说有很多开发人员总是搞不清匿名函数与闭包的区别。这就尴尬了，在我看来，他们俩最大的共同点：<code>他们都是函数</code>。然后没了。</p>
<h3 id="匿名函数定义"><a href="#匿名函数定义" class="headerlink" title="匿名函数定义"></a>匿名函数定义</h3><p>function关键字后没有标识符的函数，就是匿名函数（拉姆达函数）。简而言之就是没有函数名。</p>
<h3 id="匿名函数与闭包的联系"><a href="#匿名函数与闭包的联系" class="headerlink" title="匿名函数与闭包的联系"></a>匿名函数与闭包的联系</h3><p>我们经常用匿名函数去创建闭包。</p>
<h3 id="匿名函数的this对象"><a href="#匿名函数的this对象" class="headerlink" title="匿名函数的this对象"></a>匿名函数的this对象</h3><p>匿名函数的执行对象具有全局性，因此this指向window。</p>
<h2 id="内存泄露问题"><a href="#内存泄露问题" class="headerlink" title="内存泄露问题"></a>内存泄露问题</h2><p>IE9之前版本对JS与DOM对象使用不同的垃圾收集方法，因此闭包会产生一些问题。</p>
<pre><code>function test(){
    var a = document.getElementById(&apos;lala&apos;);
    a.onclick = function(){
        alert(a.id);
        //此处形成了循环引用。a对象的click属性引用了function这个函数，而这个函数又引用了a对象的id属性
    }
}
test（）；
</code></pre><p>a的引用次数不止一次，因此a会永远占据内存，不会被回收。<br>解决方案</p>
<pre><code>function test(){
    var a = document.getElementById(&apos;lala&apos;);
    var id = a.id;
    a.onclick = function(){
        alert(id);
    }
}
test（）；
</code></pre><p>此时，消除了循环引用，但是a依旧无法被回收。因为闭包的存在，变量a依旧是闭包可引用的活动对象。即使不引用a，a也不能释放内存，此外DOM对象也保存一个引用，因此设置a为null，可以清除DOM对象所占的内存。闭包执行完后，活动对象被销毁，此时a也就释放了内存。（这段话如果有问题的话，请评论）</p>
<h2 id="为什么JS中会有闭包的存在呢？"><a href="#为什么JS中会有闭包的存在呢？" class="headerlink" title="为什么JS中会有闭包的存在呢？"></a>为什么JS中会有闭包的存在呢？</h2><p>我认为是为了解决全局变量滥用的问题。全局变量正如其名，存在的意义应该是很多函数都会用到的，但是为了满足一个函数某种特殊的需求（譬如想要在某个函数中多次利用已经计算的变量）去声明全局变量实在是大材小用。此外，全局变量所占的内存只有在退出浏览器后才得以释放，这样就会发生内存泄漏。<br>闭包应运而生，既满足了需求，将这个变量保存在外部函数内，可以利用已经计算的变量，此外，等闭包执行完后，该变量内存就会释放。一举两得。</p>
<blockquote>
<p>当一个函数中的变量或者函数能够访问另外一个函数作用域中的变量或者函数时，就产生了闭包。</p>
</blockquote>
<center><div style="border: 2px solid #999;border-top:none;border-left:none;width: 20px;height:20px;transform:rotate(45deg);"></div></center><br><center style="dispaly:block;width:300px;margin:0 auto"><span style="display:inline-block;float:left;width:100px;height:10px;border-top:1px solid #999;margin-top:15px;"></span><span><a href="https://github.com/Gong-Elory" target="_blank" rel="external">龚小样</a></span><span style=" display:inline-block;float:right;width:100px;height:10px;border-top:1px solid #999;margin-top:15px;"></span></center><br><center><span style="font-size:14px;line-height:14px;margin-top:0;">2016-11-18</span></center>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;介绍闭包相关知识。&lt;br&gt;
    
    </summary>
    
      <category term="JS" scheme="http://gelory.me/categories/JS/"/>
    
    
  </entry>
  
  <entry>
    <title>JS中实现继承的方法</title>
    <link href="http://gelory.me/2016/11/17/JS%E4%B8%AD%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>http://gelory.me/2016/11/17/JS中实现继承的方法/</id>
    <published>2016-11-17T08:16:49.000Z</published>
    <updated>2016-11-19T01:21:16.657Z</updated>
    
    <content type="html"><![CDATA[<p>总结继承方法，并且有针对性的分析一下优缺点。由于讲继承，为了便于理解，采用父类这种叫法而不是超类。<br><a id="more"></a></p>
<h2 id="方法一：原型链法"><a href="#方法一：原型链法" class="headerlink" title="方法一：原型链法"></a>方法一：原型链法</h2><p>利用原型让一个引用类型继承另外一个引用类型的属性和方法。<br>基本模式：</p>
<pre><code>function Imtree()
{
    this.tree = true;
}

Imtree.prototype.getTreeValue = function()
{
    return this.tree;
}

function Imleaf()
{
    this.leaf = false;
}

Imleaf.prototype = new Imtree();//这一步实现继承

Imleaf.prototype.getLeaf = function()
{
    return this.leaf;
}

var test = new Imleaf();
test.leaf = false;
test.getLeaf() = false;
test.tree = true;//访问父类属性
test.getTreeValue = true;//访问父类方法
</code></pre><blockquote>
<p>本质就是把父类的实例赋值给子类的原型，其实就是相当于子类原型指向了父类原型。参考实例指向原型。</p>
</blockquote>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><blockquote>
<ul>
<li>包含引用类型值的属性会被共享，如果子类的多个实例访问父类原型中某引用类型值属性的话，只要该属性值被改变，所有子类实例访问到的该属性都会同步变化。</li>
</ul>
</blockquote>
<h3 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h3><pre><code>function Imtree()
{
    this.colors = [&quot;yellow&quot;,&quot;green&quot;,&quot;gray&quot;];
}

function Imleaf(){}
Imleaf.prototype = new Imtree();
var a = new Imleaf();
a.colors.push(&quot;black&quot;);
alert(a.colors);// &quot;yellow&quot;,&quot;green&quot;,&quot;gray&quot;,&quot;black&quot;
var b = new Imleaf();
//注意，此时b访问父类的colors属性，返回的也是四个元素，说明已经同步了。
alert(b.colors);// &quot;yellow&quot;,&quot;green&quot;,&quot;gray&quot;,&quot;black&quot;
</code></pre><p>如果这正是你想要的形态，那无话可说。</p>
<blockquote>
<ul>
<li>在创建子类型的实例时，不能向父类的构造函数中传递参数</li>
</ul>
</blockquote>
<h2 id="方法二-借用构造函数法（伪造对象-经典继承）"><a href="#方法二-借用构造函数法（伪造对象-经典继承）" class="headerlink" title="方法二 借用构造函数法（伪造对象/经典继承）"></a>方法二 借用构造函数法（伪造对象/经典继承）</h2><p>在子类构造函数的内部调用父类（超类）构造函数。</p>
<pre><code>function Imtree（）
{
    this.colors = [&quot;yellow&quot;,&quot;green&quot;,&quot;gray&quot;];
}

function Imleaf()
{
    Imtree.call(this);//此时继承了Imtree类
}

var a =new Imleaf();
a.colors.push(&quot;black&quot;);
alert(a.colors);// &quot;yellow&quot;,&quot;green&quot;,&quot;gray&quot;,&quot;black&quot;
var b = new Imleaf();
alert(b.colors);// &quot;yellow&quot;,&quot;green&quot;,&quot;gray&quot;
</code></pre><h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><p>构造函数模式的通病，方法无法复用。</p>
<h2 id="方法三-组合继承法（伪经典继承）"><a href="#方法三-组合继承法（伪经典继承）" class="headerlink" title="方法三 组合继承法（伪经典继承）"></a>方法三 组合继承法（伪经典继承）</h2><p>使用原型链实现对原型属性和方法的继承，通过借用构造函数法来实现对实例属性的继承</p>
<pre><code>function Imtree(name)
{
    this.tree = name;
    this.colors = [&quot;yellow&quot;,&quot;green&quot;,&quot;gray&quot;];
}

Imtree.prototype.sayTreeName()
{
    alert(this.tree);
}

function Imleaf(name,age) 
{
    Imtree.call(this,name); //第二次调用  
    this.age = age;
}

Imleaf.prototype = new Imtree();//第一次调用
Imleaf.prototype.constructor = Imleaf;
Imleaf.prototype.sayAge = function(){
    alert(this.age);
}

var a = new Imleaf(&quot;aTree&quot;,10);
a.colors.push(&quot;black&quot;);
alert(a.colors);//&quot;yellow&quot;,&quot;green&quot;,&quot;gray&quot;,&quot;black&quot;
alert(a.sayAge());//10
alert(a.sayName));//&quot;aTree&quot;

var b = new Imleaf(&quot;bTree&quot;,50);
alert(b.colors);//&quot;yellow&quot;,&quot;green&quot;,&quot;gray&quot;
alert(a.sayAge());//50
alert(a.sayName));//&quot;bTree&quot;
</code></pre><p>该方法结合了方法一和二的优点，避开了他们的缺点，使用的很广泛。</p>
<h3 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h3><p>调用两次父类构造函数。一次是在创建子类原型时，调用构造函数，将实例赋给子类原型。另外一次是在子类构造函数内。</p>
<h2 id="方法四-原型式继承"><a href="#方法四-原型式继承" class="headerlink" title="方法四 原型式继承"></a>方法四 原型式继承</h2><pre><code>function object(o){
    function F（）{}
    F.prototype = o ;
    return new F();
    }

var person = {
    name: &quot;aa&quot;,
    frineds:&quot;ab&quot;,&quot;ac&quot;
}

var a = object(person);
a.friends.push(&quot;lll&quot;);
alert(a.friends);//&quot;ab&quot;,&quot;ac&quot;,&quot;lll&quot;
var b = object(person);
b.friends.push(&quot;nnn&quot;);
alert(b.friends);//&quot;ab&quot;,&quot;ac&quot;,&quot;lll&quot;,&quot;nnn&quot;
</code></pre><p>该方法的规范方法：Object.create()<br>Object.create()拥有两个参数，第一个参数为（第二声）为（第四声）新对象定义额外属性的对象，第二个参数为自定义属性。</p>
<pre><code>var person = {
        name: &quot;aa&quot;,
        frineds:&quot;ab&quot;,&quot;ac&quot;
    }

var a = object(person,{name:{value:&quot;zz&quot;}});
alert(a.name);//&quot;zz&quot;
</code></pre><p>支持该方法的有IE9+,FF4+,Safari5+，Opera12+和Chrome。</p>
<h2 id="方法五-寄生式继承"><a href="#方法五-寄生式继承" class="headerlink" title="方法五 寄生式继承"></a>方法五 寄生式继承</h2><p>创建一个封闭继承过程的函数，与方法四类似。<br>function createAnother(a)<br>{<br>    var clone = object(a);//不一定是object方法，任何能返回新对象的方法都可以<br>    clone.sayHi = function（）<br>    {<br>        alert(“Hi”);<br>    }<br>    return clone;<br>}</p>
<h2 id="方法六-寄生组合式继承"><a href="#方法六-寄生组合式继承" class="headerlink" title="方法六 寄生组合式继承"></a>方法六 寄生组合式继承</h2><p>通过借用构造函数来继承属性，通过原型链的混合形式来继承方法。基本思路为：不必为了指定子类的原型而调用父类的构造函数。而是创建一个父类的副本。</p>
<pre><code>function inheritPrototype(mtree,mleaf)
{
    var prototype = object(mtree.prototype);//创建父类原型的副本
    prototype.constructor = mleaf;//为副本添加constructor属性
    mleaf.prototype = prototype; //实现继承
}

 function Imtree(name)
{
    this.tree = name;
    this.colors = [&quot;yellow&quot;,&quot;green&quot;,&quot;gray&quot;];
}

Imtree.prototype.sayTreeName()
{
    alert(this.tree);
}

function Imleaf(name,age) 
{
    Imtree.call(this,name); 
    this.age = age;
}
function inheritPrototype(Imtree,Imleaf);
Imleaf.prototype.sayAge = function(){
    alert(this.age);
}
</code></pre><p>此方法是实现类型继承的最有效方法。只调用了一次构造函数。</p>
<h2 id="小样有话说："><a href="#小样有话说：" class="headerlink" title="小样有话说："></a>小样有话说：</h2><center style="color:green;font-weight: Bold;border:1px dotted #999">JS的学习继续。</center>

<center><div style="border: 2px solid #999;border-top:none;border-left:none;width: 20px;height:20px;transform:rotate(45deg);"></div></center><br><center style="dispaly:block;width:300px;margin:0 auto"><span style="display:inline-block;float:left;width:100px;height:10px;border-top:1px solid #999;margin-top:15px;"></span><span><a href="https://github.com/Gong-Elory" target="_blank" rel="external">龚小样</a></span><span style=" display:inline-block;float:right;width:100px;height:10px;border-top:1px solid #999;margin-top:15px;"></span></center><br><center><span style="font-size:14px;line-height:14px;margin-top:0;">2016-11-17</span></center>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;总结继承方法，并且有针对性的分析一下优缺点。由于讲继承，为了便于理解，采用父类这种叫法而不是超类。&lt;br&gt;
    
    </summary>
    
      <category term="JS" scheme="http://gelory.me/categories/JS/"/>
    
    
      <category term="JS" scheme="http://gelory.me/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>JS对象创建方法</title>
    <link href="http://gelory.me/2016/11/11/JS%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E6%96%B9%E6%B3%95/"/>
    <id>http://gelory.me/2016/11/11/JS对象创建方法/</id>
    <published>2016-11-11T07:31:28.000Z</published>
    <updated>2016-11-18T10:14:33.092Z</updated>
    
    <content type="html"><![CDATA[<p>对JS创建对象的方法进行总结<br><a id="more"></a></p>
<h2 id="对象的定义"><a href="#对象的定义" class="headerlink" title="对象的定义"></a>对象的定义</h2><blockquote>
<p>在JS中，对象是拥有属性和方法的数据。</p>
</blockquote>
<h2 id="如何创建对象"><a href="#如何创建对象" class="headerlink" title="如何创建对象"></a>如何创建对象</h2><h3 id="Object实例法"><a href="#Object实例法" class="headerlink" title="Object实例法"></a>Object实例法</h3><p>创建自定义对象最简单的方式是创建一个Object实例，然后添加属性，方法。</p>
<pre><code>var a = new Object();
a.name = &quot;elory&quot;;
a.age = &quot;100&quot;;
a.gender = function()
{
    alert(&quot;no sex&quot;);
}
</code></pre><h3 id="对象字面量法"><a href="#对象字面量法" class="headerlink" title="对象字面量法"></a>对象字面量法</h3><p>其次是使用对象字面量的方法来创建。字面量是一种表示值的记法。</p>
<pre><code>var a = {
    name: &quot;elory&quot;,//注意，这里是逗号
    age: 100,
    gender: function(){
    alert(nothing);
    }
}
</code></pre><p>我们发现，这样建对象有一个好处，就是不用重复的写实例对象名</p>
<h3 id="以上两种方式的缺点"><a href="#以上两种方式的缺点" class="headerlink" title="以上两种方式的缺点"></a>以上两种方式的缺点</h3><p>假如我们要创建两个对象，那么以上两种方法就会产生很多重复的代码。譬如又要写一遍age，name，and so on。</p>
<h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>所谓工厂模式，就是给一套流程，可以重复创建多个对象的方法。正规的说：该模式抽象创建对象的具体过程，用函数来封装以特定接口来创建对象。</p>
<pre><code>function createObj(name,age,gender)
{
    var aaa = new Object();
    aaa.name = name;
    aaa.age = age;
    aaa.gender = gender；
    return a;
}
</code></pre><p>比如我想在要创建两个对象，并分别给其属性赋值，就可以酱。</p>
<pre><code>var b = createObj(&quot;imb&quot;,10,function(){alert(&quot;no sex&quot;);});
var c = createObj(&quot;imc&quot;,60,function(){alert(&quot;man&quot;);});
</code></pre><h4 id="工厂模式的优缺点"><a href="#工厂模式的优缺点" class="headerlink" title="工厂模式的优缺点"></a>工厂模式的优缺点</h4><p>优点：可以创建相似的多个对象。<br>缺点：无法知道创建对象的类型。</p>
<h3 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h3><p>先甩代码：</p>
<pre><code>function Elory(name,age,gender)
{
    this.name = name;
    this.age = age;
    this.gender = gender;
}
var b = new Elory(&quot;imb&quot;,10,function(){alert(&quot;no sex&quot;);});
var c = new Elory(&quot;imc&quot;,60,function(){alert(&quot;man&quot;);});
</code></pre><p>一看代码，这不就是普通函数吗？<br>首先，注意函数的名称，<code>首字母是大写的</code>，这是按照惯例来区别于非构造函数的。<br>此时要创建对象实例，需要使用new操作符。<br>我们可以用instanceof来检测对象类型。</p>
<p><code>此方法就解决了工厂模式不能识别对象类型的问题。</code></p>
<h4 id="构造函数与普通函数的区别"><a href="#构造函数与普通函数的区别" class="headerlink" title="构造函数与普通函数的区别"></a>构造函数与普通函数的区别</h4><p>之前说到的构造函数首字母大写只是人为的规定，便于识别构造函数和普通函数的。他们最大的不同在于他们的调用方式。<br>只要通过new操作符来调用，就可以当做是构造函数。</p>
<h4 id="构造函数的缺点"><a href="#构造函数的缺点" class="headerlink" title="构造函数的缺点"></a>构造函数的缺点</h4><p>明显的问题就是构造函数内的方法都会在实例中重新创建，比如之前我们创建的两个Elory实例，他们中的function实例也是不同的。也就是说通过构造函数创建对象会产生不同的作用域链。</p>
<pre><code>alert(b.gender == c.gender); //返回false；
</code></pre><p>那这样创建这么多function实例有必要吗？显然没必要，正如其名，方法，一套做事的方法，有方法就行，都是完成相同的任务要这么多没必要。况且我们有this这个可以替代调用当前函数的对象在。</p>
<h4 id="该模式的改进版"><a href="#该模式的改进版" class="headerlink" title="该模式的改进版"></a>该模式的改进版</h4><p>把方法放到构造函数外，此时gender方法为全局的,这样，每次在设置gender属性的时候，其实就是设置了一个指向该函数的指针。<br>该方法的缺点：gender方法只在调用该构造函数的时候才有用，设置成全局的，转为他服务，岂不是大材小用。如此一来，构造函数一多，全局方法岂不是满天飞？于是有一种明星级的模式闪亮登场！</p>
<h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><p>用自己的话来解释这个模式就是：<br>我们每创建一个函数，都会自动生成一个prototype属性，该属性以指针的形式存在，指向一个公共的名叫<code>原型对象</code>的东西，这个原型对象里面呢，存在着所有实例<code>共享</code>的属性和方法。看起来就像是构造函数把需要共享的东西放到另外一个对象里，然后用prototype属性指针指向他。实际上就是这样的哈！（有错误请评论指出，欢迎指正，么么）。这样，实例对象们就可以用同一个方法和属性了。</p>
<pre><code>function Elory(){}
Elory.prototype.name = &quot;eeelory&quot;;
Elory.prototype.age = 100;
Elory.prototype.gender = function(){
    alert(&quot;就不说&quot;);
};
var b = new Elory();
b.gender();//就不说
var c = new Elory();
c.gender();//就不说
alert(b.gender == c.gender); //返回true；
</code></pre><p>如果我们在实例对象中设置与原型对象中同名的属性值，那么前者中的值会屏蔽后者的值，也就是添加这个属性，会阻止我们访问原型对象中的属性的值。</p>
<pre><code>function Elory(){}
Elory.prototype.name = &quot;eeelory&quot;;
Elory.prototype.age = 100;
Elory.prototype.gender = function(){
    alert(&quot;就不说&quot;);
};
var b = new Elory();
var c = new Elory();
b.name = &quot;imb&quot;;
alert(b.name);//imb
alert(c.name);//eeelory
</code></pre><p>那如何重新访问原型对象中的属性呢？</p>
<pre><code>//接上例
delete b.name 
alert(b.name);//eeelory
</code></pre><p>答案就是使用<code>delete</code>操作符。</p>
<p>那怎样检测实例中存在某属性呢？</p>
<pre><code>//接上例
alert(b.name);//eeelory 因为上一步删除了实例中的name属性，所以此时访问的是原型对象中的name属性
alert(b.hasOwnProperty(&quot;name&quot;));//false 表示不存在于实例中
b.name = &quot;imb&quot;; //在实例对象中设置name属性
alert(b.hasOwnProperty(&quot;name&quot;));//true 表示存在于实例中
</code></pre><p>答案就是使用<code>hasOwnProperty（）</code>方法。</p>
<h4 id="该模式的改进版-1"><a href="#该模式的改进版-1" class="headerlink" title="该模式的改进版"></a>该模式的改进版</h4><p>字面量法定义原型对象。<br>我们在添加属性和方法时，都加上了Object.prototype前缀，但是如果属性数量很多，这样也太复杂了，于是用字面量来重写原型对象。</p>
<pre><code>function Elory(){}
Elory.prototype ={
name : &quot;eeelory&quot;,
age : 100,
gender : function(){alert(&quot;就不说&quot;);}
};
</code></pre><p>此时我们通过字面量的形式创建了一个新对象，但是这个新对象又拥有了自己的原型对象。画个图大概是这样：<br><img src="http://oeqcvcrxo.bkt.clouddn.com/js%E5%AF%B9%E8%B1%A1.png" alt="js-modle"><br>可以看到该原型对象的constructor并不指向Elory函数了。所以我们需要手动设置constructor的值为Elory.<br>其实这个属性值是否设置对我们要调用属性和方法好像没有太大用处，所以不用在意。</p>
<h4 id="原型模式的缺点"><a href="#原型模式的缺点" class="headerlink" title="原型模式的缺点"></a>原型模式的缺点</h4><p>1.省略了为构造函数传递初始化参数，这样导致新建的实例对象属性值都是相同的。<br>2.针对包含引用类型值的属性来说，实例就无法拥有自己的单独属性。（引用类型是一种数据结构，用于将数据和功能组织在一起）<br>举个例子：</p>
<pre><code>function Elory(){}
Elory.prototype ={
name : &quot;eeelory&quot;,
age : 100,
friends :[&quot;abc&quot;,&quot;def&quot;],
gender : function(){alert(&quot;就不说&quot;);}
};
var b = new Elory();
var c = new Elory();
b.friends.push(&quot;kkk&quot;);
alert(b.friends);//&quot;abc&quot;,&quot;def&quot;,&quot;kkk&quot;
alert(c.friends);//&quot;abc&quot;,&quot;def&quot;,&quot;kkk&quot;
alert(c.friends === b.friends);//true
</code></pre><p>从这里看出，实例不一定能拥有属于自己的全部属性。<br>如何改进上述两个缺点？</p>
<h3 id="组合使用构造函数模式和原型模式"><a href="#组合使用构造函数模式和原型模式" class="headerlink" title="组合使用构造函数模式和原型模式"></a>组合使用构造函数模式和原型模式</h3><p>构造函数模式用于定义实例属性，原型模式负责定义共享属性和方法。此外还支持向构造函数传递参数。</p>
<pre><code>function Elory(name,age)
{
    this.name = name;
    this.age = age;
    this.friends = [&quot;aaa&quot;,&quot;bbb&quot;];
}
Elory.prototype = {
constructor: Elory;
gender:function(){
alert(this.name);
}
var b = new Elory(&quot;imb&quot;,100);
var c = new Elory(&quot;imc&quot;,40);
b.friends.push(&quot;ccc&quot;);
alert(b.friends);//&quot;aaa&quot;,&quot;bbb&quot;,&quot;ccc&quot;
alert(c.friends);//&quot;aaa&quot;,&quot;bbb&quot;
alert(c.friends === b.friends);//false 专有属性
alert(c.gender === b.gender);//true  共享属性
</code></pre><h3 id="动态原型模式"><a href="#动态原型模式" class="headerlink" title="动态原型模式"></a>动态原型模式</h3><p>动态原型模式把所有信息封装在构造函数中，在必要的情况下通过构造函数初始化原型。</p>
<pre><code>function Elory(name,age)
{
    this.name = name;
    this.age = age;
    if(typeof this.gender != &quot;function&quot;){
            Elory.prototype.gender = function(){
            alert(this.name+&quot;have no sex&quot;);
            };
        }
}
</code></pre><p>if块内的代码只在初次调用构造函数时执行，此时原型对象已经完成初始化，具备gender属性，被所有实例共享。</p>
<h3 id="寄生构造函数模式"><a href="#寄生构造函数模式" class="headerlink" title="寄生构造函数模式"></a>寄生构造函数模式</h3><p>该模式的思想是创建一个函数，该函数的作用只是去封装创建对象所用的代码，然后返回新创建的对象。</p>
<pre><code>function SpecialArray(){
var values = new Array();
values.push.apply(values,arguments);
values.toPipedString = function(){
    return this.join(&quot;|&quot;);
    };
return values;
}
var colors = new SpecialArray(&quot;r&quot;,&quot;g&quot;,&quot;b&quot;);
alert(colors.toPipedString());//&quot;r&quot;|&quot;g&quot;|&quot;b&quot;
</code></pre><p>该模式需要注意的地方是：返回的对象和构造函数没有任何关系，从代码中可以看到。因此他也有工厂模式的缺点，不能识别对象类型。因此不建议使用该方法。</p>
<h3 id="稳妥构造函数模式"><a href="#稳妥构造函数模式" class="headerlink" title="稳妥构造函数模式"></a>稳妥构造函数模式</h3><h4 id="稳妥对象"><a href="#稳妥对象" class="headerlink" title="稳妥对象"></a>稳妥对象</h4><p>没有公共属性，其方法不引用this的对象。适用于安全环境中（这些环境禁止使用this和new），或者是防止数据被其他程序改动的时候使用。</p>
<h4 id="与寄生构造函数的差异"><a href="#与寄生构造函数的差异" class="headerlink" title="与寄生构造函数的差异"></a>与寄生构造函数的差异</h4><ol>
<li>新创建对象的实例方法不引用this；</li>
<li>不使用new操作符调用构造函数。</li>
</ol>
<p>重写Elory构造函数为：</p>
<pre><code>function Elory(name,age,gender)
{
    var o = new Object();

    o.readName = function(){
    alert(name);
    }
    return o;
}
</code></pre><p>这种模式创建的对象除了readName方法可以读取大name外，没有其他的方法能够访问数据。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>创建类的方法笼统的可以分三类。<br>工厂模式 构造模式 原型模式</p>
<blockquote>
<ul>
<li>工厂模式缺点<br>1.无法知道创建对象的类型。</li>
<li>构造模式的缺点<br>1.构造函数内的方法都会在实例中重新创建.</li>
<li>原型模式的缺点<br>1.省略了为构造函数传递初始化参数，这样导致新建的实例对象属性值都是相同的。<br>2.针对包含引用类型值的属性来说，实例就无法拥有自己的单独属性。</li>
</ul>
</blockquote>
<h2 id="小样有话说"><a href="#小样有话说" class="headerlink" title="小样有话说"></a>小样有话说</h2><center style="color:green;font-weight: Bold;border:1px dotted #999">这篇文章写了很多天了，并不是因为太难以理解导致的而是因为小样最近回学校忙着叙旧了。哇咔咔</center>

<center><div style="border: 2px solid #999;border-top:none;border-left:none;width: 20px;height:20px;transform:rotate(45deg);"></div></center><br><center style="dispaly:block;width:300px;margin:0 auto"><span style="display:inline-block;float:left;width:100px;height:10px;border-top:1px solid #999;margin-top:15px;"></span><span><a href="https://github.com/Gong-Elory" target="_blank" rel="external">龚小样</a></span><span style=" display:inline-block;float:right;width:100px;height:10px;border-top:1px solid #999;margin-top:15px;"></span></center><br><center><span style="font-size:14px;line-height:14px;margin-top:0;">2016-11-11</span></center>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对JS创建对象的方法进行总结&lt;br&gt;
    
    </summary>
    
      <category term="JS" scheme="http://gelory.me/categories/JS/"/>
    
    
      <category term="JS" scheme="http://gelory.me/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>JS执行环境及作用域的理解</title>
    <link href="http://gelory.me/2016/11/06/JS%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83%E5%8F%8A%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>http://gelory.me/2016/11/06/JS执行环境及作用域的理解/</id>
    <published>2016-11-06T04:02:07.000Z</published>
    <updated>2016-11-06T04:04:15.152Z</updated>
    
    <content type="html"><![CDATA[<p>对执行环境，作用域以及作用域链的理解。<br><a id="more"></a></p>
<h2 id="什么是执行环境"><a href="#什么是执行环境" class="headerlink" title="什么是执行环境"></a>什么是执行环境</h2><p>执行环境定义了变量和函数有权访问其他的数据，决定各自的行为。每个执行环境都有一个变量对象来存储所有的变量和函数。web浏览器的全局执行环境是window对象。对象会因ECMAScript实现的宿主环境不同而有差异。</p>
<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>指变量的适用范围。</p>
<h2 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h2><p>当代码在一个环境中执行，会创建变量对象的作用域链。用途是<strong>保证对执行环境有权访问的变量和函数进行有序的访问</strong></p>
<h3 id="作用域链顺序"><a href="#作用域链顺序" class="headerlink" title="作用域链顺序"></a>作用域链顺序</h3><p>作用域链的前端始终为 — 当前执行代码所在的环境的变量对象。譬如在函数中，就是arguments对象。<br>下个变量对象来自于包含当前环境的环境。<br>…<br>这样一直延续到全局执行环境。</p>
<h3 id="延长作用域链"><a href="#延长作用域链" class="headerlink" title="延长作用域链"></a>延长作用域链</h3><p>当执行流进入 try-catch语句中的catch块时，或者进入with语句时，作用域链得以加长。<br>这两个语句都会在作用域链的前端添加一个变量对象。对with来说，将语句指定的对象添加到作用域链.</p>
<pre><code>function(){
var color = &quot;red&quot;;
with(location)
{
    var ii =  href+color;//href为location对象的属性。此时location这个变量对象被加入到当前作用域链的前端
}
return ii;
}
</code></pre><h3 id="js中没有块级作用域"><a href="#js中没有块级作用域" class="headerlink" title="js中没有块级作用域"></a>js中没有块级作用域</h3><p>通俗的将就是for，if/else,while等用花括号括起来的代码块中定义的变量在当前执行环境中的任意地方都可以使用。</p>
<center><div style="border: 2px solid #999;border-top:none;border-left:none;width: 20px;height:20px;transform:rotate(45deg);"></div></center><br><center style="dispaly:block;width:300px;margin:0 auto"><span style="display:inline-block;float:left;width:100px;height:10px;border-top:1px solid #999;margin-top:15px;"></span><span><a href="https://github.com/Gong-Elory" target="_blank" rel="external">龚小样</a></span><span style=" display:inline-block;float:right;width:100px;height:10px;border-top:1px solid #999;margin-top:15px;"></span></center><br><center><span style="font-size:14px;line-height:14px;margin-top:0;">2016-11-6</span></center>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对执行环境，作用域以及作用域链的理解。&lt;br&gt;
    
    </summary>
    
      <category term="JS" scheme="http://gelory.me/categories/JS/"/>
    
    
      <category term="JS" scheme="http://gelory.me/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>JS垃圾回收机制</title>
    <link href="http://gelory.me/2016/11/05/JS%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"/>
    <id>http://gelory.me/2016/11/05/JS垃圾回收机制/</id>
    <published>2016-11-05T12:39:47.000Z</published>
    <updated>2016-11-05T12:42:48.148Z</updated>
    
    <content type="html"><![CDATA[<p>JavaScript具有自动垃圾收集机制，也就是说，执行环境会负责管理代码执行过程中使用的内存。<br><a id="more"></a><br>在浏览器中实现垃圾回收，通常有两个策略。</p>
<h2 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h2><p>垃圾收集器会在运行的时候，给所有存储在内存中的变量加上标记。然后去掉执行环境中的变量以及被环境中变量引用的变量的标记。而在此之后再被加上标记的变量被视为要删除的变量。因为这些变量再被加上标记的时候就是这些不需要这些变量的时候。譬如在执行完某个函数体后，跳出该函数体，里面的局部变量在就会重新被添加标记。此时垃圾收集器就会清除他们的内存。</p>
<p>现在，所有的现代浏览器基本上都是用标记清除算法，改进也是基于此改进的。</p>
<h2 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h2><p>跟踪记录每个值被引用的次数。如果为0，就收回内存。<br>举个例子</p>
<pre><code>var a = new Object()；
// 变量a对该对象进行首次引用
var b =a; 
// b也引用了这个对象 1+1=2
a=1; 
//此时a不在引用这个对象 1+1-1=1
//如果此时 b=2;那么b不在引用这个对象。此时就会释放这个对象实例的内存了。
c = b.name 
/*
     *此时c引用了这个对象的name属性，于是乎，即使b不再引用这个对象，在是这个对象的属性name还在被引用，因此也无法清除这个对象。
*/
b=2;
c=3;//此时，垃圾收集器就会释放这个对象内存啦
</code></pre><h2 id="例外-循环引用（导致退出函数体后无法自动清除内存）"><a href="#例外-循环引用（导致退出函数体后无法自动清除内存）" class="headerlink" title="例外-循环引用（导致退出函数体后无法自动清除内存）"></a>例外-循环引用（导致退出函数体后无法自动清除内存）</h2><pre><code>function pro()
{
var a = new Object();
var b = new Object();
a.name = b; //a的name属性引用了b
b.age = a;//b的age属性引用了a
}
</code></pre><p>如果采用标记清除法，会因为退出函数体而自动清除内存.但是如果用引用计数法，此时两个对象都被引用了两次，于是无法自动清除内存了。<br>如果这个函数被大量调用，就会导致大量内存被占用不能回收。因此要手动取消循环引用.</p>
<pre><code>a.name = null;
b.age = null;
此时a，b的内存就被回收啦。
a=null;
b=null;//两个对象的内存就被清除啦。
</code></pre><p>如有错误，评论。</p>
<center><div style="border: 2px solid #999;border-top:none;border-left:none;width: 20px;height:20px;transform:rotate(45deg);"></div></center><br><center style="dispaly:block;width:300px;margin:0 auto"><span style="display:inline-block;float:left;width:100px;height:10px;border-top:1px solid #999;margin-top:15px;"></span><span><a href="https://github.com/Gong-Elory" target="_blank" rel="external">龚小样</a></span><span style=" display:inline-block;float:right;width:100px;height:10px;border-top:1px solid #999;margin-top:15px;"></span></center><br><center><span style="font-size:14px;line-height:14px;margin-top:0;">2016-11-5</span></center>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JavaScript具有自动垃圾收集机制，也就是说，执行环境会负责管理代码执行过程中使用的内存。&lt;br&gt;
    
    </summary>
    
      <category term="前端" scheme="http://gelory.me/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JS" scheme="http://gelory.me/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>JS实现快速排序</title>
    <link href="http://gelory.me/2016/11/05/Js%E5%AE%9E%E7%8E%B0%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    <id>http://gelory.me/2016/11/05/Js实现快速排序/</id>
    <published>2016-11-05T06:57:08.000Z</published>
    <updated>2016-11-05T07:14:02.789Z</updated>
    
    <content type="html"><![CDATA[<p>关于快速排序的理解。<br><a id="more"></a><br>快速排序的思想是：<br>1.从数列中找一个基准数。<br>2.把小于他的数放在基准数左边，剩余的放右边。<br>3.分别对左边和右边进行步骤1,2，知道区间内只有一个数。</p>
<p>其实可以把快排分为两个部分，<code>分</code>与<code>治</code>。因此用两个函数体概括两部分更加明了。</p>
<h2 id="治部分"><a href="#治部分" class="headerlink" title="治部分"></a>治部分</h2><p>该部分规定每一次排序采用的方法</p>
<pre><code>function cover(arr,left,right)
{
    var i = left;
    var j = right;
    var based = arr[i]; //去数列的第一个为基准数
    while(i&lt;j)
    {
        while(i&lt;j &amp;&amp; arr[j]&gt;=x) j--;
        if(i&lt;j) arr[i++] = arr[j];
        while(i&lt;j &amp;&amp; arr[i]&lt;=x) i++;
        if(i&lt;j) arr[j--] = arr[i];
    }
    arr[i] = based;
    return i//运行到这，其实i与j相等了，这一轮就弄完了
}
</code></pre><p>治部分可以这样理解。</p>
<p><div><span style="border:1px solid;padding:0.5rem">0</span><span style="border:1px solid;padding:0.5rem">1</span><span style="border:1px solid;padding:0.5rem">2</span><span style="border:1px solid;padding:0.5rem">3</span><span style="border:1px solid;padding:0.5rem">4</span></div><br></p>
<p><div><span style="color:#666;border:1px solid;padding:0.5rem">88</span><span style="border:1px solid;padding:0.5rem">21</span><span style="border:1px solid;padding:0.5rem">35</span><span style="border:1px solid;padding:0.5rem">12</span><span style="border:1px solid;padding:0.5rem">6</span><span style="color:#fff;background:#666;border:1px solid;padding:0.5rem">88</span></div><br></p>
<h3 id="步骤1：找基准数"><a href="#步骤1：找基准数" class="headerlink" title="步骤1：找基准数"></a>步骤1：找基准数</h3><p>这里有5个萝卜坑，每个坑里有一个萝卜。我现在去<code>arr[0]</code>为基准数，并赋值给<code>based</code>，就相当于把第一个坑里的萝卜放篮子里。</p>
<pre><code>var based = arr[i]; 
</code></pre><h3 id="步骤2：从后向前找小于基准数的数"><a href="#步骤2：从后向前找小于基准数的数" class="headerlink" title="步骤2：从后向前找小于基准数的数"></a>步骤2：从后向前找小于基准数的数</h3><p>然后从4开始往前找一个比篮子里的萝卜88更小的。<br>譬如，在图中我们就把<code>4号坑</code>里的萝卜放到了<code>0号坑</code>。<br>如果当前坑没有就继续往下找（<code>j--</code>）。这里用<code>i&lt;j</code>来限制什么时候停止寻找。<br>找到后，填到第一个坑里，即<code>arr[i]=arr[j]</code><br>之后是从前往后找大萝卜，是从刚填了小萝卜的后一个坑开始。所以是<code>i++</code>.合并了就是<code>arr[i++] = arr[j];</code><br>这就是代码中的这一段：</p>
<pre><code>while(i&lt;j &amp;&amp; arr[j]&gt;=x) j--; //挨个从后向前找小萝卜
if(i&lt;j) arr[i++] = arr[j]; //用小萝卜填坑
</code></pre><h3 id="步骤3：从前向后找大于基准数的数"><a href="#步骤3：从前向后找大于基准数的数" class="headerlink" title="步骤3：从前向后找大于基准数的数"></a>步骤3：从前向后找大于基准数的数</h3><p>此时<code>0号坑</code>里有了萝卜，但是<code>4号坑</code>没了。<br>那<code>4号坑</code>谁来填，我们从<code>1（步骤2中的i++导致的）号坑</code>开始向后寻找一个比<code>篮子里的萝卜</code>大的放在<code>4号坑</code>。坑里没有就<code>i++</code>，到下一个坑里找.这就是代码中的这一段：</p>
<pre><code>while(i&lt;j &amp;&amp; arr[i]&lt;=x) i++;// 挨个从前向后找大萝卜
if(i&lt;j) arr[j--] = arr[i]; //用大萝卜填坑
</code></pre><p><strong>这就是代码段中的循环过程：</strong></p>
<blockquote>
<p>从后向前（<code>j--</code>）找小萝卜填上一个坑<br>从前向后（<code>i++</code>）找大萝卜填上一个坑<br>从后向前（<code>j--</code>）找小萝卜填上一个坑<br>从前向后（<code>i++</code>）找大萝卜填上一个坑<br>…<br>直到 从前向后以及从后向前遇到了同一个坑<code>i=j</code>。</p>
</blockquote>
<pre><code>while(i&lt;j){
    //找萝卜。当i=j时就不会执行了
}
</code></pre><h3 id="步骤4-回填基准数"><a href="#步骤4-回填基准数" class="headerlink" title="步骤4 回填基准数"></a>步骤4 回填基准数</h3><p>最后，我们把篮子里的萝卜填到<code>i=j</code>的那个坑<code>arr[i] = based;</code></p>
<h2 id="分部分"><a href="#分部分" class="headerlink" title="分部分"></a>分部分</h2><p>该部分规定如何去调用治。</p>
<pre><code>function quick_sort(arr,l,r){
    if(l&lt;r)
    {
        var m = cover(arr,l,r); 
        quick_sort(arr,l,m-1);
        quick_sort(arr,m+1,r);
    }
}
</code></pre><p>经过第一次的治：<code>首次执行cover(arr,l,r)</code>，我们已经通过基准数把大于他的数放到了右边，小于他的数放在了左边。</p>
<p><div><span style="border:1px solid;padding:0.5rem">0</span><span style="border:1px solid;padding:0.5rem">1</span><span style="border:1px solid;padding:0.5rem">2</span><span style="border:1px solid;padding:0.5rem">3</span><span style="border:1px solid;padding:0.5rem">4</span></div><br></p>
<p><div><br><span style="border:1px solid;padding:0.5rem">6</span><span style="border:1px solid;padding:0.5rem">21</span> <span style="border:1px solid;padding:0.5rem">35</span><span style="border:1px solid;padding:0.5rem">12</span><span style="border:1px solid;padding:0.5rem">88</span><span style="color:#fff;background:#666;border:1px solid;padding:0.5rem">88</span></div><br><br>这个例子中，88最大所以他成了最后一个，小于他的全部在左边。但是发现没有，左边的数并不是从大到小的。于是我们把除开88之后，其他的坑在来进行一次换坑操作。如果88不是最大的。譬如</p>
<p><div><span style="border:1px solid;padding:0.5rem">6</span><span style="border:1px solid;padding:0.5rem">21</span> <span style="border:1px solid;padding:0.5rem">35</span><span style="border:1px solid;padding:0.5rem">12</span><span style="border:1px solid;padding:0.5rem">88</span><span style="border:1px solid;padding:0.5rem">106</span><span style="border:1px solid;padding:0.5rem">90</span> </div><br><br>那我们也要对88右边也进行换坑操作。</p>
<p>对左边的坑进行操作：</p>
<p><div><span style="border:1px solid;padding:0.5rem">6</span><span style="border:1px solid;padding:0.5rem">21</span><span style="border:1px solid;padding:0.5rem">35</span><span style="border:1px solid;padding:0.5rem">12</span></div><br><br>调用的是：</p>
<pre><code>quick_sort(arr,l,m-1);//m-1是为了排除88这个萝卜坑
//在这里面就会执行如下代码
if(i&lt;j)
    {
        var m = cover(arr,l,m-1); 
        quick_sort(arr,l,m-1);
        quick_sort(arr,m+1,m-1);
    }
</code></pre><p>对右边的坑进行操作：</p>
<p><div><span style="border:1px solid;padding:0.5rem">106</span><span style="border:1px solid;padding:0.5rem">90</span></div><br><br>调用的是：</p>
<pre><code>quick_sort(arr,m+1,r);//m+1是为了排除88这个萝卜坑
//在这里面就会执行如下代码
if(i&lt;j)
    {
        var m = cover(arr,m+1,r); 
        quick_sort(arr,m+1,m-1);
        quick_sort(arr,m+1,r);
    }
</code></pre><p>就这样不停地迭代调用 quick_sort 直到不能满足<code>if(l&lt;r)</code>就停止啦。</p>
<p>然后我们随便定义一个数组，试试看？</p>
<pre><code>var array = [9,8,5,8,7,6,5];
quick_sort(array,0,array.length-1);
alert(array);
</code></pre><h2 id="最后贴上合并版本的代码。"><a href="#最后贴上合并版本的代码。" class="headerlink" title="最后贴上合并版本的代码。"></a>最后贴上合并版本的代码。</h2><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><pre><code>//原地排序，不产生新的数组
function quicksorter(arr,start,end)
{
    var i =start;
    var j =end;
    var m;
    if(i&lt;j)
    {
        var x = arr[i];
        while(i &lt; j)
        {
            while(i &lt; j &amp;&amp; arr[j]&gt;=x) j--;
            if(i&lt;j )arr[i++]=arr[j];
            while(i&lt;j &amp;&amp; arr[i]&lt;=x) i++;
             if(i&lt;j) arr[j--]=arr[i];    
        }
        arr[i]=x;
        m=i;
        console.log(m);
        quicksorter(arr,start,m-1);
        quicksorter(arr,m+1,end);
    }
}
var array = [9,8,5,8,7,6,5];
var lili =quicksorter(array,0,array.length-1);
alert(array);
</code></pre><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><pre><code>//利用新数组来排序
var quicksort = function(arr)
{
    if(arr.length &lt;= 1) return arr;
    var based_var = arr[0];
    var left = [];
    var right = [];
    for(var i=1;i&lt;arr.length;i++)
    {
        if(arr[i]&lt;=based_var)
            left.push(arr[i]);
        else
            right.push(arr[i]);
    }
    return quicksort(left).concat(based_var,quicksort(right));
}
var array = [2,3,4,13,89,72,4,20,3,3,3,3,3,3,1,2];
var lili =quicksort(array)
alert(lili);
</code></pre><center><div style="border: 2px solid #999;border-top:none;border-left:none;width: 20px;height:20px;transform:rotate(45deg);"></div></center><br><center style="dispaly:block;width:300px;margin:0 auto"><span style="display:inline-block;float:left;width:100px;height:10px;border-top:1px solid #999;margin-top:15px;"></span><span><a href="https://github.com/Gong-Elory" target="_blank" rel="external">龚小样</a></span><span style=" display:inline-block;float:right;width:100px;height:10px;border-top:1px solid #999;margin-top:15px;"></span></center><br><center><span style="font-size:14px;line-height:14px;margin-top:0;">2016-11-5</span></center>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于快速排序的理解。&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="http://gelory.me/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="JS" scheme="http://gelory.me/tags/JS/"/>
    
      <category term="算法" scheme="http://gelory.me/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>call与apply，caller与callee</title>
    <link href="http://gelory.me/2016/11/04/call%E4%B8%8Eapply%EF%BC%8Ccaller%E4%B8%8Ecallee/"/>
    <id>http://gelory.me/2016/11/04/call与apply，caller与callee/</id>
    <published>2016-11-04T13:38:42.000Z</published>
    <updated>2016-11-06T07:05:05.573Z</updated>
    
    <content type="html"><![CDATA[<p>讲一下这两对的区别。<br><a id="more"></a></p>
<h2 id="call与apply"><a href="#call与apply" class="headerlink" title="call与apply"></a>call与apply</h2><p>call和apply都具有相同的作用，就是借别人的方法用，一句话，简洁明了。<br>什么意思呢？一个表达式表达出来：<code>b方法</code>.<code>call</code>(<code>a对象</code>,<code>a带的参数（可选）</code>);<br>这样a就可以用b方法啦。<br>具体到实例：</p>
<pre><code>function b(x，y){
    alert(&quot;我是&quot;+x+y)；
}
function a(){
    b.call(this,&quot;a&quot;,&quot;吧&quot;);//我是a吧
}

function  c(m,n){
    b.apply(this,arguments);//我是mn
    b.apply(this,[m,n])；// 我是mn
}
a();
c(&quot;m&quot;,&quot;n&quot;);
</code></pre><p>区别在于：call是直接把参数传过去，apply是把参数先放到一个数组，然后一块传。</p>
<p>那什么时候用哪一种呢？<br>明确参数的个数时，就用call，不知道有多少个参数时，就用apply。</p>
<h2 id="caller"><a href="#caller" class="headerlink" title="caller"></a>caller</h2><p>caller，该属性中保存着调用当前函数的函数的引用，简洁的说就是找出是<code>谁调用了</code>正在运行我的<code>这个函数体</code><br>举个栗子：</p>
<pre><code>function a()
{
 alert(a.caller)
}

function b(){
 a();
}
a();// null
b();//b
</code></pre><p>执行a();时，是js顶层调用的，所以返回null<br>执行b();时，是b调用了a，所以返回的是b的方法名。</p>
<h2 id="callee"><a href="#callee" class="headerlink" title="callee"></a>callee</h2><p>这个在匿名递归时用的最多。指向拥有arguments对象的函数，简洁的说就是找出callee运行的那个函数体<br>举个栗子：</p>
<pre><code>setTimeout(function(){
/*
*do something
*/
setTimeout(arguments.callee,100);//指向当前执行的函数，此时指向的是匿名函数。
},100)
</code></pre><p>当然，不嫌麻烦可以这样写。</p>
<pre><code>function bb(){
/*
*do something
*/
setTimeout(bb(),100);
}

setTimeout(bb(),100);
</code></pre><h2 id="使用caller，callee要注意的地方"><a href="#使用caller，callee要注意的地方" class="headerlink" title="使用caller，callee要注意的地方"></a>使用caller，callee要注意的地方</h2><p>在严格模式下，访问arguments.callee会报错。ES5也定义了arguments.caller。同样也会报错。在非严格模式下arguments.caller始终返回undefined。在严格模式下,为函数的caller赋值也会报错。</p>
<center><div style="border: 2px solid #999;border-top:none;border-left:none;width: 20px;height:20px;transform:rotate(45deg);"></div></center><br><center style="dispaly:block;width:300px;margin:0 auto"><span style="display:inline-block;float:left;width:100px;height:10px;border-top:1px solid #999;margin-top:15px;"></span><span><a href="https://github.com/Gong-Elory" target="_blank" rel="external">龚小样</a></span><span style=" display:inline-block;float:right;width:100px;height:10px;border-top:1px solid #999;margin-top:15px;"></span></center><br><center><span style="font-size:14px;line-height:14px;margin-top:0;">2016-11-4</span></center>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;讲一下这两对的区别。&lt;br&gt;
    
    </summary>
    
      <category term="前端" scheme="http://gelory.me/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="http://gelory.me/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="Js" scheme="http://gelory.me/tags/Js/"/>
    
  </entry>
  
  <entry>
    <title>setTimeout与setInterval的区别与互补</title>
    <link href="http://gelory.me/2016/11/04/setTimeout%E4%B8%8EsetInterval%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E4%BA%92%E8%A1%A5/"/>
    <id>http://gelory.me/2016/11/04/setTimeout与setInterval的区别与互补/</id>
    <published>2016-11-04T12:10:55.000Z</published>
    <updated>2016-11-04T12:15:57.347Z</updated>
    
    <content type="html"><![CDATA[<p>我们经常用这两种方法来处理延时或者定时任务。但是其中还是有一点区别与联系的。<br><a id="more"></a><br>setTimeout用于在<code>指定毫秒数后</code>进行相关操作。<code>只会执行一次。</code><br>setInterval用于<code>每隔指定毫秒数后循环</code>进行相关操作。<code>执行N次。</code></p>
<h2 id="定时并非那么精准"><a href="#定时并非那么精准" class="headerlink" title="定时并非那么精准"></a>定时并非那么精准</h2><p>原因：js运行在单线程中，当定时时间到后，并不是立即执行相关操作，而是把代码放到队列里等候执行。做好了执行的准备。至于为什么等，因为浏览器要先执行一些优先级较高的代码。</p>
<h2 id="既然setInterval可以重复定时，为什么要用setTimeout来实现重复定时。"><a href="#既然setInterval可以重复定时，为什么要用setTimeout来实现重复定时。" class="headerlink" title="既然setInterval可以重复定时，为什么要用setTimeout来实现重复定时。"></a>既然setInterval可以重复定时，为什么要用setTimeout来实现重复定时。</h2><p>setInterval在执行代码时，可能因为前一次代码执行时间超出了指定时间间隔，而导致下一次的的代码在队列中等待，直到前一次代码执行完。<br>js不允许一个队列中出现同一定时器的多次代码。因此只要队列中有一个，间隔时间到了，后面的代码将会被丢弃。<br><a href="http://qingbob.com/difference-between-settimeout-setinterval/" target="_blank" rel="external">这里没有图片，不直观，可以点击这里！</a><br>于是就会出现问题：<br>1.有些间隔就被忽略了。<br>2.假设间隔为100ms，如果前一次在190ms的时候结束，后一次的代码会在200ms时开始执行，因此实际运行间隔就不是100ms了<br>于是，鉴于这些缺点，setTimeout很好地弥补了这个缺点。因为如果这样写</p>
<pre><code>  setTimeout(function repeatMe() {     
/* Some long block of code... */   
setTimeout(repeatMe, 10);          
}, 10);
</code></pre><p>这样写的话，每次都是先执行外代码，然后创建了一个新的定时器，开始计时，于是就保证了间隔永远是指定时间</p>
<p>此外setTimeout还可以用在发生时间冒泡时，设置事件发生顺序。有时间在深入讨论冒泡捕获相关内容。</p>
<center><div style="border: 2px solid #999;border-top:none;border-left:none;width: 20px;height:20px;transform:rotate(45deg);"></div></center><br><center style="dispaly:block;width:300px;margin:0 auto"><span style="display:inline-block;float:left;width:100px;height:10px;border-top:1px solid #999;margin-top:15px;"></span><span><a href="https://github.com/Gong-Elory" target="_blank" rel="external">龚小样</a></span><span style=" display:inline-block;float:right;width:100px;height:10px;border-top:1px solid #999;margin-top:15px;"></span></center><br><center><span style="font-size:14px;line-height:14px;margin-top:0;">2016-11-4</span></center>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们经常用这两种方法来处理延时或者定时任务。但是其中还是有一点区别与联系的。&lt;br&gt;
    
    </summary>
    
      <category term="前端" scheme="http://gelory.me/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="http://gelory.me/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="Js" scheme="http://gelory.me/tags/Js/"/>
    
  </entry>
  
  <entry>
    <title>innerHTML相关知识点总结</title>
    <link href="http://gelory.me/2016/11/03/innerHTML%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"/>
    <id>http://gelory.me/2016/11/03/innerHTML相关知识点总结/</id>
    <published>2016-11-03T14:25:28.000Z</published>
    <updated>2016-11-03T14:26:38.761Z</updated>
    
    <content type="html"><![CDATA[<p>这里总结了和innerHTML有联系的一些知识点。<br><a id="more"></a></p>
<h2 id="innerHTML相关属性的区别"><a href="#innerHTML相关属性的区别" class="headerlink" title="innerHTML相关属性的区别"></a>innerHTML相关属性的区别</h2><p>innerHTML:获取或者设置位于对象起止标签内的HTML<br>innerText：获取设置位于对象起止标签内的文本<br>outerHTML：获取设置包括对象起止标签的HTML<br>outerText：设置包括标签的文本，获取不包括标签的文本。<br>譬如：</p>
<pre><code>&lt;div&gt;content&lt;br/&gt;&lt;/div&gt;
</code></pre><p>innerHTML：<code>content&lt;br/&gt;</code><br>innerText： <code>content</code><br>outerHTML： <code>&lt;div&gt;content&lt;br/&gt;&lt;/div&gt;</code><br>outerText： <code>content</code>//如果修改该值的话，会把<code>&lt;div&gt;content&lt;br/&gt;&lt;/div&gt;</code>覆盖掉。</p>
<p>innerHTML虽然并不是W3C DOM标准的组成部分，但是符合HTML5规范。innerText只适用于IE浏览器，所以考虑兼容性的话，尽量使用innerHTML。如果只需要标签内文本的话，可以使用正则表达式过滤。</p>
<h2 id="innerHTML与document-write-的区别"><a href="#innerHTML与document-write-的区别" class="headerlink" title="innerHTML与document.write()的区别"></a>innerHTML与document.write()的区别</h2><blockquote>
<ul>
<li>定义：innerHTML是DOM元素对象的一个属性，write是document对象的一个方法。</li>
<li>用途：innerHTML属性可以用来获取、修改指定元素内的所有标签和内容。而document.write()对整个文档流进行重写。</li>
<li>原理：innerHTML是对属性设置，代表的是该元素的HTML内容，可以精准的对某一元素进行修改。document.write()创建一个新的文档输出流，向HTML输出流写内容，如果在文档渲染完毕后使用，则会迫使浏览器重新渲染。</li>
<li>优劣：document.write（）最大的缺点是违背了<code>行为应为与结构分离</code>的原则，也就是js应该与html代码分离。<br>innerHTML在很多情况下优于document.write()，原因是前者允许精准修改某一部分。缺点：相对于DOM方法和属性，innerHTML没有细节而言，他获取的是整个内容。</li>
</ul>
</blockquote>
<center><div style="border: 2px solid #999;border-top:none;border-left:none;width: 20px;height:20px;transform:rotate(45deg);"></div></center><br><center style="dispaly:block;width:300px;margin:0 auto"><span style="display:inline-block;float:left;width:100px;height:10px;border-top:1px solid #999;margin-top:15px;"></span><span><a href="https://github.com/Gong-Elory" target="_blank" rel="external">龚小样</a></span><span style=" display:inline-block;float:right;width:100px;height:10px;border-top:1px solid #999;margin-top:15px;"></span></center><br><center><span style="font-size:14px;line-height:14px;margin-top:0;">2016-11-3</span></center>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这里总结了和innerHTML有联系的一些知识点。&lt;br&gt;
    
    </summary>
    
      <category term="前端" scheme="http://gelory.me/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="http://gelory.me/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="DOM" scheme="http://gelory.me/tags/DOM/"/>
    
  </entry>
  
  <entry>
    <title>JS中全局变量和局部变量的区别</title>
    <link href="http://gelory.me/2016/11/03/JS%E4%B8%AD%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%92%8C%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://gelory.me/2016/11/03/JS中全局变量和局部变量的区别/</id>
    <published>2016-11-03T06:12:17.000Z</published>
    <updated>2016-11-03T06:14:06.022Z</updated>
    
    <content type="html"><![CDATA[<p>什么是局部变量，用var操作符定义的变量将成为该变量作用域中的局部变量。其实可以这样理解，全局变量也是局部变量，只不过他是在<code>&lt;script&gt;&lt;/script&gt;</code>包含的作用域下的局部变量。但是通常情况下，我们参考的标准的function域，也就是说在<code>function域中用var定义的变量称为在该作用域下的局部变量</code>，那么剩余的就是全局变量了。<br><a id="more"></a></p>
<h2 id="哪些方式可以生成全局变量与局部变量："><a href="#哪些方式可以生成全局变量与局部变量：" class="headerlink" title="哪些方式可以生成全局变量与局部变量："></a>哪些方式可以生成全局变量与局部变量：</h2><pre><code>var a=0; //全局变量1
b=0; //全局变量2
window.str3 = &quot;hello3&quot;; //全局变量3
function(){
    var d = 0；//局部变量4
    e=0; //全局变量5
}
</code></pre><p>全局变量2，5，虽说这样可以定义全局变量，但是不推荐这样做，因为如果你养成了这样定义全局变量的习惯，如果有一天一不小心，原本应该定位为局部变量的变量，由于忘记了var，变成了全局变量，那么找bug将会很困难，因为在你潜意识中，看到这个变量，你以为是在这里定义了个全局变量，其实是忘写var了。<strong>所以，不要有意识的去不写var</strong>。 此外给未经声明的变量赋值，在严格模式下会抛出<code>ReferenceError</code>错误。</p>
<h2 id="局部变量的陷阱"><a href="#局部变量的陷阱" class="headerlink" title="局部变量的陷阱"></a>局部变量的陷阱</h2><h3 id="陷阱1"><a href="#陷阱1" class="headerlink" title="陷阱1"></a>陷阱1</h3><p>在作用域当中，在声明前使用局部变量不会报错，但因为没有赋值，所以返回的是undefined。</p>
<pre><code>function test(){  
    alert(a);  //1.此时显示的为undefined
    var a=4;
    alert(a); //2.此时显示的是4
} 
</code></pre><p>原因：js在执行前会对整个脚本文件分析，因此1不会报错，而只是因为在此前没对a赋值，所以显示undefined。<br>之所以2处会显示a，是因为在此之前对a进行赋值了。<br>因此需要注意两点：</p>
<blockquote>
<ul>
<li><p>在引用局部变量时，与局部变量的声明地点无关，局部变量的作用域为整个function域。</p>
</li>
<li><p>在使用局部变量的值时，与局部变量的赋值地点有关，赋值的作用域起于赋值地点，止于function域结束，可以被覆盖。</p>
</li>
</ul>
</blockquote>
<h3 id="陷阱2"><a href="#陷阱2" class="headerlink" title="陷阱2"></a>陷阱2</h3><p>局部变量的划分是以function块为标准，而for、while、if块不是。</p>
<pre><code>function test(){  
        for(var i=0;i&lt;3;i++)
        {
            alert(i); //1.此时显示的是0,1,2
        }
        alert(i) //2.此时显示的是2
    } 
</code></pre><p>原因：在for内进行声明的变量属于局部变量，他的作用域在整个function域内，而不仅仅只for域内，因此2处显示的是2，而不是报错。<br>因此注意一点</p>
<blockquote>
<ul>
<li>局部变量的划分是以function块为标准。</li>
</ul>
</blockquote>
<h3 id="陷阱3"><a href="#陷阱3" class="headerlink" title="陷阱3"></a>陷阱3</h3><p>如果全局变量和局部变量的变量名相同，采取的是谁近听谁的原则。</p>
<pre><code>var a = 0;
function test(){  
        var a = 1;
        alert(a); //1.此时显示的是1
    }
alert(a); //2.此时显示的是0
</code></pre><p>原因：1在function域下,其直接父域是function，所以听局部声明。2.的直接父域是script域,所以听全局声明<br>注意一点</p>
<blockquote>
<ul>
<li>重名时，局部变量覆盖全局变量声明，跳出局部变量所在域后，由全局声明决定变量值。</li>
</ul>
</blockquote>
<p>那怎样才能在这种情况下，在function域中使用全局变量呢？<br>1.改名。天涯何处无芳草，何必吊死于一树。<br>2.在function域中使用<code>window.变量名</code>就可以调用全局变量啦。</p>
<pre><code>alert(window.a); //此时显示的是0
</code></pre><center><div style="border: 2px solid #999;border-top:none;border-left:none;width: 20px;height:20px;transform:rotate(45deg);"></div></center><br><center style="dispaly:block;width:300px;margin:0 auto"><span style="display:inline-block;float:left;width:100px;height:10px;border-top:1px solid #999;margin-top:15px;"></span><span><a href="https://github.com/Gong-Elory" target="_blank" rel="external">龚小样</a></span><span style=" display:inline-block;float:right;width:100px;height:10px;border-top:1px solid #999;margin-top:15px;"></span></center><br><center><span style="font-size:14px;line-height:14px;margin-top:0;">2016-11-3</span></center>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;什么是局部变量，用var操作符定义的变量将成为该变量作用域中的局部变量。其实可以这样理解，全局变量也是局部变量，只不过他是在&lt;code&gt;&amp;lt;script&amp;gt;&amp;lt;/script&amp;gt;&lt;/code&gt;包含的作用域下的局部变量。但是通常情况下，我们参考的标准的function域，也就是说在&lt;code&gt;function域中用var定义的变量称为在该作用域下的局部变量&lt;/code&gt;，那么剩余的就是全局变量了。&lt;br&gt;
    
    </summary>
    
      <category term="前端" scheme="http://gelory.me/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="http://gelory.me/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JS" scheme="http://gelory.me/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>Viewport的深入了解</title>
    <link href="http://gelory.me/2016/11/02/Viewport%E7%9A%84%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3/"/>
    <id>http://gelory.me/2016/11/02/Viewport的深入了解/</id>
    <published>2016-11-02T05:59:06.000Z</published>
    <updated>2016-11-02T06:00:35.197Z</updated>
    
    <content type="html"><![CDATA[<p>刚接触移动端网页开发，之前不知带要设置页面缩放属性，导致正常字体小的出奇，这次对viewport进一步深入学习。<br><a id="more"></a></p>
<h2 id="viewport定义"><a href="#viewport定义" class="headerlink" title="viewport定义"></a>viewport定义</h2><p>就像英文字面翻译一样，能看得到的区域。viewport指的是显示网页的区域。但是因为viewport按特性可以分为三类，所以viewport又不仅仅是浏览器可视区域那么大。</p>
<p>譬如一般移动端浏览器显示屏宽度都是320px 480px等。但是移动设备的viewport默认宽度是980px或者1024px。这个值可以自己设置。</p>
<h2 id="物理像素与CSS像素的区别与联系"><a href="#物理像素与CSS像素的区别与联系" class="headerlink" title="物理像素与CSS像素的区别与联系"></a>物理像素与CSS像素的区别与联系</h2><p>在桌面浏览器中，CSS的1px是等于屏幕上的1个物理像素的。 但是在移动设备中可就不一定，譬如Retina屏，一个CSS像素相当于两个物理像素。</p>
<h3 id="屏幕尺寸和像素尺寸的区别与联系"><a href="#屏幕尺寸和像素尺寸的区别与联系" class="headerlink" title="屏幕尺寸和像素尺寸的区别与联系"></a>屏幕尺寸和像素尺寸的区别与联系</h3><p>屏幕的尺寸和像素尺寸不是一样的  譬如ipone3和iphone4都是320px的宽屏。但是前者像素是320px，后者采用retina屏，像素是640px。<br>安卓设备也是一样，根据像素密度分为ldpi，mdpi，hdpi，xhdpi等不同等级。</p>
<h3 id="用户缩放导致CSS像素与物理像素的比值差异"><a href="#用户缩放导致CSS像素与物理像素的比值差异" class="headerlink" title="用户缩放导致CSS像素与物理像素的比值差异"></a>用户缩放导致CSS像素与物理像素的比值差异</h3><p>如果用户把页面放大一倍，首先，屏幕尺寸是不会变的，1个CSS像素如果以前相当于一个物理像素，此时，就相当于两个物理像素了，那么我们看到的景象就是字体什么的放大了。</p>
<h2 id="viewport按表现类型分三类"><a href="#viewport按表现类型分三类" class="headerlink" title="viewport按表现类型分三类"></a>viewport按表现类型分三类</h2><p>layout viewport 大于浏览器可视区域宽度<br>visual biewport 浏览器可视区域宽度<br>ideal viewport 完美适配移动端屏幕的宽度</p>
<p>只要在CSS中把某一元素的宽度设置为ideal viewport的宽度，那么这个元素的宽度就是设备屏幕的宽度。</p>
<h2 id="利用meta元标签对viewport进行控制"><a href="#利用meta元标签对viewport进行控制" class="headerlink" title="利用meta元标签对viewport进行控制"></a>利用meta元标签对viewport进行控制</h2><p>移动设备默认的是layout viewport。但是进行移动设备网站开发时，我们需要ideal viewport。</p>
<pre><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0&quot;&gt;
</code></pre><p>这个标签的作用就是让当前页面的宽度等于设备的宽度，不允许手动缩放。</p>
<h2 id="meta-viewport的6个属性"><a href="#meta-viewport的6个属性" class="headerlink" title="meta viewport的6个属性"></a>meta viewport的6个属性</h2><p>width：设置layout viewport的宽度。可以使整数，也可以设置为width-device。当设置为width-device时，自动适配屏幕宽度。<br>height：设置layout viewport的高度。<br>initial-scale：设置页面加载时的缩放值，可以是小数。相对于ideal-viewport值进行缩放。<br>minimum-scale：允许用户的最小缩放值。<br>maximum-scale：允许用户的最大缩放值。<br>user-scalable：是否允许用户手动缩放。 值为’yes’ or ‘no’。</p>
<p>经证明：<br>    <meta name="viewport" content="width=device-width, initial-scale=1"></p>
<p>可以让大部分的移动端设备的viewport设置为ideal viewport。</p>
<center><div style="border: 2px solid #999;border-top:none;border-left:none;width: 20px;height:20px;transform:rotate(45deg);"></div></center><br><center style="dispaly:block;width:300px;margin:0 auto"><span style="display:inline-block;float:left;width:100px;height:10px;border-top:1px solid #999;margin-top:15px;"></span><span><a href="https://github.com/Gong-Elory" target="_blank" rel="external">龚小样</a></span><span style=" display:inline-block;float:right;width:100px;height:10px;border-top:1px solid #999;margin-top:15px;"></span></center><br><center><span style="font-size:14px;line-height:14px;margin-top:0;">2016-11-2</span></center>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;刚接触移动端网页开发，之前不知带要设置页面缩放属性，导致正常字体小的出奇，这次对viewport进一步深入学习。&lt;br&gt;
    
    </summary>
    
      <category term="前端" scheme="http://gelory.me/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="http://gelory.me/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="CSS" scheme="http://gelory.me/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>Webkit内核显示字体自动放大问题</title>
    <link href="http://gelory.me/2016/10/26/Webkit%E5%86%85%E6%A0%B8%E6%98%BE%E7%A4%BA%E5%AD%97%E4%BD%93%E8%87%AA%E5%8A%A8%E6%94%BE%E5%A4%A7%E9%97%AE%E9%A2%98/"/>
    <id>http://gelory.me/2016/10/26/Webkit内核显示字体自动放大问题/</id>
    <published>2016-10-26T09:21:21.000Z</published>
    <updated>2016-10-26T09:23:02.519Z</updated>
    
    <content type="html"><![CDATA[<p>在做移动端页面时，出现了这么个抓狂的问题。明明设置的font-size值为20px，但是computed下的font-size值缺为56px，吓得我看是怀疑人生。<br><a id="more"></a><br>这个东西不是bug也不是hack，是Chromium内核为了提高移动端文本可读性，而增加的一个特性。还有个学名叫<code>Text Autosizer</code> 这个算法呢会根据缩放比例，字体大小，屏幕分辨率等特性，将开发人员设置的字体大小值做一系列运算，然后显示。意思就是：它认为你这样用户会看不清。于是助你一臂之力。</p>
<p>那如何禁用这个特性呢？有人说给文本增加宽高，真是脑洞大。<br>最直接的方法就是设置<br><code>max-height=100%；</code>设置元素的最大宽度。<br>当然你也可以设置viewport元标签内的initial-scale属性为1。initial-scale属性控制页面最初加载时的缩放等级。更多关于元标签的信息可以看我遇到的另一个问题<a href="http://gelory.me/2016/10/26/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%98%BE%E7%A4%BA%E6%97%B6%E9%A1%B5%E9%9D%A2%E7%BC%A9%E6%94%BE%E9%97%AE%E9%A2%98/">移动端显示时页面缩放问题</a>.</p>
<center><div style="border: 2px solid #999;border-top:none;border-left:none;width: 20px;height:20px;transform:rotate(45deg);"></div></center><br><center style="dispaly:block;width:300px;margin:0 auto"><span style="display:inline-block;float:left;width:100px;height:10px;border-top:1px solid #999;margin-top:15px;"></span><span><a href="https://github.com/Gong-Elory" target="_blank" rel="external">龚小样</a></span><span style=" display:inline-block;float:right;width:100px;height:10px;border-top:1px solid #999;margin-top:15px;"></span></center><br><center><span style="font-size:14px;line-height:14px;margin-top:0;">2016-10-26</span></center>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在做移动端页面时，出现了这么个抓狂的问题。明明设置的font-size值为20px，但是computed下的font-size值缺为56px，吓得我看是怀疑人生。&lt;br&gt;
    
    </summary>
    
      <category term="前端" scheme="http://gelory.me/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="http://gelory.me/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="CSS" scheme="http://gelory.me/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>移动端显示时页面缩放问题</title>
    <link href="http://gelory.me/2016/10/26/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%98%BE%E7%A4%BA%E6%97%B6%E9%A1%B5%E9%9D%A2%E7%BC%A9%E6%94%BE%E9%97%AE%E9%A2%98/"/>
    <id>http://gelory.me/2016/10/26/移动端显示时页面缩放问题/</id>
    <published>2016-10-26T08:47:07.000Z</published>
    <updated>2016-10-26T09:23:02.519Z</updated>
    
    <content type="html"><![CDATA[<p>在做简易自适应布局时，出现了一个问题，硬是折磨了我一天。同样是16px的字体，在手机上显示，连放大镜都找不到。此外，横屏的时候，字体又变得出奇的大。试了网上的某些添加属性值方法都不管用。其实问题出在页面身上，字体是无过的。<br><a id="more"></a><br>一个典型的针对移动端优化的站点会包含类似下面的内容。</p>
<p><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><br>width可以是固定值，也可以是device-width这一变量，代表虚拟窗口的宽度。</p>
<p>initial-scale属性控制页面最初加载时的缩放等级。<br>maximum-scale、minimum-scale控制页面最大缩放比例和最小缩放比例。<br>user-scalable属性控制允许用户缩放页面</p>
<p>我当初遇到的问题就是没有设置元标签的内容，导致手机为了适应屏幕宽度，而缩小页面。<br><strong>如果想要保证页面不缩放，可以设置maximum-scale、minimum-scale都为1.</strong><br>user-scalable=no这样设置有的浏览器不保证所有浏览器都会不缩放页面</p>
<center><div style="border: 2px solid #999;border-top:none;border-left:none;width: 20px;height:20px;transform:rotate(45deg);"></div></center><br><center style="dispaly:block;width:300px;margin:0 auto"><span style="display:inline-block;float:left;width:100px;height:10px;border-top:1px solid #999;margin-top:15px;"></span><span><a href="https://github.com/Gong-Elory" target="_blank" rel="external">龚小样</a></span><span style=" display:inline-block;float:right;width:100px;height:10px;border-top:1px solid #999;margin-top:15px;"></span></center><br><center><span style="font-size:14px;line-height:14px;margin-top:0;">2016-10-26</span></center>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在做简易自适应布局时，出现了一个问题，硬是折磨了我一天。同样是16px的字体，在手机上显示，连放大镜都找不到。此外，横屏的时候，字体又变得出奇的大。试了网上的某些添加属性值方法都不管用。其实问题出在页面身上，字体是无过的。&lt;br&gt;
    
    </summary>
    
      <category term="前端" scheme="http://gelory.me/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="http://gelory.me/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="HTML" scheme="http://gelory.me/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>px，em，rem单位的区别与联系</title>
    <link href="http://gelory.me/2016/10/26/px%EF%BC%8Cem%EF%BC%8Crem%E5%8D%95%E4%BD%8D%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E8%81%94%E7%B3%BB/"/>
    <id>http://gelory.me/2016/10/26/px，em，rem单位的区别与联系/</id>
    <published>2016-10-26T08:23:57.000Z</published>
    <updated>2016-10-26T09:08:04.537Z</updated>
    
    <content type="html"><![CDATA[<p>在重构页面时，经常会用到px，em等单位来设置距离，大小。但是用px还好，em时稍不留心，参考大小就弄错了，然后计算出一个错误的距离，还用得不亦乐乎。<br><a id="more"></a><br>px（Pixel）这个单位是相当于显示器的分辨率来说的。</p>
<h2 id="em的特点"><a href="#em的特点" class="headerlink" title="em的特点"></a>em的特点</h2><blockquote>
<ul>
<li>表示字体大小时，是相对其父元素字体大小的倍数而言的。<br>譬如该父元素字体大小为16px，那么1.5em=1.5*16px=24px</li>
<li>在表示距离，宽高的时候，是相对其自身元素字体大小而言的，这个极为重要。<br>譬如父元素字体大小为16px 自身元素字体大小为24px（或者（1.5em）），那么margin-top：2em，这里换算为px值是48px，而不是32px。</li>
</ul>
</blockquote>
<p>任何浏览器的默认字体大小都是16px，那我们每次算像素值，然后用em表示，岂不是相当麻烦。是的，很麻烦。为了简化运算，经常会在body选择器中声明</p>
<pre><code>font-size：62.5%
</code></pre><p>意思是参考值变为原来的.625倍，也就是16*0.625=10px。那么之后在算em就是以这个为基准了。譬如23像素就可以表示为2.3em。</p>
<p>但我还是觉得麻烦啊！每次还要考虑其父元素的大小，考虑自身元素字体大小，操着卖白粉的心啊！<br>是的！ 考虑到这个原因在CSS3中新增了rem这个相对单位。</p>
<h2 id="rem和em的区别"><a href="#rem和em的区别" class="headerlink" title="rem和em的区别"></a>rem和em的区别</h2><p>rem永远相对于根元素，也就是说不需要考虑他的父元素大小了，统一以根元素的字体大小作为基准。此时设置文档根元素html标签的字体</p>
<p>font-size：62.5%</p>
<p>来使1rem 代表 10px。</p>
<p>这个在自适应布局用途非常的广，譬如设计稿给的宽度是640px，此时根元素设置的是20px  那么10rem代表200px，如果想在屏幕宽度为320px的移动端也适用这一套，只需要根据屏幕宽度比去计算在320px下html的字体大小值就行了。不需要去具体改动其他元素的值。</p>
<h2 id="rem的兼容性"><a href="#rem的兼容性" class="headerlink" title="rem的兼容性"></a>rem的兼容性</h2><blockquote>
<ul>
<li>支持 IE9+</li>
</ul>
</blockquote>
<p>IE9/IE10在用于伪元素时或者使用字体简写声明时不支持rem；</p>
<blockquote>
<ul>
<li>支持 FireFox3.5+</li>
<li>支持Chrome 6+</li>
<li>支持 Safari 5+</li>
<li>支持Opera 11.6+</li>
<li>支持IOS Safari 4.1+</li>
</ul>
</blockquote>
<p>IOS Safari5.0-5.1虽然支持rem，但是在使用媒体查询时不支持rem。</p>
<blockquote>
<ul>
<li>支持Android2.1+ 微信页面可能不起作用</li>
</ul>
</blockquote>
<p>如果兼容性不支持，那么就采用px 和rem一起写的方式。</p>
<p>rem和em可以一起用，但是这样不嫌麻烦吗？</p>
<h2 id="小样有话说："><a href="#小样有话说：" class="headerlink" title="小样有话说："></a>小样有话说：</h2><center style="color:green;font-weight: Bold;border:1px dotted #999">能用rem尽量用，不兼容就混合用，迟早是它的天下！</center>

<center><div style="border: 2px solid #999;border-top:none;border-left:none;width: 20px;height:20px;transform:rotate(45deg);"></div></center><br><center style="dispaly:block;width:300px;margin:0 auto"><span style="display:inline-block;float:left;width:100px;height:10px;border-top:1px solid #999;margin-top:15px;"></span><span><a href="https://github.com/Gong-Elory" target="_blank" rel="external">龚小样</a></span><span style=" display:inline-block;float:right;width:100px;height:10px;border-top:1px solid #999;margin-top:15px;"></span></center><br><center><span style="font-size:14px;line-height:14px;margin-top:0;">2016-10-26</span></center>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在重构页面时，经常会用到px，em等单位来设置距离，大小。但是用px还好，em时稍不留心，参考大小就弄错了，然后计算出一个错误的距离，还用得不亦乐乎。&lt;br&gt;
    
    </summary>
    
      <category term="前端" scheme="http://gelory.me/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="http://gelory.me/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="CSS" scheme="http://gelory.me/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>Absolute定位的进一步认识</title>
    <link href="http://gelory.me/2016/10/24/Absolute%E5%AE%9A%E4%BD%8D%E7%9A%84%E8%BF%9B%E4%B8%80%E6%AD%A5%E8%AE%A4%E8%AF%86/"/>
    <id>http://gelory.me/2016/10/24/Absolute定位的进一步认识/</id>
    <published>2016-10-24T09:10:48.000Z</published>
    <updated>2016-10-24T09:12:24.176Z</updated>
    
    <content type="html"><![CDATA[<p>在我印象中，我一直认为absolute是离不开另外一个属性值：relative的。因为这种现象很常见：当我们要使用相对定位是，经常会给父元素设置一个relative属性值，然后给子元素设置一个absolute属性值。然后通过控制子元素top，left等样式来控制子元素的定位。这种使用方法没有错误？但是呢，却没有更好的利用absolute的属性，代码比较冗杂。absolute绝对定位还有很多不为人知的秘密，今天就来扒一扒。<br><a id="more"></a></p>
<h2 id="无依赖的absolute定位"><a href="#无依赖的absolute定位" class="headerlink" title="无依赖的absolute定位"></a>无依赖的absolute定位</h2><p>我们经常会遇到这样的案例：某个标题右上角打上hot标签，或者某个商品图片右上角打上特惠图片。<br>相信很多人第一想法是，先给包容图片和这个标签的父元素设置position属性值为relative，然后设置这个标签的该属性值为absolute，然后通过top和right值去设置相对位置。<br>然而如果知道absolute的无依赖定位后，你就不需要给父元素设置position值，不用top，right值去位置。<br>那怎么做呢？<br>我们只设置</p>
<pre><code>&lt;span class=&quot;biaoqian&quot; style=&quot;position:absolute;margin-left:-30px&quot;&gt;&lt;/span&gt;
</code></pre><p>类似这样的形式即可实现上述功能。原因是，当给某元素设置absolute后，他在屏幕中的位置是不变的，只不过宽高没有了，不存在于文档流中了。所以，如果这个标签放在图片的后面，absolute之后，位置依然在图片之后。想要把他移到图片上，只需给一个margin-left负值即可。</p>
<p>采用Relative遵循两个原则：</p>
<blockquote>
<ul>
<li>能不用就不用</li>
<li>要用尽量范围涉及小</li>
</ul>
</blockquote>
<h2 id="absolute定位的对宽高的替代性"><a href="#absolute定位的对宽高的替代性" class="headerlink" title="absolute定位的对宽高的替代性"></a>absolute定位的对宽高的替代性</h2><p>经常我们需要某元素能够自适应宽高其父元素？我们除了用width，height的100%外加top=0来实现外，还可以利用top，right，bottom，left同时为0时来显示。</p>
<h2 id="absolute定位对fixed定位的替代性"><a href="#absolute定位对fixed定位的替代性" class="headerlink" title="absolute定位对fixed定位的替代性"></a>absolute定位对fixed定位的替代性</h2><p>在整体布局时，尤其是为了适应移动端，经常会使用fixed来定位header和footer。除了可以用fixed定位外，absolute同样也适用。</p>
<pre><code>html body{
    width:100%;
    height:100%
}

header,footer{
display:absolute;
right:0;
lrft:0;
width:50px;
}

.content{
display:absolute;
top:50px;
bottom:50px;
overflow:auto;
}
</code></pre><p>这样就ok了。</p>
<h2 id="absolute与宽高百分比的合作性"><a href="#absolute与宽高百分比的合作性" class="headerlink" title="absolute与宽高百分比的合作性"></a>absolute与宽高百分比的合作性</h2><p>当我们同时设置top，right，bottom，left为0，设置width=50%时，此时改元素的宽度是50%。<br>那此时right，left岂不是打酱油了？没有。合作性在此处体现：<br>当满足上面条件的同时，在加上margin：auto，会产生绝对定位元素水平居中的效果。次特性支持IE8+。</p>
<center><div style="border: 2px solid #999;border-top:none;border-left:none;width: 20px;height:20px;transform:rotate(45deg);"></div></center><br><center style="dispaly:block;width:300px;margin:0 auto"><span style="display:inline-block;float:left;width:100px;height:10px;border-top:1px solid #999;margin-top:15px;"></span><span><a href="https://github.com/Gong-Elory" target="_blank" rel="external">龚小样</a></span><span style=" display:inline-block;float:right;width:100px;height:10px;border-top:1px solid #999;margin-top:15px;"></span></center><br><center><span style="font-size:14px;line-height:14px;margin-top:0;">2016-10-24</span></center>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在我印象中，我一直认为absolute是离不开另外一个属性值：relative的。因为这种现象很常见：当我们要使用相对定位是，经常会给父元素设置一个relative属性值，然后给子元素设置一个absolute属性值。然后通过控制子元素top，left等样式来控制子元素的定位。这种使用方法没有错误？但是呢，却没有更好的利用absolute的属性，代码比较冗杂。absolute绝对定位还有很多不为人知的秘密，今天就来扒一扒。&lt;br&gt;
    
    </summary>
    
      <category term="前端" scheme="http://gelory.me/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="http://gelory.me/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="CSS" scheme="http://gelory.me/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>外边距塌陷相关问题的解决方案</title>
    <link href="http://gelory.me/2016/10/23/%E5%A4%96%E8%BE%B9%E8%B7%9D%E5%A1%8C%E9%99%B7%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>http://gelory.me/2016/10/23/外边距塌陷相关问题的解决方案/</id>
    <published>2016-10-23T04:34:53.000Z</published>
    <updated>2016-10-23T04:38:31.139Z</updated>
    
    <content type="html"><![CDATA[<p>最近，在写代码时发现了这样一个问题。两个div元素的间距为0，我想为下面一个div元素的第一个子元素添加一个上外边距，结果该距离直接转化成了两个div元素的距离，于是只能用改变这个子元素的内边距去达到这个效果。后来知道这种现象又有个学名叫<code>外边距塌陷</code>.<br><a id="more"></a><br><code>外边距塌陷（margin collapse）</code>：块元素的外边距有时候会发生合并为单个外边距的现象，就称为外边距塌陷。</p>
<p>这个现象发生的原因是因为：按照规范，一个盒子没有padding-top和border-top，那么这个盒子的上边距会和其内部文档流中的第一个子元素的上边距重叠。</p>
<p>这种现象有多种表现形式（)：<br>1.块级父元素（该元素没有设置border，paddding，清除浮动属性时） 和第一个子元素的margin-top合并。<br>解决方法：</p>
<blockquote>
<ul>
<li>设置border padding值。</li>
<li>在第一个子元素与父元素之间添加一个空块，并设置padding值</li>
<li>给父元素设置overflow：hidden；</li>
<li>给内层或者外层div设置float，float:left;</li>
<li>给内层或者外层设置position，position:absolute;</li>
</ul>
</blockquote>
<p>2.块级父元素（该元素没有<code>height</code>，border，paddding，清除浮动属性时），与其最后一个子元素的margin-bottom也会产生这种现象。<br>解决方法同上。</p>
<p>3.两相邻兄弟元素（没限制条件）<br>前一个兄弟元素的下边距会和下一个兄弟元素的上边距重合，选最大的显示。譬如前者下边距是30px后者上边距是40px，最终两元素的间距是40px。<br>解决方法：</p>
<blockquote>
<ul>
<li>设置一个元素的边距值就行了。</li>
</ul>
</blockquote>
<p>4.空块元素的上下边距合并 该元素没有设置border，padding，height相关属性时。<br>解决方法：</p>
<blockquote>
<ul>
<li>设置border，padding，height相关属性时。</li>
</ul>
</blockquote>
<h2 id="小样有话说："><a href="#小样有话说：" class="headerlink" title="小样有话说："></a>小样有话说：</h2><center style="color:green;font-weight: Bold;border:1px dotted #999">这个现象很常见，总算是弄明白原因了。</center>

<center><div style="border: 2px solid #999;border-top:none;border-left:none;width: 20px;height:20px;transform:rotate(45deg);"></div></center><br><center style="dispaly:block;width:300px;margin:0 auto"><span style="display:inline-block;float:left;width:100px;height:10px;border-top:1px solid #999;margin-top:15px;"></span><span><a href="https://github.com/Gong-Elory" target="_blank" rel="external">龚小样</a></span><span style=" display:inline-block;float:right;width:100px;height:10px;border-top:1px solid #999;margin-top:15px;"></span></center><br><center><span style="font-size:14px;line-height:14px;margin-top:0;">2016-10-23</span></center>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近，在写代码时发现了这样一个问题。两个div元素的间距为0，我想为下面一个div元素的第一个子元素添加一个上外边距，结果该距离直接转化成了两个div元素的距离，于是只能用改变这个子元素的内边距去达到这个效果。后来知道这种现象又有个学名叫&lt;code&gt;外边距塌陷&lt;/code&gt;.&lt;br&gt;
    
    </summary>
    
      <category term="前端" scheme="http://gelory.me/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="http://gelory.me/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="CSS" scheme="http://gelory.me/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>inline-block元素之间间隙的去除法</title>
    <link href="http://gelory.me/2016/10/20/inline-block%E5%85%83%E7%B4%A0%E4%B9%8B%E9%97%B4%E9%97%B4%E9%9A%99%E7%9A%84%E5%8E%BB%E9%99%A4%E6%B3%95/"/>
    <id>http://gelory.me/2016/10/20/inline-block元素之间间隙的去除法/</id>
    <published>2016-10-20T06:57:01.000Z</published>
    <updated>2016-10-20T07:05:24.546Z</updated>
    
    <content type="html"><![CDATA[<p>inline-block元素，或者属性被设置为inline-block的元素。会出现一个问题：当水平显示的时候，两个inline-block元素间会有间隙。这个不是bug，是这个属性应有的表现。当时作为开发者来说，显得有些多余，我们要想尽方法来去除这个间隙。<br><a id="more"></a><br>之前看过一个教Psd重构Html的视频,里面说这种方法很常用，那么首先就说这种方法：</p>
<h2 id="font-size-0去除法"><a href="#font-size-0去除法" class="headerlink" title="font-size:0去除法"></a>font-size:0去除法</h2><p>做法是将父元素的font-size属性值设置为0，<br><strong>然后</strong>将父元素里面的子元素设置它应有的字体大小。</p>
<h2 id="不过听说这个方法在手机上行不通啊！兼容性最好的方法是消灭空格法，见下。"><a href="#不过听说这个方法在手机上行不通啊！兼容性最好的方法是消灭空格法，见下。" class="headerlink" title="不过听说这个方法在手机上行不通啊！兼容性最好的方法是消灭空格法，见下。"></a>不过听说这个方法在手机上行不通啊！兼容性最好的方法是消灭空格法，见下。</h2><p>第二个方法是在学习HTML5+CSS3视频的时候，老师演示的方法。我猜两inline-block之间的间隙应该与在HTML文档书写时换行有关。</p>
<h2 id="消灭空格法"><a href="#消灭空格法" class="headerlink" title="消灭空格法"></a>消灭空格法</h2><p>这个方法的好处就是不要设置样式值，把HTML书写的格式修改一下即可。<br>例如，原本排列的很整齐的两个元素</p>
<pre><code>&lt;span style=&quot;display:inline-block;width:50px;height:90px;&quot;&gt;第一个&lt;/span&gt;
&lt;span style=&quot;display:inline-block;width:50px;height:90px;&quot;&gt;第er个&lt;/span&gt;
</code></pre><p>把第二行的起始标签写在第一行终止标签后：</p>
<pre><code>&lt;span style=&quot;display:inline-block;width:50px;height:90px;&quot;&gt;第一个&lt;/span&gt;&lt;span style=&quot;display:inline-block;width:50px;height:90px;&quot;&gt;第er个&lt;/span&gt;
</code></pre><p>但是有没有发现，如果行数多了，这样写，别人来读你的代码岂不是一种折磨？我发现只要让两个标签中间没空格就行。可以这样做。</p>
<pre><code>&lt;span style=&quot;display:inline-block;width:50px;height:90px&quot;&gt;第一个&lt;/span&gt;&lt;!--
--&gt;&lt;span style=&quot;display:inline-block;width:50px;height:90px;&quot;&gt;第er个&lt;/span&gt;
</code></pre><p>我们用一个注释符号充当链接符，占据他们之间的空格。当然只要你能想法把两个元素之间的空格去掉就行。你要问我，啥是元素？<a href="http://gelory.me/2016/10/19/%E5%B1%9E%E6%80%A7%EF%BC%8C%E6%A0%B7%E5%BC%8F%EF%BC%8C%E6%A0%87%E7%AD%BE%EF%BC%8C%E5%85%83%E7%B4%A0%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E8%81%94%E7%B3%BB/">属性，样式，标签，元素的区别与联系</a>这篇文章给你一个好的解释。</p>
<hr>
<p>第三个方法有点死，就是当你发现空格后，利用浏览器的审查元素，定位元素后，给后面的元素设置margin-left为负数。</p>
<h2 id="设置margin法"><a href="#设置margin法" class="headerlink" title="设置margin法"></a>设置margin法</h2><p>这个方法没什么说的，对着浏览器，找到一个合适值就行。不过这个方法有点尴尬，要设置的多了，你是不是就麻木了，解决方法就是设置一个<code>公共样式</code>处理该类问题吧！</p>
<hr>
<h2 id="还有其他方法："><a href="#还有其他方法：" class="headerlink" title="还有其他方法："></a>还有其他方法：</h2><blockquote>
<ul>
<li>譬如设置父元素 dispaly:table，设置子元素为table-cell。</li>
<li>设置父元素letter-spacing为一个负值，设置子元素为0。</li>
<li>word-spacing类似。</li>
<li>还有，用js去解决。</li>
</ul>
</blockquote>
<center><div style="border: 2px solid #999;border-top:none;border-left:none;width: 20px;height:20px;transform:rotate(45deg);"></div></center><br><center style="dispaly:block;width:300px;margin:0 auto"><span style="display:inline-block;float:left;width:100px;height:10px;border-top:1px solid #999;margin-top:15px;"></span><span><a href="https://github.com/Gong-Elory" target="_blank" rel="external">龚小样</a></span><span style=" display:inline-block;float:right;width:100px;height:10px;border-top:1px solid #999;margin-top:15px;"></span></center><br><center><span style="font-size:14px;line-height:14px;margin-top:0;">2016-10-20</span></center>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;inline-block元素，或者属性被设置为inline-block的元素。会出现一个问题：当水平显示的时候，两个inline-block元素间会有间隙。这个不是bug，是这个属性应有的表现。当时作为开发者来说，显得有些多余，我们要想尽方法来去除这个间隙。&lt;br&gt;
    
    </summary>
    
      <category term="前端" scheme="http://gelory.me/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="http://gelory.me/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="CSS" scheme="http://gelory.me/tags/CSS/"/>
    
  </entry>
  
</feed>
