<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>龚小样儿</title>
  <subtitle>写一些小事，做一些大事</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://ielory.com/"/>
  <updated>2017-11-02T02:43:14.700Z</updated>
  <id>http://ielory.com/</id>
  
  <author>
    <name>龚志强</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>移动端常见问题以及解决方案(待完善)</title>
    <link href="http://ielory.com/2017/11/01/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-%E5%BE%85%E5%AE%8C%E5%96%84/"/>
    <id>http://ielory.com/2017/11/01/移动端常见问题以及解决方案-待完善/</id>
    <published>2017-11-01T13:03:30.000Z</published>
    <updated>2017-11-02T02:43:14.700Z</updated>
    
    <content type="html"><![CDATA[<p>移动端常见问题以及解决方案(持续完善中…)<br><a id="more"></a></p>
<blockquote>
<p>IOS禁用数字识别为电话号码</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no,email=no&quot;/&gt;</div></pre></td></tr></table></figure>
<blockquote>
<p>解决手机点击事件的300ms事件</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">使用fastclick插件解决</div></pre></td></tr></table></figure>
<blockquote>
<p>解决safari浏览器中的链接或者可点击元素点击后出现蒙层的解决方案</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">-webkit-tap-highlight-color:rgba(0, 0, 0, 0)</div></pre></td></tr></table></figure>
<blockquote>
<p>改变webkit浏览器的默认表单元素外观</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">input,select &#123; -webkit-appearance:none; appearance: none; &#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>禁用用户选中文字</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">-webkit-user-select:none; user-select: none;</div></pre></td></tr></table></figure>
<blockquote>
<p>禁止长按链接或者图片弹出菜单</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">-webkit-touch-callout: none</div></pre></td></tr></table></figure>
<blockquote>
<p>改变输入框placeholder的颜色值</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">::-webkit-input-placeholder&#123;</div><div class="line">    color: #333</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>ios输入框默认首字母大写取消</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">设置autocapitalize=&quot;off&quot;</div><div class="line">``` </div><div class="line">&gt;audio元素的autoplay属性在IOS及Android上无法使用，在PC正常</div></pre></td></tr></table></figure>
<p>JS绑定自动播放<br>$(window).one(‘touchstart’,fn)<br>原生方法就是在元素上添加一个flag属性，控制执行一次<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt;消除transition闪屏</div></pre></td></tr></table></figure></p>
<p>-webkit-transform-style: preserve-3d;<br>-webkit-backface-visibility: hidden;<br>-webkit-perspective: 1000;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt;开启硬件加速</div></pre></td></tr></table></figure></p>
<p>-webkit-transform: translate3d(0,0,0);<br>-moz-transform: translate3d(0,0,0);<br>-ms-transform: translate3d(0,0,0);<br>transform: translate3d(0,0,0);<br>```<br>待完善…</p>
<center><div style="border: 2px solid #999;border-top:none;border-left:none;width: 20px;height:20px;transform:rotate(45deg);"></div></center><br><center style="dispaly:block;width:300px;margin:0 auto"><span style="display:inline-block;float:left;width:100px;height:10px;border-top:1px solid #999;margin-top:15px;"></span><span><a href="https://github.com/Gong-Elory" target="_blank" rel="external">龚小样</a></span><span style=" display:inline-block;float:right;width:100px;height:10px;border-top:1px solid #999;margin-top:15px;"></span></center><br><center><span style="font-size:14px;line-height:14px;margin-top:0;">2017-11-01</span></center>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;移动端常见问题以及解决方案(持续完善中…)&lt;br&gt;
    
    </summary>
    
      <category term="前端" scheme="http://ielory.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="移动端" scheme="http://ielory.com/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>函数节流和函数防抖</title>
    <link href="http://ielory.com/2017/09/07/%E5%87%BD%E6%95%B0%E8%8A%82%E6%B5%81%E5%92%8C%E5%87%BD%E6%95%B0%E9%98%B2%E6%8A%96/"/>
    <id>http://ielory.com/2017/09/07/函数节流和函数防抖/</id>
    <published>2017-09-07T14:05:03.000Z</published>
    <updated>2017-09-07T14:12:27.143Z</updated>
    
    <content type="html"><![CDATA[<p>函数节流：指定时间间隔内只执行一次任务；<br>函数防抖：任务频繁触发的情况下，只有任务触发的间隔超过指定间隔，任务才会执行。<br><a id="more"></a><br>函数节流和函数防抖<br>—闭包的使用场景</p>
<h2 id="函数节流（throttle）"><a href="#函数节流（throttle）" class="headerlink" title="函数节流（throttle）"></a>函数节流（throttle）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">throttle（fn,interval）&#123;</div><div class="line">    let canRun = true;</div><div class="line">    return function()&#123;</div><div class="line">        var that = this,args = arguments;</div><div class="line">        if(!canRun) return;</div><div class="line">        canRun = false;</div><div class="line">        setTimeOut(function()&#123;</div><div class="line">            canRun = true;</div><div class="line">            fn.apply(this,args);</div><div class="line">        &#125;,interval);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">//节流的思想其实在日常的编程中很常见，就是设置一个标志位，</div><div class="line">//在指定的时刻去设置这个标志位，让程序执行下去</div></pre></td></tr></table></figure>
<h2 id="函数防抖（debounce）"><a href="#函数防抖（debounce）" class="headerlink" title="函数防抖（debounce）"></a>函数防抖（debounce）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function debounce(fn,interval)&#123;</div><div class="line">    let timer = null;</div><div class="line">    return function()&#123;</div><div class="line">        var that = this,args = arguments;</div><div class="line">        clearInterval(timer);</div><div class="line">        timer = setTimeOut(function()&#123;</div><div class="line">            fn.apply(that,args);</div><div class="line">        &#125;,interval);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">//防抖的思想，可以简单的描述为，你要想执行，你得先熬过指定时间。</div><div class="line">//要是期间出了岔子，又得重新开始。有点像炼药，修仙一样。只不过这里不会爆炸，不会走火入魔。</div><div class="line">//而防抖就是要想触发事件，必须在指定时间内不能再有下一次触发，不然得重新开始。</div></pre></td></tr></table></figure>
<p>函数节流和函数防抖的目的就是为了节约资源。</p>
<center><div style="border: 2px solid #999;border-top:none;border-left:none;width: 20px;height:20px;transform:rotate(45deg);"></div></center><br><center style="dispaly:block;width:300px;margin:0 auto"><span style="display:inline-block;float:left;width:100px;height:10px;border-top:1px solid #999;margin-top:15px;"></span><span><a href="https://github.com/Gong-Elory" target="_blank" rel="external">龚小样</a></span><span style=" display:inline-block;float:right;width:100px;height:10px;border-top:1px solid #999;margin-top:15px;"></span></center><br><center><span style="font-size:14px;line-height:14px;margin-top:0;">2017-08-30</span></center>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;函数节流：指定时间间隔内只执行一次任务；&lt;br&gt;函数防抖：任务频繁触发的情况下，只有任务触发的间隔超过指定间隔，任务才会执行。&lt;br&gt;
    
    </summary>
    
      <category term="JS" scheme="http://ielory.com/categories/JS/"/>
    
    
      <category term="JS" scheme="http://ielory.com/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>响应式设计</title>
    <link href="http://ielory.com/2017/09/07/%E5%93%8D%E5%BA%94%E5%BC%8F%E8%AE%BE%E8%AE%A1/"/>
    <id>http://ielory.com/2017/09/07/响应式设计/</id>
    <published>2017-09-07T14:04:09.000Z</published>
    <updated>2017-09-07T14:15:38.781Z</updated>
    
    <content type="html"><![CDATA[<p>响应式的一些知识点。<br><a id="more"></a></p>
<h2 id="响应式图片"><a href="#响应式图片" class="headerlink" title="响应式图片"></a>响应式图片</h2><h3 id="涉及到两个属性"><a href="#涉及到两个属性" class="headerlink" title="涉及到两个属性"></a>涉及到两个属性</h3><blockquote>
<p>srcset和sizes</p>
</blockquote>
<p>在我认为前者主要应该和分辨率打交道，把和尺寸打交道的交给后者。<br>首先，控制一张图片的尺寸是一件很容易的是，采用百分百width，即可以控制<br>但是要控制在什么时候加载什么分辨率的图片，就没那么容易<br>先从sizes说起，他主要是表示尺寸临界点。跟响应式布局打交道。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">sizes = &quot;(max-width: 360px) 340px,128px&quot;</div><div class="line">sizes = &quot;(max-width: 360px) calc(100vm - 20px),128px&quot;</div><div class="line">//上面的意思是当视窗宽度不大于360px时，图片的尺寸为视窗宽度-20px</div><div class="line">//vm将在后面讲到，在这里只要知道100vm，相当于100%视窗宽度。</div><div class="line">//其他时刻，则为固定宽度128px</div></pre></td></tr></table></figure></p>
<p>这里只对图像尺寸进行控制，那么分辨率在哪里控制的呢。<br>通过srcset<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">srcset=&quot;mm-width-128px.jpg 128w, mm-width-256px.jpg 256w, mm-width-512px.jpg 512w&quot;</div></pre></td></tr></table></figure></p>
<p>其实这三个图像的大小都是一般大，只不过分辨率不同。那到底在什么时候加载哪张图 为我们不许要去管，这一切浏览器帮我们去做了。</p>
<h3 id="扩展："><a href="#扩展：" class="headerlink" title="扩展："></a>扩展：</h3><blockquote>
<p>我们知道有种高富帅屏叫retina，这种屏的像素比比普通屏高，可以通过window.devicePixelRatio获得。<br>PPI像素密度  每英寸有多少个物理像素点 公式为（根号下横向像素评分+纵向像素平方）/屏幕尺寸（英寸）<br>DIPs设备独立像素 独立于设备的用于逻辑上衡量像素的单位。可以认为是程序可以使用的虚拟像素（CSS像素），然后由相关的系统转换为物理像素。<br>DPR设备像素比 在某一方向上 物理像素/设备独立像素，js中通过window.devicePixelRatio使用</p>
</blockquote>
<p>以IPhone6为例，设备宽高为375<em>667，可以理解为设备独立像素（或css像素）<br>i6的dpr为2，根据dpr的计算公式<code>DPR = 物理像素/设备独立像素</code>,可以算出其物理像素为750</em>1334。</p>
<center><img src="http://divio.qiniudn.com/FpXnQbkqJ8sqP82mmrIjYBxfliQL"></center>

<p>从上图可以看出，在不同的屏幕上，css像素所呈现的物理尺寸是一样大的（肉眼看见的是一样大的）。只不过此时一个css像素对应的物理像素点个数不一样。以前是1:1，现在是1:4（注意这里说的是单位面积的个数，刚才有DPR公式算的是x，y一条边上的个数）。</p>
<p>我们在适应retina2倍屏的时候，会多设计一份两倍图片（@2x）,例如一个200<em>300像素的图片要像在2倍屏下清晰可见的话，就需要多一份400</em>600的图，如果硬是要用200<em>300的图会出现什么效果呢。相当于原来一个像素点的颜色现在要供2倍屏的4个像素点用，你说能不模糊吗，如果为400</em>600的图，就相当于一个像素点一个色。会更加逼真清晰。<br>那如果我们将两倍图用在1倍屏上，是什么效果呢，也就是说相当于4个像素的颜色用在一个像素点上。这里面通过一种算法来取颜色（downsampling）。</p>
<p>在不同屏幕下，css像素呈现的物理尺寸是一致的，而不同的是css像素对应的物理像素是不一致的。在普通屏幕下1个css像素对应一个物理像素，在retina屏下，一个css像素对应dpr*dpr个</p>
<p>假设我们的像素比发生了变化，此时浏览器会根据情况自动的选择加载相应的图片。<br>我们看到srcset里面有一个标识符w，这不是什么度量单位，最好的理解就是宽度规格，不要理解为宽度尺寸。<br>代表的是质量的好坏，譬如我们可以把一张实际宽度只有100px的png24无损图规格设置为200w</p>
<h2 id="响应式文字"><a href="#响应式文字" class="headerlink" title="响应式文字"></a>响应式文字</h2><h3 id="不常见的单位"><a href="#不常见的单位" class="headerlink" title="不常见的单位"></a>不常见的单位</h3><blockquote>
<p>vh，vw</p>
</blockquote>
<p>我们知道元素的宽高百分比是相对于最近父元素的宽高的。但是如果想用视口的宽高，就可以考虑vh，vm了<br>1vh等于1/100的视口高度，vw同理</p>
<blockquote>
<p>vmax，vmin</p>
</blockquote>
<p>视口宽高中的最大最小值/100，加入视口宽高为100px*500px<br>100vmax = 500px 100vmin = 100px</p>
<h2 id="响应式设计"><a href="#响应式设计" class="headerlink" title="响应式设计"></a>响应式设计</h2><h3 id="meta属性"><a href="#meta属性" class="headerlink" title="meta属性"></a>meta属性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;meta name=&quot;viewport&quot; content=&quot;initial-scale=0.5, maximum-scale=0.5, minimum-scale=0.5, user-scalable=no&quot;/&gt;</div></pre></td></tr></table></figure>
<p>手机淘宝的meta,通过js动态写入。在retina3倍屏时，上述的三个数字参数将变成0.33333333<br>二倍屏时为0.5<br>有人可能会问了，为什么要设置这么多，而不就设置为1，然后去相应的根据retina屏，去改变元素的大小了例如要像让retina屏下显示12px的字体，只需要改为6px就好了嘛。但是我们在日常中，可能遇到这样的需求，在任何屏幕上某条边框都为1px，如果像上面那样设置initial-scale=1，除非将边框像素设置为0.5px，如果在3倍屏的话，更是要设置为0.3333333px，想想那些不支持小数px的，想让所有设备都为1px显然是不可能的。所以采用小数版initial要好一些。这样要想打印1px的边框，只需设置为2px就ok了。</p>
<center><div style="border: 2px solid #999;border-top:none;border-left:none;width: 20px;height:20px;transform:rotate(45deg);"></div></center><br><center style="dispaly:block;width:300px;margin:0 auto"><span style="display:inline-block;float:left;width:100px;height:10px;border-top:1px solid #999;margin-top:15px;"></span><span><a href="https://github.com/Gong-Elory" target="_blank" rel="external">龚小样</a></span><span style=" display:inline-block;float:right;width:100px;height:10px;border-top:1px solid #999;margin-top:15px;"></span></center><br><center><span style="font-size:14px;line-height:14px;margin-top:0;">2017-09-02</span></center>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;响应式的一些知识点。&lt;br&gt;
    
    </summary>
    
      <category term="JS" scheme="http://ielory.com/categories/JS/"/>
    
    
      <category term="JS" scheme="http://ielory.com/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>异步编程的4种方法</title>
    <link href="http://ielory.com/2017/09/07/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E7%9A%844%E7%A7%8D%E6%96%B9%E6%B3%95/"/>
    <id>http://ielory.com/2017/09/07/异步编程的4种方法/</id>
    <published>2017-09-07T14:03:51.000Z</published>
    <updated>2017-09-07T14:09:49.716Z</updated>
    
    <content type="html"><![CDATA[<p>同步模式：后一个任务等待前一个任务结束然后再执行。程序的执行顺序和任务的排列顺序是一致的，同步的。<br>异步模式：每一个任务有多个回调函数，前一个任务执行后，不是执行后一个任务而是执行回调函数。<br><a id="more"></a></p>
<p>##异步编程的四种方法：</p>
<p>###回调函数：<br>优点是简单，利于部署，缺点是不利于代码的阅读和维护，各个部分之间高度耦合，流程会很乱<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">f1(); f2();</div><div class="line">f1(callback)&#123;</div><div class="line">    //f1任务代码</div><div class="line">    callback();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="事件监听法（事件驱动模式）："><a href="#事件监听法（事件驱动模式）：" class="headerlink" title="事件监听法（事件驱动模式）："></a>事件监听法（事件驱动模式）：</h3><p>任务的执行不取决于代码的顺序，取决于某个事件是否发生。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">为f1绑定事件，f1.on(&apos;done&apos;,f2);</div><div class="line">f1()&#123;</div><div class="line">    //f1任务代码</div><div class="line">    f1.trigger(&apos;done&apos;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>优点：比较容易理解，可以绑定多个事件，每个事件可以指定多个回调，有利于实现模块化。<br>缺点：整个程序都要变成事件驱动型，运行流程会变得很不清晰。</p>
<h3 id="发布-订阅法："><a href="#发布-订阅法：" class="headerlink" title="发布/订阅法："></a>发布/订阅法：</h3><p>假设存在一个信号中心，某个任务完成时，就向信号中心发布（publish）一个信号，其他任务可以向信号中心订阅（subscribe）这个信号。当订阅的这个信号被publish，就代表已经完成，此时自己就可以执行了这叫做发布/订阅模式，也叫作观察者模式<br>实现这种模式的插件有很多<br>核心方法有俩<br>subscribe（“done”,f2）//订阅信号，当这个信号被pub时，就执行f2<br>publish（“done”）//发布信号到信号中心</p>
<p>优点：可以通过查看消息种子呢，了解存在多少信号，每个信号有多少订阅者，从而监控程序的运行。（每个插件实现的方法不同）</p>
<h3 id="Promises对象"><a href="#Promises对象" class="headerlink" title="Promises对象"></a>Promises对象</h3><p>CommonJS工作组提出的一组规范，目的是为异步编程提供接口。<br>使用Jquery实现的promise使用起来非常方便，其核心是<strong>deferred对象</strong><br>适用场景之一就是ajax读取服务器数据<br>传统的ajax操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">$.ajax(&#123;</div><div class="line">    url:&quot;test.html&quot;,</div><div class="line">    success: function()&#123;</div><div class="line">        alert(&quot;success&quot;);</div><div class="line">    &#125;,</div><div class="line">    error:function()&#123;</div><div class="line">        alert(&apos;error&apos;);</div><div class="line">    &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>这种传统的写法在v1.5后可以用新方法代替<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$.ajax(&quot;test.html&quot;)</div><div class="line">    .done(function()&#123;alert(&quot;success&quot;)&#125;)</div><div class="line">    .fail(function()&#123;alert(&quot;error&quot;)&#125;);</div></pre></td></tr></table></figure></p>
<p>新版本的ajax方法返回的是deferred对象，可以进行链式操作。这样代码可读性明显就清晰了许多。<br>deferred对象</p>
<blockquote>
<ul>
<li><p>好处一：允许添加多个回调函数。因为支持链式操作，所以写起来很方便。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$.ajax(&quot;test.html&quot;)</div><div class="line">    .done(function()&#123;alert(&quot;success&quot;)&#125;)</div><div class="line">    .fail(function()&#123;alert(&quot;error&quot;)&#125;)</div><div class="line">    .done(function()&#123;alert(&quot;success2&quot;)&#125;)</div><div class="line">    ...</div><div class="line">    ...//当然，你还可以往后面加，只要你乐意</div><div class="line">    ;</div></pre></td></tr></table></figure>
</li>
<li><p>好处二：允许为多个事件指定一个回调函数。</p>
</li>
</ul>
</blockquote>
<p>此时用到了$.when()，依旧返回deferred对象。记住，$.when()的参数也必须是一个deferred对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$.when($.ajax(&quot;test1.html&quot;),$.ajax(&quot;test2.html&quot;))</div><div class="line">    .done(function()&#123;alert(&quot;success&quot;)&#125;)</div><div class="line">    .fail(function()&#123;alert(&quot;error&quot;)&#125;)</div></pre></td></tr></table></figure></p>
<p>但是要记住when的使用场景。只有两个操作test1,test2都成功了，才运行done，有一个失败就运行fail</p>
<blockquote>
<ul>
<li>好处三：普适性</li>
</ul>
</blockquote>
<p>不仅ajax操作可以用，只要涉及到回调的地方，都可以使用deferred对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">//这是一个耗时操作，为他制定回调函数</div><div class="line">var wait = function()&#123;</div><div class="line">　　　　var tasks = function()&#123;</div><div class="line">　　　　　　alert(&quot;执行完毕！&quot;);</div><div class="line">　　　　&#125;;</div><div class="line">　　　　setTimeout(tasks,5000);</div><div class="line">　　&#125;;</div><div class="line">/*************/</div><div class="line">/**这样来改写**/</div><div class="line">/*************/</div><div class="line">//step1： 新建一个def对象</div><div class="line">var dt = $.Deferred();</div><div class="line">var wait = function()&#123;</div><div class="line">　　　　var tasks = function()&#123;</div><div class="line">　　　　　　alert(&quot;执行完毕！&quot;);</div><div class="line">　　　　　　//step2: 改变def对象的执行状态</div><div class="line">　　　　　　dt.resolve();</div><div class="line">　　　　　　//失败则是 dt.reject（）</div><div class="line">　　　　&#125;;</div><div class="line">　　　　setTimeout(tasks,5000);</div><div class="line">　　　　return dt; //返回def对象</div><div class="line">　　&#125;;</div></pre></td></tr></table></figure>
<p>这里有必要把Promise对象的规范拿出来回顾一下<br>在规范中，每个任务都有三种状态：默认（pending）,完成（fulfilled）,失败（rejected）<br>Jquery实现的deferred根据规范，有相应的三种执行状态：未完成（继续等待或者调用progress（）指定的回调函数），完成（调用done方法指定的回调函数），失败（调用fail指定的回调函数）<br>如何改变执行状态呢，使用相应的方法dt.resolve()状态从未完成-&gt;已完成,dt.reject()将状态从未完成改为-&gt;失败。</p>
<p>但是上面代码暴露了一个缺点，其返回的dt对象，让在外部改变执行状态成为可能，为了避免这种情况，jq提供了promise（）方法，该方法返回一个def对象，只不过这个对象屏蔽了resolve和reject方法，值开放了不会改变执行状态的方法，譬如done，fail方法。<br>所以更好的写法是这样:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">var wait = function()&#123;</div><div class="line">        var dt = $.Deferred();</div><div class="line">　　　　var tasks = function()&#123;</div><div class="line">　　　　　　alert(&quot;执行完毕！&quot;);</div><div class="line">　　　　　　//step2: 改变def对象的执行状态</div><div class="line">　　　　　　dt.resolve();</div><div class="line">　　　　　　//失败则是 dt.reject（）</div><div class="line">　　　　&#125;;</div><div class="line">　　　　setTimeout(tasks,5000);</div><div class="line">　　　　return dt.promise(); //返回def对象</div><div class="line">　　&#125;;</div><div class="line">　　$.when(wait())</div><div class="line">　　.done(function()&#123; alert(&quot;success&quot;); &#125;)</div><div class="line">　　.fail(function()&#123; alert(&quot;error&quot;); &#125;);</div></pre></td></tr></table></figure></p>
<center><div style="border: 2px solid #999;border-top:none;border-left:none;width: 20px;height:20px;transform:rotate(45deg);"></div></center><br><center style="dispaly:block;width:300px;margin:0 auto"><span style="display:inline-block;float:left;width:100px;height:10px;border-top:1px solid #999;margin-top:15px;"></span><span><a href="https://github.com/Gong-Elory" target="_blank" rel="external">龚小样</a></span><span style=" display:inline-block;float:right;width:100px;height:10px;border-top:1px solid #999;margin-top:15px;"></span></center><br><center><span style="font-size:14px;line-height:14px;margin-top:0;">2016-10-9</span></center>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;同步模式：后一个任务等待前一个任务结束然后再执行。程序的执行顺序和任务的排列顺序是一致的，同步的。&lt;br&gt;异步模式：每一个任务有多个回调函数，前一个任务执行后，不是执行后一个任务而是执行回调函数。&lt;br&gt;
    
    </summary>
    
      <category term="JS" scheme="http://ielory.com/categories/JS/"/>
    
    
      <category term="JS" scheme="http://ielory.com/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>JS设计模式之单例模式</title>
    <link href="http://ielory.com/2017/09/07/JS%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://ielory.com/2017/09/07/JS设计模式之单例模式/</id>
    <published>2017-09-07T14:03:25.000Z</published>
    <updated>2017-09-07T14:11:11.808Z</updated>
    
    <content type="html"><![CDATA[<p>单例作为一个命名空间提供者，在全局命名空间里提供一个唯一的访问点来访问该对象。<br><a id="more"></a><br>JS中实现单例的方法：<br>对象字面量法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var mySingleton = &#123;</div><div class="line">    property1 : &quot;something&quot;,</div><div class="line">    property2 : &quot;something else&quot;,</div><div class="line">    method1: function()&#123;</div><div class="line">        console.log(&apos;hello&apos;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>–闭包的使用场景之一，单例对象生成<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">var mySingleton = function () &#123;</div><div class="line"></div><div class="line">    /* 这里声明私有变量和方法 */</div><div class="line">    var privateVariable = &apos;something private&apos;;</div><div class="line">    function showPrivate() &#123;</div><div class="line">        console.log(privateVariable);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /* 公有变量和方法（可以访问私有变量和方法） */</div><div class="line">    return &#123;</div><div class="line">        publicMethod: function () &#123;</div><div class="line">            showPrivate();</div><div class="line">        &#125;,</div><div class="line">        publicVar: &apos;the public can see this!&apos;</div><div class="line">    &#125;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>在使用的时候再初始化<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">var Singleton = (function () &#123;</div><div class="line">    var instantiated;</div><div class="line">    function init() &#123;</div><div class="line">        /*这里定义单例代码*/</div><div class="line">        return &#123;</div><div class="line">            publicMethod: function () &#123;</div><div class="line">                console.log(&apos;hello world&apos;);</div><div class="line">            &#125;,</div><div class="line">            publicProperty: &apos;test&apos;</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return &#123;</div><div class="line">        getInstance: function () &#123;</div><div class="line">            if (!instantiated) &#123;</div><div class="line">                instantiated = init();</div><div class="line">            &#125;</div><div class="line">            return instantiated;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;)();</div><div class="line">Singleton.getInstance().publicMethod();</div></pre></td></tr></table></figure></p>
<p>这里的instantiated变量就很好的利用的闭包的原理，所有的闭包访问同一个instantiated，如果已经存在，说明已经有这么个实例了，那么直接返回，没有的话，生成一个。</p>
<center><div style="border: 2px solid #999;border-top:none;border-left:none;width: 20px;height:20px;transform:rotate(45deg);"></div></center><br><center style="dispaly:block;width:300px;margin:0 auto"><span style="display:inline-block;float:left;width:100px;height:10px;border-top:1px solid #999;margin-top:15px;"></span><span><a href="https://github.com/Gong-Elory" target="_blank" rel="external">龚小样</a></span><span style=" display:inline-block;float:right;width:100px;height:10px;border-top:1px solid #999;margin-top:15px;"></span></center><br><center><span style="font-size:14px;line-height:14px;margin-top:0;">2017-08-24</span></center>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;单例作为一个命名空间提供者，在全局命名空间里提供一个唯一的访问点来访问该对象。&lt;br&gt;
    
    </summary>
    
      <category term="JS" scheme="http://ielory.com/categories/JS/"/>
    
    
      <category term="JS" scheme="http://ielory.com/tags/JS/"/>
    
      <category term="设计模式" scheme="http://ielory.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>再探作用域</title>
    <link href="http://ielory.com/2017/09/07/%E5%86%8D%E6%8E%A2%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    <id>http://ielory.com/2017/09/07/再探作用域/</id>
    <published>2017-09-07T14:01:59.000Z</published>
    <updated>2017-09-07T14:08:36.340Z</updated>
    
    <content type="html"><![CDATA[<p>作用域重新认识。<br><a id="more"></a><br>变量对象、活动对象都是在进入执行上下文时被创建的。</p>
<p>执行上下文中定义的所有变量和函数都存储在变量对象中<br>变量对象在每次进入上下文时创建并填入初始值，赋值或者更新出现在代码执行阶段。</p>
<p>每进入一个执行上下文时，该上下文的变量对象就被激活可，就叫做活动对象。<br>此时活动对象作为变量对象，活动对象最开始时包含一个arguments变量。此外还包括声明的变量和函数</p>
<p>当代码在一个环境中执行时，会创建一条作用域链，这条作用域链由变量对象组成。<br>作用域链的最前端始终是当前执行代码所在上下文的变量对象（活动对象）。</p>
<p>当前执行代码的作用域链为  Scope = AO+[[scope]];<br>[[scope]]为其父执行上下文的作用域链，[[scope]]在函数被创建时就被存储</p>
<p>bind方法<br>if(!bind in Function.prototype){<br>Function.prototye.bind = function(){<br>    var fn = this,args = Array.prototype.slice.apply(arguments),obj = args.shift();<br>     return function(){<br>         return fn.apply(obj,args.concat(arguments));<br>     }<br>    }<br>}</p>
<center><div style="border: 2px solid #999;border-top:none;border-left:none;width: 20px;height:20px;transform:rotate(45deg);"></div></center><br><center style="dispaly:block;width:300px;margin:0 auto"><span style="display:inline-block;float:left;width:100px;height:10px;border-top:1px solid #999;margin-top:15px;"></span><span><a href="https://github.com/Gong-Elory" target="_blank" rel="external">龚小样</a></span><span style=" display:inline-block;float:right;width:100px;height:10px;border-top:1px solid #999;margin-top:15px;"></span></center><br><center><span style="font-size:14px;line-height:14px;margin-top:0;">2017-08-20</span></center>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作用域重新认识。&lt;br&gt;
    
    </summary>
    
      <category term="JS" scheme="http://ielory.com/categories/JS/"/>
    
    
      <category term="JS" scheme="http://ielory.com/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>Angularjs-指令</title>
    <link href="http://ielory.com/2017/08/07/Angularjs-%E6%8C%87%E4%BB%A4/"/>
    <id>http://ielory.com/2017/08/07/Angularjs-指令/</id>
    <published>2017-08-07T13:29:40.000Z</published>
    <updated>2017-08-10T14:49:48.195Z</updated>
    
    <content type="html"><![CDATA[<p>当一个指令被创建时，要么是继承父作用域，还是创建一个新作用域。<br><a id="more"></a></p>
<p>———————-2017-08-10 更新—————————<br>第一期写的示例解释的一团糟，简直是驴唇不对马嘴。有些博客的内容是错的，所以在看的时候不能全信。现在重新解释一下指令的作用域绑定。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">scope：&#123;</div><div class="line">    name: &apos;@myName&apos;,</div><div class="line"> /*子scope，name是scope想外提供的接口，在这个指令的作用域内则可以通过调用这个name来访问作用域外的数据。@后面的myName相当于重新取了一个名字，实际上就是name = myName，给接口多取了一个名字。*/</div><div class="line">/*如下面的代码。name=“hisName” 这样调用，我们就可以访问父作用域的hisName。但是当我们修改子作用域name的值时，父作用域的hisName不//会跟着改变,当然，你也可以这样使用  myName=&quot;hisName&quot;*/</div><div class="line">    //&lt;div name=&quot;hisName&quot; changesth=&apos;funct（）&apos; myage=&quot;age&quot;&gt;&lt;/div&gt;</div><div class="line">    name: &apos;@&apos;</div><div class="line">//=是双向绑定 在子域内也可以改变父域的值 myage同理，就相当于取了一个别名</div><div class="line">    age：&apos;=myage&apos;,</div><div class="line">    //双向绑定  无论是指令还是父作用域中的属性值发生改变另一方的值也会改变</div><div class="line">    funct : &apos;&amp;changesth&apos;</div><div class="line">    //声明了一个专用于绑定函数的接口  统一用&amp;标志符表示 </div><div class="line">    //使用的时候，如下</div><div class="line">    //&lt;div  changesth=&apos;funct（a,b）&apos;&gt;&lt;/div&gt;</div><div class="line">    //那么在子作用域就可以使用changesth（）只不过此时不能直接把变量往里塞，像这样changesth（2,3）</div><div class="line">    //而应该塞一个对象，键为接口处的形参声明的 changesth(&#123;a:2,b:3&#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>指令对象的scope属性拥有三种形式<br>为false 继承了父作用域所有的属性和方法 。 此时指令没有属于自身的作用域，处于父作用域当中<br>为true时，创建一个新的作用域，初始化时，用的父作用域的属性和方法去填充这个新的作用域<br>为{}时 创建一个独立的作用域，与父作用域没有联系。。但是可以通过其他方法让他们产生联系</p>
<h2 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&lt;diective myName=&quot;&#123;&#123;name&#125;&#125;&quot; changesth=&apos;funct（）&apos; myage=&quot;age&quot;&gt;&lt;/directive&gt;</div><div class="line">scope：&#123;</div><div class="line">    name: &apos;@myName&apos;,</div><div class="line">    //如果指令中的属性名与要绑定的要在父作用域上查找的属性名相同，可以简写</div><div class="line">    //name为要查找的父作用域的属性，myName为要进行绑定的属性，</div><div class="line">    //在父作用域上查找name的属性值，然后绑定到myName上</div><div class="line">    //&lt;diective name=&quot;&#123;&#123;name&#125;&#125;&quot; changesth=&apos;funct（）&apos; myage=&quot;age&quot;&gt;&lt;/directive&gt;</div><div class="line">    name: &apos;@&apos;</div><div class="line">    </div><div class="line">    </div><div class="line">    age：&apos;=myage&apos;,</div><div class="line">    //双向绑定  无论是指令还是父作用域中的属性值发生改变另一方的值也会改变</div><div class="line">    funct : &apos;&amp;changesth&apos;</div><div class="line">    //绑定副作用域上的funct函数到changesth属性上</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="需要注意的是："><a href="#需要注意的是：" class="headerlink" title="需要注意的是："></a>需要注意的是：</h2><p>1.使用@，是单向传递，使用这种方式，只能将字符串传递给参数，而不是对象。所以当你修改独立scope属性的属性值时，父scope的相关属性是不会更改的。简单的说就是将父scope的值复制一份给独立scope<br>2.相比较下，=双向绑定，修改独立scope的属性值，父scope也会同步更改。简单的说就是某个属性的引用传递给了独立scope的属性<br>3.通过&amp;绑定的函数，其实传递的是一个引用，及父scope函数的引用</p>
<h2 id="true与-的区别"><a href="#true与-的区别" class="headerlink" title="true与{}的区别"></a>true与<code>{}</code>的区别</h2><p>前者是将父scope的无论是函数的引用还是属性值，全部复制一份到子scope<br>后者是‘&amp;’复制函数引用，’@’复制属性值,’=’复制属性引用</p>
<p>=与@的区别<br>= 是把独立scope的属性与父scope的属性进行绑定<br>@ 是把独立scope的属性与父scope的属性的值进行绑定  </p>
<h2 id="小样有话说："><a href="#小样有话说：" class="headerlink" title="小样有话说："></a>小样有话说：</h2><center style="color:green;font-weight: Bold;border:1px dotted #999">无fuck说</center>

<center><div style="border: 2px solid #999;border-top:none;border-left:none;width: 20px;height:20px;transform:rotate(45deg);"></div></center><br><center style="dispaly:block;width:300px;margin:0 auto"><span style="display:inline-block;float:left;width:100px;height:10px;border-top:1px solid #999;margin-top:15px;"></span><span><a href="https://github.com/Gong-Elory" target="_blank" rel="external">龚小样</a></span><span style=" display:inline-block;float:right;width:100px;height:10px;border-top:1px solid #999;margin-top:15px;"></span></center><br><center><span style="font-size:14px;line-height:14px;margin-top:0;">2017-08-07</span></center>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当一个指令被创建时，要么是继承父作用域，还是创建一个新作用域。&lt;br&gt;
    
    </summary>
    
      <category term="Angualarjs" scheme="http://ielory.com/categories/Angualarjs/"/>
    
    
      <category term="Angualarjs" scheme="http://ielory.com/tags/Angualarjs/"/>
    
      <category term="前端" scheme="http://ielory.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>Angularjs-服务</title>
    <link href="http://ielory.com/2017/08/07/Angularjs-%E6%9C%8D%E5%8A%A1/"/>
    <id>http://ielory.com/2017/08/07/Angularjs-服务/</id>
    <published>2017-08-07T13:00:35.000Z</published>
    <updated>2017-08-07T13:16:57.597Z</updated>
    
    <content type="html"><![CDATA[<p>服务的作用，就是对外提供某种功能。angularjs上定义它为一个单例对象（只允许有一个实例的对象）或是一个函数。<br><a id="more"></a></p>
<h2 id="对服务的理解"><a href="#对服务的理解" class="headerlink" title="对服务的理解"></a>对服务的理解</h2><p>服务的作用就是类似于我们常听说的构造函数的存在，只不过相比构造函数而言，不需要我们自己new一个实例，也不像构造函数可以new无数个实例，此外，服务被定义于一个模块中，其使用范围是可控范围，不会污染全局环境。</p>
<h2 id="服务的自定义"><a href="#服务的自定义" class="headerlink" title="服务的自定义"></a>服务的自定义</h2><p>ng为我们提供了很多内置服务，以$开头。此外也可以自定义服务。常用的方法有： </p>
<h3 id="使用provider方法"><a href="#使用provider方法" class="headerlink" title="使用provider方法"></a>使用provider方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var app = angular.module(&quot;myApp&quot;,[]);</div><div class="line">app.provider(&quot;myService&quot;,function()&#123;</div><div class="line">    this.$get = function()&#123;</div><div class="line">     return &#123;</div><div class="line">        name: &quot;elory&quot;;</div><div class="line">     &#125; </div><div class="line">    &#125;</div><div class="line">);</div><div class="line">//此时就可以在控制器中注入这个服务了。</div><div class="line">//注意：使用provider注册服务时，控制器访问的实例其实是$get()</div><div class="line">//provider是唯一一种生成可以注入到config()中的服务的方法。如果需要在服务启动之前，配置模块，可以使用provider。</div><div class="line">//在config（）中注入时，服务声明格式必须是 myService+ Provider</div><div class="line">//app.config(myServiceProvider)</div></pre></td></tr></table></figure>
<h3 id="使用factory方法"><a href="#使用factory方法" class="headerlink" title="使用factory方法"></a>使用factory方法</h3><p>该方法最终要返回一个对象,或者一个函数，factory的内部实现其实是调用了provider<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">var app = angular.module(&quot;myApp&quot;,[]);</div><div class="line">app.factory(&quot;myService&quot;,function()&#123;</div><div class="line">    var name = &quot;elory&quot;,</div><div class="line">    service = &#123;&#125;;</div><div class="line">    service.getName =function()&#123;</div><div class="line">    return name;</div><div class="line">    &#125;;</div><div class="line">    return service;</div><div class="line">);</div><div class="line">app.factory(&quot;myServiceFunc&quot;,function()&#123;</div><div class="line">    return function(name)&#123;</div><div class="line">        console.log(name)</div><div class="line">    &#125;;</div><div class="line">);</div><div class="line">//此时就可以在控制器中注入这个服务了。</div><div class="line">//返回函数的话，直接传入参数即可myServiceFunc（“leory&quot;）</div></pre></td></tr></table></figure></p>
<p>###使用service方法<br>使用service方法，不需要返回对象了。service的内部实现其实就是调用的factory。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var app = angular.module(&quot;myApp&quot;,[]);</div><div class="line">app.factory(&quot;myService&quot;,function()&#123;</div><div class="line">    this.name== &quot;elory&quot;;</div><div class="line">    &#125;;</div><div class="line">);</div><div class="line">//在控制器中注入服务后，可以直接调用，</div><div class="line">//因为注入器已经帮我们实例化了这个服务，所以不需要手动实例化。</div><div class="line">//myService.name</div></pre></td></tr></table></figure></p>
<h3 id="使用value方法"><a href="#使用value方法" class="headerlink" title="使用value方法"></a>使用value方法</h3><p>value定义服务时，只能定义单一的常量服务，类似于key，value一样。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">service.value(&quot;name&quot;,&quot;elory&quot;);</div><div class="line">//使用时，直接将name赋值给其他变量</div></pre></td></tr></table></figure></p>
<h2 id="小样有话说："><a href="#小样有话说：" class="headerlink" title="小样有话说："></a>小样有话说：</h2><center style="color:green;font-weight: Bold;border:1px dotted #999">没话说</center>

<center><div style="border: 2px solid #999;border-top:none;border-left:none;width: 20px;height:20px;transform:rotate(45deg);"></div></center><br><center style="dispaly:block;width:300px;margin:0 auto"><span style="display:inline-block;float:left;width:100px;height:10px;border-top:1px solid #999;margin-top:15px;"></span><span><a href="https://github.com/Gong-Elory" target="_blank" rel="external">龚小样</a></span><span style=" display:inline-block;float:right;width:100px;height:10px;border-top:1px solid #999;margin-top:15px;"></span></center><br><center><span style="font-size:14px;line-height:14px;margin-top:0;">2017-08-07</span></center>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;服务的作用，就是对外提供某种功能。angularjs上定义它为一个单例对象（只允许有一个实例的对象）或是一个函数。&lt;br&gt;
    
    </summary>
    
      <category term="Angualarjs" scheme="http://ielory.com/categories/Angualarjs/"/>
    
    
      <category term="Angualarjs" scheme="http://ielory.com/tags/Angualarjs/"/>
    
      <category term="前端" scheme="http://ielory.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>跨域方法解读(待完善)</title>
    <link href="http://ielory.com/2017/07/27/%E8%B7%A8%E5%9F%9F%E6%96%B9%E6%B3%95%E8%A7%A3%E8%AF%BB-%E5%BE%85%E5%AE%8C%E5%96%84/"/>
    <id>http://ielory.com/2017/07/27/跨域方法解读-待完善/</id>
    <published>2017-07-27T09:30:16.000Z</published>
    <updated>2017-07-27T09:34:48.429Z</updated>
    
    <content type="html"><![CDATA[<p>协议、域名、子域名、端口号 任意一个不同，就叫跨域<br>同源策略的作用是为了保证用户信息安全，防止数据被恶意窃取。<br><a id="more"></a><br>由于同源策略的限制，会导致三种行为被限制：</p>
<pre><code>Cookie、Localstorage以及IndexDB无法读取
DOM无法获得
Ajax请求不能发送
</code></pre><p>解决Cookie无法共享的问题。在两位顶级域名相同，而次级域名不同时，<br>浏览器可以通过设置document.write来共享Cookie两个网页都设置document.domain = “samedomain.com” 即可<br>服务器可以在设置cookie时，指定cookie一级域名。Set-Cookie:domain=.samedomain.com</p>
<h2 id="iframe"><a href="#iframe" class="headerlink" title="iframe"></a>iframe</h2><p>iframe窗口无法与父窗口通信：<br>如果只是子域名不同，同样可以使用设置document.domain来规避<br>对于完全不同源的，有三种方法<br>1.通过片段标识符进行数据传输。父窗口把信息写入子窗口的片段标识符中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var src = url+&quot;#&quot;+data;</div><div class="line">$(&quot;myframe&quot;).src = src;</div><div class="line">//子窗口通过监听hashchange事件来通知子窗口获得数据</div><div class="line">window.onhashchange = function()&#123;</div><div class="line">    var msg = window.location.hash</div><div class="line">&#125;</div><div class="line">//这里的hash就是指url中包含的以#跟的多个字符。</div><div class="line">//子窗口也可以改变父窗口的hash</div><div class="line">parent.location.href = target + &quot;#&quot; + hash;</div></pre></td></tr></table></figure></p>
<p>此方法的缺点有：会产生历史记录，并且数据量有限</p>
<p>2.浏览器窗口有window.name属性，该属性最大的特点就是</p>
<p>无论是否同源，只要在一个窗口里，前一个网页设置了这个属性，后一个网页就可以读取他。<br>做法是指定iframe的src为不同域的网页，在这里修改window.name，然后将iframe的src改为同域网页。即可获取到window.name的数据。具体做法可以参考这篇文章:<a href="http://www.cnblogs.com/zichi/p/4620656.html" target="_blank" rel="external">window.name+iframe</a></p>
<p>3.window.postMessage方法，允许跨窗口通信，无论是否同源。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var ppp = window.open(&quot;http://son.com&quot;,&quot;title&quot;);</div><div class="line">ppp.postMessage(&quot;hello,son&quot;,&quot;http://son.com&quot;);</div></pre></td></tr></table></figure></p>
<p>第一个参数时发送的消息，第二个参数是接收消息的窗口的源。这个知识点在红宝书第16章讲过，但是措辞真是让人捉摸不透。格式为协议+域名+端口 也可以为“*”，表示想所有窗口发送。</p>
<p>双方可以通过message事件监听对方的消息。数据保存在event对象的data属性中。<br>event还有origin属性，可以用来过滤不是发给本窗口的信息。origin属性为消息发向的网址<br>source属性指的是发送消息的窗口</p>
<p>那么在子窗口中可以这样反馈：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">window.addEventListener(&apos;message&apos;,function(e)&#123;</div><div class="line">    if(e.origin != &quot;http://father.com&quot;) return;//不是发给我的，我不要</div><div class="line">    processMessage(e.data);//处理数据</div><div class="line">    e.source.postMessage(&quot;ok&quot;,e.origin);</div><div class="line">&#125;)</div><div class="line">//总结来说就是</div><div class="line">//接收信息的窗口对象.postMessage（&quot;信息内容&quot;，&quot;接受信息窗口的源&quot;）</div></pre></td></tr></table></figure></p>
<p>Ajax智能请求同源服务器，有三种常用方案规避这个限制。</p>
<h2 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h2><p>JSON是一种数据交换格式，JSONP是一种数据交互协议。</p>
<h3 id="JSON的优点"><a href="#JSON的优点" class="headerlink" title="JSON的优点"></a>JSON的优点</h3><pre><code>1.基于纯文本，跨平台传递很简单
2.js原生支持，后台语言支持
3.轻量级
4.可读性强
5.容易编写和解析
</code></pre><h3 id="JSONP-1"><a href="#JSONP-1" class="headerlink" title="JSONP"></a>JSONP</h3><p>我们知道，web页面调用js文件时，可以跨域。JSONP就是基于<code>&lt;script&gt;</code>标签<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">//在客户端页面中</div><div class="line">&lt;head&gt;</div><div class="line">    &lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">    //声明函数</div><div class="line">    var callbacker = function(data)&#123;</div><div class="line">        alert(data);</div><div class="line">    &#125;;</div><div class="line">    // 提供jsonp服务的url地址</div><div class="line">    var url = &quot;http://a.com/test.php?callback=callbacker&quot;;</div><div class="line">    // 创建script标签，设置其属性</div><div class="line">    var script = document.createElement(&apos;script&apos;);</div><div class="line">    script.setAttribute(&apos;src&apos;, url);</div><div class="line">    // 把script标签加入head，此时调用开始</div><div class="line">    document.getElementsByTagName(&apos;head&apos;)[0].appendChild(script); </div><div class="line">    &lt;/script&gt;</div><div class="line">&lt;/head&gt;</div><div class="line"></div><div class="line">//服务端页面</div><div class="line">根据返回的callback函数，生成一段带有数据的js代码，例如</div><div class="line">callbacker(&#123;</div><div class="line">    &quot;a&quot;:&quot;b&quot;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>在jquery中，实现jsonp调用，则是通过$.ajax()方法，参数上要修改一下。<br>回调函数不用添加在url后面，而是<br>设置datatype的值为”jsonp”<br>设置jsonp的值为”callbacker”,设置的值为参数名<br>设置jsonpCallback的值为函数名，可选属性<br>设置success：function（）{}。请求成功后回调函数的处理程序<br>设置error：function（）{}。请求失败后回调函数的处理程序</p>
<h3 id="ajax和jsonp的区别"><a href="#ajax和jsonp的区别" class="headerlink" title="ajax和jsonp的区别"></a>ajax和jsonp的区别</h3><p>虽然调用方式和目的一样，但是本质上不同。ajax的核心是通过XHR获取内容，而jsonp的核心则是动态添加<code>&lt;script&gt;</code>标签来调用服务器的js脚本。</p>
<h2 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h2><p>WebSocket是一种通信协议，使用ws://和我是说：wss://（加密）作为协议前缀。不受同源政策的限制<br>浏览器发出的请求头信息中如果包含字段Origin，其中包含的是请求源。服务器判断该源是否在白名单内，如果在，则做出响应。</p>
<h2 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h2><p>cors是W3C标准，全称跨域资源共享。他允许向跨院服务器发送XHR请求<br>目前所有浏览器都支持，只不过IE要不能低于IE10</p>
<p>浏览器将CORS请求分为两大类。简单请求和非简单请求。<br>只要满足两个请求就为简单请求。<br>1.请求方法是HEAD,POST,GET其中一种。<br>2.HTTP头信息不超出Accept，Accept-Language，Content-Language，Last-Event-ID，以及Content-Type<br>而Content-Type仅限于application/x-www-form-urlencode/multipart-data以及text/plain</p>
<h3 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h3><p>浏览器如果发现跨源ajax请求为简单请求，就会自动在头信息中，添加Origin字段。<br>如果请求源不在服务器的白名单内，服务器会返回一个正常的http回应，此时的回应头信息中没有Access-Control-Allow-Origin字段，浏览器就知道错了，因此会抛出一个错误，被XHR的onerror回调函数捕获。</p>
<p>Access-Control-Allow-Credentials字段可选为布尔值，表示服务器是否明确允许发送Cookie。<br>Access-Control-Expose-Headers字段可选。CORS请求时，XHR对象的getResponseHeader（）只能拿到6个基本字段，如果想拿到其他字段，就必须在Access-Control-Expose-Headers指定。如getResponseHeader（’a’），就可以拿到a字段的值。</p>
<h4 id="设置withCredentials属性控制Cookie的传输"><a href="#设置withCredentials属性控制Cookie的传输" class="headerlink" title="设置withCredentials属性控制Cookie的传输"></a>设置withCredentials属性控制Cookie的传输</h4><p>CORS默认不发送Cookie和HTTP认证信息，如果要，一方面服务器统一，指定Access-Control-Allow-Credentials字段，此外，还需要开发者在AJAX请求中设置<code>xhrobj.withCredentials=true</code>。如果有些浏览器在忽略此值时依然发送cookie，可手动关闭。</p>
<h3 id="非简单请求"><a href="#非简单请求" class="headerlink" title="非简单请求"></a>非简单请求</h3><p>非简单请求包括特殊请求，如PUT,DELETE，或者Content-Type字段为application/json。<br>费简单请求在正式通信之前，增加了一次HTTP查询请求，该请求的请求方法是OPTIONS,查询源是否在白名单中，那些字段被允许，得到响应后再正式发起XHR请求。</p>
<p>服务请回应查询请求是否允许跨院请求的依据是···Access-Control-Allow-Origin···字段是否为请求源或者*；<br>如果不是上面两种，浏览器就知道被拒绝了，同样触发XHR的onerror监听事件。</p>
<p>CORS与JSONP相比，优点就是支持所有HTTP请求。劣势在于兼容性没CORS好。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>【1】<a href="http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html#fa" target="_blank" rel="external">浏览器同源政策及其规避方法</a><br>【2】<a href="http://www.ruanyifeng.com/blog/2016/04/cors.html" target="_blank" rel="external">跨域资源共享 CORS 详解</a><br>【3】<a href="http://www.cnblogs.com/dowinning/archive/2012/04/19/json-jsonp-jquery.html" target="_blank" rel="external">说说JSON和JSONP，也许你会豁然开朗，含jQuery用例</a></p>
<h3 id="小样有话说："><a href="#小样有话说：" class="headerlink" title="小样有话说："></a>小样有话说：</h3><center style="color:green;font-weight: Bold;border:1px dotted #999">加油</center>

<center><div style="border: 2px solid #999;border-top:none;border-left:none;width: 20px;height:20px;transform:rotate(45deg);"></div></center><br><center style="dispaly:block;width:300px;margin:0 auto"><span style="display:inline-block;float:left;width:100px;height:10px;border-top:1px solid #999;margin-top:15px;"></span><span><a href="https://github.com/Gong-Elory" target="_blank" rel="external">龚小样</a></span><span style=" display:inline-block;float:right;width:100px;height:10px;border-top:1px solid #999;margin-top:15px;"></span></center><br><center><span style="font-size:14px;line-height:14px;margin-top:0;">2017-7-27</span></center>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;协议、域名、子域名、端口号 任意一个不同，就叫跨域&lt;br&gt;同源策略的作用是为了保证用户信息安全，防止数据被恶意窃取。&lt;br&gt;
    
    </summary>
    
      <category term="JS" scheme="http://ielory.com/categories/JS/"/>
    
    
      <category term="JS" scheme="http://ielory.com/tags/JS/"/>
    
      <category term="通信" scheme="http://ielory.com/tags/%E9%80%9A%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title>函数柯里化</title>
    <link href="http://ielory.com/2017/07/21/%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96/"/>
    <id>http://ielory.com/2017/07/21/函数柯里化/</id>
    <published>2017-07-21T12:00:19.000Z</published>
    <updated>2017-07-21T12:07:38.223Z</updated>
    
    <content type="html"><![CDATA[<p>函数柯里化（currying）<br>把接收多个参数的函数变换成接收单一参数的函数，并且返回一个函数，该函数接收余下的参数且返回新函数的技术。<br><a id="more"></a><br>一道题目<br>要实现的结果：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">add(<span class="number">1</span>)()= <span class="number">1</span>;</div><div class="line">add(<span class="number">2</span>)(<span class="number">3</span>)() = <span class="number">5</span>;</div><div class="line">add(<span class="number">1</span>)(<span class="number">2</span>,[<span class="number">3</span>,<span class="number">4</span>])()=<span class="number">10</span>;</div></pre></td></tr></table></figure></p>
<p>柯里化具有：延迟计算、参数复用、动态生成函数的作用、固定易变因素</p>
<h3 id="柯里化应用之–运算"><a href="#柯里化应用之–运算" class="headerlink" title="柯里化应用之–运算"></a>柯里化应用之–运算</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">    add(<span class="number">1</span>)()== <span class="number">1</span>;</div><div class="line">    add(<span class="number">2</span>)(<span class="number">3</span>)() == <span class="number">5</span>;</div><div class="line">    add(<span class="number">1</span>)(<span class="number">2</span>,[<span class="number">3</span>,<span class="number">4</span>])()==<span class="number">10</span>;</div><div class="line">    <span class="comment">//乘法</span></div><div class="line">    mult(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">4</span>) == <span class="number">8</span>;</div><div class="line">    </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="keyword">var</span> sum=<span class="number">0</span>;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">var</span> m <span class="keyword">of</span> <span class="built_in">arguments</span>)&#123;</div><div class="line">		(m <span class="keyword">instanceof</span> <span class="built_in">Array</span>)?sum+=<span class="built_in">arguments</span>.callee(m):sum+=m;	</div><div class="line">		<span class="comment">// sum+=((m instanceof Array)?arguments.callee(m):m)	</span></div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> sum;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">curryAdd</span>(<span class="params">fn</span>)</span>&#123;</div><div class="line">	<span class="keyword">var</span> _args = [];</div><div class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</div><div class="line">		<span class="keyword">if</span>(<span class="built_in">arguments</span>.length === <span class="number">0</span>)&#123;</div><div class="line">			<span class="keyword">return</span> fn.apply(<span class="keyword">this</span>,_args);</div><div class="line">		&#125;<span class="keyword">else</span>&#123;</div><div class="line">			<span class="built_in">Array</span>.prototype.push.apply(_args,<span class="built_in">arguments</span>);</div><div class="line">			<span class="keyword">return</span> <span class="built_in">arguments</span>.callee;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">curryAdd(sum)(<span class="number">1</span>)(<span class="number">2</span>,[<span class="number">3</span>,<span class="number">4</span>])() == <span class="number">10</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">mult</span>(<span class="params">x</span>)</span>&#123;</div><div class="line">	<span class="keyword">var</span> um=x;</div><div class="line">	</div><div class="line">	<span class="keyword">var</span> mu = <span class="function"><span class="keyword">function</span>(<span class="params">y</span>)</span>&#123;</div><div class="line">	    sum *=y;</div><div class="line">	    <span class="keyword">return</span> mu;</div><div class="line">	&#125;;</div><div class="line">	</div><div class="line">	mu.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> um&#125;;</div><div class="line">	<span class="keyword">return</span> mu;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="柯里化应用之–DOM事件绑定"><a href="#柯里化应用之–DOM事件绑定" class="headerlink" title="柯里化应用之–DOM事件绑定"></a>柯里化应用之–DOM事件绑定</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">addEvent</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="keyword">if</span>(<span class="built_in">window</span>.addEventListener)&#123;</div><div class="line">		<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">el,type,fn,capture</span>)</span>&#123;</div><div class="line">			el.addEventListener(type,fn,capture);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">window</span>.attachEvent)&#123;</div><div class="line">		<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">el,type,fn</span>)</span>&#123;</div><div class="line">			el.attachEvent(<span class="string">"on"</span>+type,fn);</div><div class="line">		&#125;</div><div class="line">	&#125;<span class="keyword">else</span>&#123;</div><div class="line">		<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">el,type,fn</span>)</span>&#123;</div><div class="line">			el[<span class="string">"on"</span>+type] = fn;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> aE = addEvent();</div><div class="line">aE(el,<span class="string">"click"</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;,<span class="literal">false</span>);</div></pre></td></tr></table></figure>
<h3 id="柯里化应用之–bind"><a href="#柯里化应用之–bind" class="headerlink" title="柯里化应用之–bind()"></a>柯里化应用之–bind()</h3><p>bind()会创建一个新函数（绑定函数），新函数与被调函数具有相同的函数体，当被调函数被调用时，this被绑定到bind()的第一个参数上。起主要作用就是将函数绑定在某个对象上。</p>
<p>bing()原理<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">    <span class="keyword">if</span>(!<span class="built_in">Function</span>.prototype.bind)&#123;</div><div class="line">	<span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span>(<span class="params">oThis</span>)</span>&#123;</div><div class="line">		<span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">"function"</span>)&#123;</div><div class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"fucntion.prototype.bind-what is trying to be bound is not callable"</span>);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">var</span> aArgs = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>,<span class="number">1</span>),</div><div class="line">		that = <span class="keyword">this</span>,</div><div class="line">		fNop = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;,</div><div class="line">		Bound = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		<span class="comment">//当返回的是构造函数是，oThis将被忽略</span></div><div class="line">			<span class="keyword">return</span> that.apply(<span class="keyword">this</span> <span class="keyword">instanceof</span> fNop?<span class="keyword">this</span>:oThis || <span class="keyword">this</span>,aArgs.concat(<span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>)));</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		fNop.prototype = <span class="keyword">this</span>.prototype;</div><div class="line">		fBound.prototype = <span class="keyword">new</span> fNop();</div><div class="line">		<span class="keyword">return</span> fBound;</div><div class="line">	&#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>目前应用的还少，等用到了在加深记忆。</p>
<h3 id="小样有话说："><a href="#小样有话说：" class="headerlink" title="小样有话说："></a>小样有话说：</h3><center style="color:green;font-weight: Bold;border:1px dotted #999">Nothig</center>

<center><div style="border: 2px solid #999;border-top:none;border-left:none;width: 20px;height:20px;transform:rotate(45deg);"></div></center><br><center style="dispaly:block;width:300px;margin:0 auto"><span style="display:inline-block;float:left;width:100px;height:10px;border-top:1px solid #999;margin-top:15px;"></span><span><a href="https://github.com/Gong-Elory" target="_blank" rel="external">龚小样</a></span><span style=" display:inline-block;float:right;width:100px;height:10px;border-top:1px solid #999;margin-top:15px;"></span></center><br><center><span style="font-size:14px;line-height:14px;margin-top:0;">2016-07-21</span></center>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;函数柯里化（currying）&lt;br&gt;把接收多个参数的函数变换成接收单一参数的函数，并且返回一个函数，该函数接收余下的参数且返回新函数的技术。&lt;br&gt;
    
    </summary>
    
      <category term="JS" scheme="http://ielory.com/categories/JS/"/>
    
    
      <category term="JS" scheme="http://ielory.com/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>本地文件的上传方法的思索及延伸</title>
    <link href="http://ielory.com/2017/07/20/%E6%9C%AC%E5%9C%B0%E6%96%87%E4%BB%B6%E7%9A%84%E4%B8%8A%E4%BC%A0%E6%96%B9%E6%B3%95%E7%9A%84%E6%80%9D%E7%B4%A2%E5%8F%8A%E5%BB%B6%E4%BC%B8/"/>
    <id>http://ielory.com/2017/07/20/本地文件的上传方法的思索及延伸/</id>
    <published>2017-07-20T13:47:27.000Z</published>
    <updated>2017-07-20T13:56:07.563Z</updated>
    
    <content type="html"><![CDATA[<p>上传本地文件时，用input标签。<br>拥有属性type，该属性设置为file时，将会显示为文件选择框特性，但是没有提供修改选择文件按钮的操作。因此常规做法是将input设置为display：none，通过点击外部的label标签来触发input的change事件。当然，不一定非得包裹input，也可以在其他地方。此外也可以用过其他标签来设置，例如a标签，点击a标签时，调用input元素的click()方法即可。<br><a id="more"></a></p>
<h2 id="FileReader"><a href="#FileReader" class="headerlink" title="FileReader"></a>FileReader</h2><p>该对象允许web应用程序异步读取存储在用户计算机上的文件的内容。使用File或者Bolb对象指定要读取的文件数据</p>
<p>File对象可以来自于用上在input元素上选择文件后返回的FileList对象，这是一个文件对象列表。也可以来自拖放操作。</p>
<p>通过new FileReader()返回FileReader实例，</p>
<h3 id="最常用的方法包括"><a href="#最常用的方法包括" class="headerlink" title="最常用的方法包括"></a>最常用的方法包括</h3><pre><code>abort();中断读取操作
readAsDataURL();
如果绑定了onload事件处理程序，那么在load成功之后，
result属性上将包含一个DataURL对象，其中包含读取的文件内容
readAsArrayBuffer()
readAsBinaryString()
readAsText()，原理相似，只是数据形式不同。
</code></pre><h3 id="常用的事件处理程序包括"><a href="#常用的事件处理程序包括" class="headerlink" title="常用的事件处理程序包括"></a>常用的事件处理程序包括</h3><pre><code>onabort中断读取时调用
onerror读取失败时调用
onload读取操作成功后调用
onloadend完成时调用，无论成功失败
onloadstart读取开始之前调用
onprogress读取过程中周期性调用
</code></pre><h3 id="FileReader应用-本地图片上传时的缩略图预览"><a href="#FileReader应用-本地图片上传时的缩略图预览" class="headerlink" title="FileReader应用-本地图片上传时的缩略图预览"></a>FileReader应用-本地图片上传时的缩略图预览</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"IE=edge"</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">title</span>&gt;</span>图书管理系统<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line">	</div><div class="line">	<span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">href</span>=<span class="string">"css/booksys.css"</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">href</span>=<span class="string">"css/dbs-common.css"</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">href</span>=<span class="string">"css/dbs-reset.css"</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrapper"</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"innner clearfix"</span>&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">""</span> <span class="attr">method</span>=<span class="string">""</span> <span class="attr">accept-charset</span>=<span class="string">"utf-8"</span>&gt;</span></div><div class="line">				<span class="tag">&lt;<span class="name">label</span> <span class="attr">id</span>=<span class="string">"fileBtn"</span> <span class="attr">for</span>=<span class="string">"fileInput"</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span>  <span class="attr">id</span>=<span class="string">"fileInput"</span> <span class="attr">style</span>=<span class="string">"display:none"</span> <span class="attr">multiple</span>=<span class="string">"multiple"</span> <span class="attr">accept</span>=<span class="string">"image/*"</span>&gt;</span>上传图片<span class="tag">&lt;/<span class="name">label</span>&gt;</span></div><div class="line">			<span class="tag">&lt;/<span class="name">form</span>&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"imageItem"</span>&gt;</span></div><div class="line">				<span class="tag">&lt;<span class="name">h4</span> <span class="attr">id</span>=<span class="string">"imageItemTit"</span>&gt;</span>图片预览<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></div><div class="line">				<span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"imagelist"</span>&gt;</span></div><div class="line">				<span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div><div class="line">			<span class="tag">&lt;/<span class="name">div</span>&gt;</span>		</div><div class="line">		<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">	<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"imagetemplate none"</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"imgItmli"</span>&gt;</span></div><div class="line">		    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">""</span> <span class="attr">alt</span>=<span class="string">""</span> <span class="attr">class</span>=<span class="string">"img"</span>&gt;</span></div><div class="line">		    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"imgName"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line">		<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">	<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"js/booksys.js"</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<pre><code>js代码
</code></pre><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> inputEle = <span class="built_in">document</span>.getElementById(<span class="string">"fileInput"</span>);</div><div class="line"><span class="keyword">var</span> fileBtn = <span class="built_in">document</span>.getElementById(<span class="string">"fileBtn"</span>);</div><div class="line"><span class="keyword">var</span> imagelist = <span class="built_in">document</span>.getElementById(<span class="string">"imagelist"</span>);</div><div class="line"><span class="keyword">var</span> imgItmli = <span class="built_in">document</span>.getElementsByClassName(<span class="string">"imgItmli"</span>)[<span class="number">0</span>];</div><div class="line"></div><div class="line"><span class="comment">//当input[file=type]发生改变时触发</span></div><div class="line">inputEle.onchange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		<span class="keyword">var</span> fileList = <span class="keyword">this</span>.files;</div><div class="line">		handleImage(fileList);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleImage</span>(<span class="params">files</span>)</span>&#123;</div><div class="line">	<span class="keyword">var</span> count=<span class="number">0</span>;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">var</span> i= <span class="number">0</span>;i&lt; files.length;i++)&#123;</div><div class="line">			<span class="keyword">var</span> file = files[i];</div><div class="line">			<span class="keyword">var</span> imagePattern = <span class="regexp">/^image\//</span>;</div><div class="line">			<span class="keyword">if</span>(!imagePattern.test(file.type))&#123;</div><div class="line">				<span class="keyword">continue</span>;</div><div class="line">			&#125;</div><div class="line">			<span class="comment">//克隆模板节点用于显示上传的缩略图以及名称</span></div><div class="line">			<span class="keyword">var</span> imgitemli = imgItmli.cloneNode(<span class="literal">true</span>);</div><div class="line">			<span class="keyword">var</span> img = imgitemli.getElementsByClassName(<span class="string">"img"</span>)[<span class="number">0</span>];</div><div class="line">			<span class="keyword">var</span> imgName = imgitemli.getElementsByClassName(<span class="string">"imgName"</span>)[<span class="number">0</span>];</div><div class="line"></div><div class="line">			img.file = file;</div><div class="line">			imgName.innerHTML = file.name;</div><div class="line">			imagelist.appendChild(imgitemli);</div><div class="line">			<span class="keyword">var</span> reader = <span class="keyword">new</span> FileReader();</div><div class="line">			<span class="comment">//当文件读取成功是，将读取到的图片数据赋值给img.src,从而显示图片</span></div><div class="line">			reader.onload = (<span class="function"><span class="keyword">function</span>(<span class="params">img</span>)</span>&#123;</div><div class="line">				<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</div><div class="line">					img.src = event.target.result;</div><div class="line">				&#125;</div><div class="line">			&#125;)(img);</div><div class="line">			<span class="comment">//以DATAURL形式读取文件，读取成功时触发load事件</span></div><div class="line">			reader.readAsDataURL(file);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="FileReader兼容性问题"><a href="#FileReader兼容性问题" class="headerlink" title="FileReader兼容性问题"></a>FileReader兼容性问题</h3><p>IE9及以下不支持，IE10以上部分支持。</p>
<h3 id="针对IE的解决方法"><a href="#针对IE的解决方法" class="headerlink" title="针对IE的解决方法"></a>针对IE的解决方法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//此时input不能设置为隐藏，而应该是透明</span></div><div class="line">fileImg.select();</div><div class="line"><span class="comment">//在IE9下，如果file控件获得焦点，document.selection.createRange拒绝访问</span></div><div class="line"><span class="comment">//因此添上下面这句</span></div><div class="line"><span class="comment">//input.blur();失去焦点，或者让其他的对象获得焦点element.focus();</span></div><div class="line">strPic = <span class="built_in">document</span>.selection.createRange().text;</div><div class="line"><span class="built_in">document</span>.selection.empty();</div><div class="line"><span class="keyword">var</span> img = imgitemli.getElementsByClassName(<span class="string">"img"</span>)[<span class="number">0</span>];<span class="comment">//一个类为img的div标签</span></div><div class="line">img.style.filter =<span class="string">"progid:DXImageTransform.Microsoft.AlphaImageLoader(sizingMethod=scale)"</span>;</div><div class="line">img.filters.item(<span class="string">"DXImageTransform.Microsoft.AlphaImageLoader"</span>).src = strPic;</div></pre></td></tr></table></figure>
<pre><code>提到文件上传，不得不追溯一下他的历史
</code></pre><h2 id="文件上传历史"><a href="#文件上传历史" class="headerlink" title="文件上传历史"></a>文件上传历史</h2><h3 id="iframe上传"><a href="#iframe上传" class="headerlink" title="iframe上传"></a>iframe上传</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> foem = <span class="built_in">document</span>.getElementById(<span class="string">"upload-form"</span>);</div><div class="line"><span class="keyword">var</span> url = foem.getAttribute(<span class="string">'action'</span>);</div><div class="line">foem.onsubmit = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="comment">//生成随意数</span></div><div class="line">    <span class="keyword">var</span> ran = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*<span class="number">1000</span>);</div><div class="line">    <span class="keyword">var</span> id= <span class="string">"upload-form-"</span>+ran;</div><div class="line">    <span class="keyword">var</span> handler = <span class="string">"upload-handler-"</span>+ran;</div><div class="line">    <span class="keyword">var</span> iframe = <span class="built_in">document</span>.createElement(<span class="string">"iframe"</span>);</div><div class="line">    iframe.id = id;</div><div class="line">    iframe.style.display = <span class="string">"none"</span>;</div><div class="line">    iframe.name = id;</div><div class="line">    <span class="comment">//设置表单的target属性指向iframe，使得上传结束后，</span></div><div class="line">    <span class="comment">//服务器将结果返回iframe窗口，此时foem所在的窗口就不会跳转</span></div><div class="line">    foem.setAttribute(<span class="string">'target'</span>,id);</div><div class="line">    foem.appendChild(iframe);</div><div class="line">    <span class="comment">//设置action属性，使服务器知道回掉函数名称，</span></div><div class="line">    <span class="comment">//方便将服务器饭返回的信息从iframe传你到上层页面</span></div><div class="line">    foem.setAttribute(<span class="string">'action'</span>,url+<span class="string">'?iframe='</span>+handler);</div><div class="line">    </div><div class="line">&#125;</div><div class="line"><span class="built_in">window</span>[handler] = funtion()&#123;</div><div class="line">    <span class="comment">//移除框架</span></div><div class="line">    iframe.remove();</div><div class="line">    foem.removeAttribute(<span class="string">'target'</span>);</div><div class="line">    foem.setAttribute(<span class="string">"action"</span>,url);</div><div class="line">    <span class="built_in">window</span>[handler] = <span class="literal">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="ajax上传"><a href="#ajax上传" class="headerlink" title="ajax上传"></a>ajax上传</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> foem = <span class="built_in">document</span>.getElementById(<span class="string">"upload-form"</span>);</div><div class="line">foem.onsubmit = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span>(<span class="built_in">window</span>.FormData)&#123;</div><div class="line">        <span class="keyword">var</span> formData = <span class="keyword">new</span> FormData();</div><div class="line">        <span class="comment">//建立一个key为upload的表单项，值为上传的文件</span></div><div class="line">        formData.append(<span class="string">'upload'</span>,<span class="built_in">document</span>.getElementById(<span class="string">'upload'</span>).files[<span class="number">0</span>]);</div><div class="line">        <span class="keyword">var</span> xhr= <span class="keyword">new</span> XMLHttpRequest();</div><div class="line">        xhr.open(<span class="string">'POST'</span>,<span class="keyword">this</span>.getAttribute(<span class="string">'aciton'</span>));</div><div class="line">        xhr.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</div><div class="line">            <span class="keyword">if</span>(xhr.status === <span class="number">200</span>)&#123;</div><div class="line">                <span class="built_in">console</span>.log(<span class="string">"upload successed"</span>);</div><div class="line">            &#125;<span class="keyword">else</span>&#123;</div><div class="line">                <span class="built_in">console</span>.log(<span class="string">"upload error"</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        xhr.send(foemData);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="延伸-FormData"><a href="#延伸-FormData" class="headerlink" title="延伸-FormData"></a>延伸-FormData</h3><pre><code>利用FormData可以通过JS用一些简直来模拟表单控件。使用send方法异步提交表单。
比起普通的ajax，使用FormData的最大优点就是可以异步上传二进制文件。
append（）方法
为当前对象添加一对键值
兼容IE10+
</code></pre><h3 id="延伸-进度条"><a href="#延伸-进度条" class="headerlink" title="延伸-进度条"></a>延伸-进度条</h3><pre><code>XMLHttpRequest第二版定义的progress事件可用来做进度条
</code></pre><p>流程为：</p>
<p>step1<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;progress id=<span class="string">"upprog"</span> min=<span class="string">"0"</span> max=<span class="string">"100"</span> value=<span class="string">"0"</span>&gt;<span class="number">0</span>&lt;<span class="regexp">/progress&gt;</span></div></pre></td></tr></table></figure></p>
<p>step2<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//progress事件是定义在upload上的，因为还有下载，下载也有progress事件</span></div><div class="line">xhr.upload.onprogress = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span>(e.lengthComputable)&#123;</div><div class="line">        <span class="keyword">var</span> complete = (e.loaded/e.total*<span class="number">100</span> | <span class="number">0</span>);</div><div class="line">        <span class="keyword">var</span> progress = <span class="built_in">document</span>.getElementById(<span class="string">"upprog"</span>);</div><div class="line">        progress.value = progress.innerHTML = complete;</div><div class="line">    &#125;   </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="小样有话说："><a href="#小样有话说：" class="headerlink" title="小样有话说："></a>小样有话说：</h2><center style="color:green;font-weight: Bold;border:1px dotted #999">谨此而已</center>

<center><div style="border: 2px solid #999;border-top:none;border-left:none;width: 20px;height:20px;transform:rotate(45deg);"></div></center><br><center style="dispaly:block;width:300px;margin:0 auto"><span style="display:inline-block;float:left;width:100px;height:10px;border-top:1px solid #999;margin-top:15px;"></span><span><a href="https://github.com/Gong-Elory" target="_blank" rel="external">龚小样</a></span><span style=" display:inline-block;float:right;width:100px;height:10px;border-top:1px solid #999;margin-top:15px;"></span></center><br><center><span style="font-size:14px;line-height:14px;margin-top:0;">2017-7-20</span></center>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上传本地文件时，用input标签。&lt;br&gt;拥有属性type，该属性设置为file时，将会显示为文件选择框特性，但是没有提供修改选择文件按钮的操作。因此常规做法是将input设置为display：none，通过点击外部的label标签来触发input的change事件。当然，不一定非得包裹input，也可以在其他地方。此外也可以用过其他标签来设置，例如a标签，点击a标签时，调用input元素的click()方法即可。&lt;br&gt;
    
    </summary>
    
      <category term="JS" scheme="http://ielory.com/categories/JS/"/>
    
    
      <category term="Javascript" scheme="http://ielory.com/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>由一道题引发的连串思考</title>
    <link href="http://ielory.com/2017/07/11/%E7%94%B1%E4%B8%80%E9%81%93%E9%A2%98%E5%BC%95%E5%8F%91%E7%9A%84%E8%BF%9E%E4%B8%B2%E6%80%9D%E8%80%83/"/>
    <id>http://ielory.com/2017/07/11/由一道题引发的连串思考/</id>
    <published>2017-07-11T15:39:01.000Z</published>
    <updated>2017-07-12T02:43:50.114Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章因为一个题目，让我回顾了很多知识点，知道了new操作到底干了些啥？<br><a id="more"></a><br>最近看见一道js考题。题目是<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; alert (<span class="number">1</span>); &#125;;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div><div class="line">Foo.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; alert (<span class="number">2</span>);&#125;;</div><div class="line">Foo.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; alert (<span class="number">3</span>);&#125;;</div><div class="line"><span class="keyword">var</span> getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; alert (<span class="number">4</span>);&#125;;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>) </span>&#123; alert (<span class="number">5</span>);&#125;</div><div class="line"> </div><div class="line"><span class="comment">//请写出以下输出结果：</span></div><div class="line">Foo.getName();</div><div class="line">getName();</div><div class="line">Foo().getName();</div><div class="line">getName();</div><div class="line"><span class="keyword">new</span> Foo.getName();</div><div class="line"><span class="keyword">new</span> Foo().getName();</div><div class="line"><span class="keyword">new</span> <span class="keyword">new</span> Foo().getName();</div></pre></td></tr></table></figure></p>
<p>磨蹭了半天硬是没有做全对，我不禁陷入了沉思。<br>看完答案后，我再次陷入沉思，这道题麻雀虽小，五脏俱全啊。</p>
<p>JS运算符的优先级。</p>
<p>在解答题目之前先要弄懂哪个括号，哪个点先执行。<br>题目涉及到也是最需要记住的优先级排序为<br><code>a.b成员访问</code> = <code>new(带参数列表)</code> = <code>（）函数调用</code> &gt; <code>new(无参数列表)</code></p>
<center><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence" target="_blank" rel="external">点击这里查看更多关于优先级的介绍</a></center>

<h2 id="题目概述："><a href="#题目概述：" class="headerlink" title="题目概述："></a>题目概述：</h2><p>第一条是声明了Foo一个函数，第二条给Foo定义了个属性，第三条给Foo的的原型对象定义了个属性，第四条利用函数变量表达式法创建了一个getName函数，第五条，声明了一个getName函数。</p>
<h2 id="开始解答"><a href="#开始解答" class="headerlink" title="开始解答"></a>开始解答</h2><p>解题之前需要弄清楚js的运行模式。<br>JS运行包括两部分 编译阶段和执行阶段<br>在代码开始执行之前，JS解析器通过<strong>函数声明提升 function declaration hoisting</strong>读取变量以及函数，并将它们放到源代码树的顶部（应该是当前作用域源代码的顶部）<br>因此经过函数声明提升后，题目应该变成了</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; alert (<span class="number">1</span>); &#125;;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> getName;<span class="comment">//变量提升</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>) </span>&#123; alert (<span class="number">5</span>);&#125;<span class="comment">//函数提升</span></div><div class="line">Foo.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; alert (<span class="number">2</span>);&#125;;</div><div class="line">Foo.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; alert (<span class="number">3</span>);&#125;;</div><div class="line">getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; alert (<span class="number">4</span>);&#125;;</div></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>问题1：Foo.getName();</li>
</ul>
</blockquote>
<p>根据优先级判断，先访问的是Foo的getName属性，并调用。所以最终会弹出<code>2</code></p>
<blockquote>
<ul>
<li>问题2：getName();</li>
</ul>
</blockquote>
<p>调用getName方法，然而题目中确定义了两次getName函数，<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; alert (<span class="number">4</span>);&#125;;<span class="comment">//通过函数表达式的方式</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>) </span>&#123; alert (<span class="number">5</span>);&#125;<span class="comment">//通过函数声明的方式</span></div></pre></td></tr></table></figure></p>
<p>在变量声明提升的过程中，所有函数声明和变量都提升到顶部，但是函数表达式的赋值<code>getName = function () { alert (4);};</code>是在执行到该行代码是，才进行的。经过函数声明提升后，表达式法的getName覆盖函数声明的getName，所以，最终弹出<code>4</code> 而不是<code>5</code></p>
<blockquote>
<ul>
<li>问题3：Foo().getName();</li>
</ul>
</blockquote>
<p>从左到右先执行Foo（），此时返回this，this指向条用当前函数的对象，因为Foo（）是在全局环境下执行的，所以this指向window，此外Foo（）函数执行过程中给getName属性赋值了，由于不是采用var声明的，因此为全局变量，相当于覆盖了全局变量getName，最终被修改alert（1），Foo().getName()；相当于执行 window.getName()；所以最终会弹出<code>1</code>.</p>
<blockquote>
<ul>
<li>问题4：getName();</li>
</ul>
</blockquote>
<p>由于题目是按顺序依次执行，getName已经在题3中被修改为alert（1），所以这题依然弹出<code>1</code>.</p>
<blockquote>
<ul>
<li>问题5：new Foo.getName();</li>
</ul>
</blockquote>
<p>按照优先级，首先是成员访问Foo.getName，然后new操作，所以最终会弹出<code>2</code>。<br>我刚开始也很差异，还有这种操作，new到底是啥?</p>
<p>继续看题</p>
<blockquote>
<ul>
<li>问题6：new Foo().getName();</li>
</ul>
</blockquote>
<p>先执行new Foo（），在执行.getName（）<br>此时，先构建了一个实例化对象，对象又返回值，为了直观一点，可以这样表示<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> Foo（）；</div><div class="line">a.getName();</div></pre></td></tr></table></figure></p>
<p>这里涉及到<strong>原型对象</strong>和<strong>原型链</strong>的知识，<br>我们知道，当创建一个函数时，就会根据特定规则为该函数创建一个prototype属性，指向函数的原型对象，<br>当调用函数，创建一个实例时，该实例内部将包含一个指向构造函数的原型对象的指针。</p>
<p>原型链就是根据 创建实例，实例内部会包含一个指向构造函数原型对象的指针的特性，来层层递进，构成链式。</p>
<p>这里还需要对<strong>构造函数有无返回值导致返回的是什么</strong>做出了解。<br>如果没返回值，或者返回值为基本类型，或者为this，都将返回其实例化对象，该对象拥有属性<em>proto</em><br>若返回值为引用类型，则返回这个引用类型。</p>
<p>题目中返回的是this，所以为实例化对象，a中并没有可以访问的属性，因此沿着原型链向上一层查找，找到原型对象中的getName属性，所以最终弹出<code>3</code>。有人会问，谁说实例中没有属性了啊。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; alert (<span class="number">1</span>); &#125;;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里面明明就有一个属性getName。额…我也是这里错了。这只是个变量，全局变量，并不是属性。那要怎么做，才能达到想要的效果呢。换成<code>this.getName</code>就好了。</p>
<blockquote>
<ul>
<li>问题7：new new Foo().getName();</li>
</ul>
</blockquote>
<p>一个new已经很烦了，居然两个new。先来看一下优先级。<br>先执行new Foo（） 然后执行.getName，最后执行new..（）。<br>一直到第二步，都和上例相同，返回的是函数<code>fuction（）{alert（3）} new</code>的结果就是弹出<code>3</code></p>
<p>讲到这是不是以为要结束了，其实还没有，不然我就不可能沉思这么久了。这几道题，有一个操作符赚足了眼球，多得令人恶心，就是new，new到底是啥，以前只知道new一下，就有一个实例了，他到底怎么办到的？这是接下来总结的重点。</p>
<h2 id="new到底做了啥"><a href="#new到底做了啥" class="headerlink" title="new到底做了啥"></a>new到底做了啥</h2><center><a href="http://blog.vjeux.com/2011/javascript/how-prototypal-inheritance-really-works.html" target="_blank" rel="external">点我进入这篇安利的文章，让我受益良多</a></center>

<p>new出一个指向构造函数的原型对象的实例总共分几步？<br>看程序：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">New</span>（<span class="title">f</span>）</span>&#123;</div><div class="line">    <span class="keyword">var</span> n = &#123;<span class="string">'__proto__'</span>: f.prototype&#125;;<span class="comment">//step1.创建一个对象n，里面包含_proto_属性，指向f.prototype对象</span></div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>（）</span>&#123;</div><div class="line">        <span class="keyword">var</span> obj = f.apply(n,<span class="built_in">arguments</span>); <span class="comment">//step2.n对象调用f函数</span></div><div class="line">		<span class="keyword">if</span>(obj <span class="keyword">instanceof</span> <span class="built_in">Object</span>)&#123;</div><div class="line">		<span class="comment">//如果执行F函数体，F带返回值，且是引用类型，则</span></div><div class="line">			<span class="keyword">return</span> obj<span class="comment">//返回执行F函数体返回的引用对象</span></div><div class="line">		&#125;<span class="keyword">else</span>&#123;</div><div class="line">		<span class="comment">//如果返回的是基本类型或者没返回，则返回对象n</span></div><div class="line">			<span class="keyword">return</span> n;<span class="comment">//返回n	</span></div><div class="line">		&#125;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fc</span>（<span class="title">age</span>,<span class="title">name</span>）</span>&#123;</div><div class="line">    <span class="keyword">this</span>.age = age;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> nn = New（Fc）;</div><div class="line"><span class="comment">/*nn 为function（）&#123;</span></div><div class="line">        var ob = Fc.apply(n,arguments); /n对象调用f函数</div><div class="line">        if(ob instanceof Objrct)&#123;</div><div class="line">		</div><div class="line">            return ob</div><div class="line">        &#125;</div><div class="line">        else&#123;</div><div class="line">            return n;//返回n</div><div class="line">        &#125;</div><div class="line">        //如果F函数体有返回值，判断是否为引用类型，不是的话丢弃，是的话返回。this的话ob,n都一样</div><div class="line">    &#125;</div><div class="line">*/</div><div class="line"><span class="keyword">var</span> obj = nn(<span class="number">10</span>,<span class="string">"tom"</span>);</div><div class="line">obj就是最终的实例化对象。obj拥有age 和name属性，此外obj拥有一个指向Fc.prototype的指针。</div></pre></td></tr></table></figure></p>
<blockquote>
<p>总的来说 new首先创建了一个对象，并让对象的<em>proto</em>属性指向构造函数的原型对象，然后利用apply方法让对象执行一遍F函数体，让其拥有F的属性和方法以及构造函数原型链上的属性和方法。</p>
<h2 id="小样有话说："><a href="#小样有话说：" class="headerlink" title="小样有话说："></a>小样有话说：</h2><center style="color:green;font-weight: Bold;border:1px dotted #999">可以被打到，但不会被打败(●—●)</center>

</blockquote>
<center><div style="border: 2px solid #999;border-top:none;border-left:none;width: 20px;height:20px;transform:rotate(45deg);"></div></center><br><center style="dispaly:block;width:300px;margin:0 auto"><span style="display:inline-block;float:left;width:100px;height:10px;border-top:1px solid #999;margin-top:15px;"></span><span><a href="https://github.com/Gong-Elory" target="_blank" rel="external">龚小样</a></span><span style=" display:inline-block;float:right;width:100px;height:10px;border-top:1px solid #999;margin-top:15px;"></span></center><br><center><span style="font-size:14px;line-height:14px;margin-top:0;">2017-7-11</span></center>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章因为一个题目，让我回顾了很多知识点，知道了new操作到底干了些啥？&lt;br&gt;
    
    </summary>
    
      <category term="JS" scheme="http://ielory.com/categories/JS/"/>
    
    
      <category term="Javascript" scheme="http://ielory.com/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>墨迹天气产品分析报告：工具类APP普适性延展方向与盈利模式思索</title>
    <link href="http://ielory.com/2017/04/20/%E5%A2%A8%E8%BF%B9%E5%A4%A9%E6%B0%94%E4%BA%A7%E5%93%81%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A%EF%BC%9A%E5%B7%A5%E5%85%B7%E7%B1%BBAPP%E6%99%AE%E9%80%82%E6%80%A7%E5%BB%B6%E5%B1%95%E6%96%B9%E5%90%91%E4%B8%8E%E7%9B%88%E5%88%A9%E6%A8%A1%E5%BC%8F%E6%80%9D%E7%B4%A2/"/>
    <id>http://ielory.com/2017/04/20/墨迹天气产品分析报告：工具类APP普适性延展方向与盈利模式思索/</id>
    <published>2017-04-20T10:19:41.000Z</published>
    <updated>2017-04-20T11:06:47.823Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要针对商业模式以及未来转型两方面对墨迹天气进行分析。<br>文章排版格式出了问题，如果是处女座或者完美主义者，请移步人人都是产品经理<a href="http://www.woshipm.com/evaluating/641182.html" target="_blank" rel="external">墨迹天气产品分析报告：工具类APP普适性延展方向与盈利模式思索</a>。<br><a id="more"></a></p>
<h2 id="体验环境"><a href="#体验环境" class="headerlink" title="体验环境"></a>体验环境</h2><pre><code>体验机型：IPhone6
系统版本： IOS10.3
APP版本：6.3.3
体验时间： 2017.4.18
</code></pre><h2 id="分析目的"><a href="#分析目的" class="headerlink" title="分析目的"></a>分析目的</h2><pre><code>了解墨迹天气的产品战略、产品模式、竞争态势
分析墨迹天气盈利模式以及未来延展方向
总结工具类APP普适性商业模式以及延展方向
</code></pre><h2 id="市场分析"><a href="#市场分析" class="headerlink" title="市场分析"></a>市场分析</h2><h3 id="移动互联网市场"><a href="#移动互联网市场" class="headerlink" title="移动互联网市场"></a>移动互联网市场</h3><p>据Analysys易观数据显示，2016年中国移动互联网用户达8.3亿，预计2017年，用户数量达到8.59亿。较2016年增长5.1%，如图所示，用户整体规模增速放缓，还未出现饱和迹象。因此，庞大的移动用户群体催生出庞大的市场规模仍然不容小觑。据估计，2017年互联网市场规模为60542.5亿元人民币，较2016年增长29.6%。</p>
<center><img src="http://image.woshipm.com/wp-files/2017/04/9B75o7eWpVKP9BD60Cxe.png" alt="分析报告"></center>

<h3 id="中国移动工具应用市场"><a href="#中国移动工具应用市场" class="headerlink" title="中国移动工具应用市场"></a>中国移动工具应用市场</h3><p>随着4G网络的普及，移动互联网也迅速发展，在此大环境下，移动工具应用也进入高速发展时期。 自2014年，猎豹移动出海并成功打开国际市场后，越来越多的工具类应用也加入到开拓海外市场的行列中，而且这种行为将成为必然。移动工具应用有别于社交等应用，对地域文化属性的依赖弱，但是用户需求与国内用户相似，由于这种天然的优势，使得该类应用出海阻力较小。从中国移动工具应用市场AMC模型图中可以看到，在中国移动工具应用的高速发展时期， 国内移动工具应用的市场认可度一直处于递增态势，预计移动应用市场将于2019年后步入应用成熟期，此后，用户需求将被充分满足，市场格局也将区域稳定，竞争也将更加激烈。</p>
<center><img src="http://image.woshipm.com/wp-files/2017/04/3gbu7iDn1nzcRJGdERsR.png" alt=""></center><br>在中国移动互联网用户规模继续扩大的大环境下，工具类应用积累的用户数量也在急剧增大。目前，WiFi万能钥匙用户9亿，月活1.98亿，搜狗输入法用户达到5.2亿，月活1.47万人，天气应用墨迹天气用户已达5亿，月活跃用户1.09亿。图片编辑软件美图秀秀的用户已达4.7亿，月活0.5亿。（数据略微有偏差，请指正）。如此庞大的用户群体，其创造的价值（商业价值、数据价值）将是巨大的。<br><br>然而，大部分用户只去使用能满足其基本需求的功能，如何提升用户停留时长、激励用户去尝试新功能，如何增加用户粘性，在同质化产品中保持竞争优势，以及商业变现、未来转型则是目前各大工具类应用现阶段（高速发展期）所共同面临的问题。<br>—————-（这一块格式出问题了）<br>## 产品简介<br>### 基本信息<br>—————-（这一块格式出问题了）<br><br><strong>产品名称</strong>：墨迹天气<br><strong>产品slogan</strong>：关心天气，更关心你<br><strong>产品定位</strong>：一款支持天气、环境信息查询，帮助用户更好的做出生活决策的生活服务工具类软件。(官方的说法：免费的天气信息查询软件)<br><strong>产品关键字</strong>（从网页源码中提取）：墨迹天气，天气预报，天气，生活贴士，星座，温馨提示，炫酷天气，GPS定位，语音播报，桌面皮肤<br><br>网页的关键字主要用于SEO，也是该产品的宣传重点。这些关键字根据属性可以分三类：<br>第一类：业务基本信息，包括墨迹天气，天气预报，天气，炫酷天气。这类信息是SEO中常用的堆积关键字法，目的就<br>是在用户搜索天气时，能够尽可能的先看到墨迹天气的宣传网页。<br>第二类：业务功能信息，包括温馨提示，炫酷天气，GPS定位，语音播报，桌面皮肤。除GPS定位属基础型需求外，其他的四项皆属于兴奋性需求，有这个功能，用户的好感会明显增加，没有这些功能，用户也不会觉得怎样。<br>第三类：生活服务信息：生活贴士、星座。生活贴士暂且理解为墨迹天气的生活指数版块。<br><br><br><center><img src="http://image.woshipm.com/wp-files/2017/04/FpFNuJKFq7X1V1JukDxG.png" alt=""></center>

<p>生活指数版块包含两方面信息。一是常规生活提醒，各类天气状况、生活指数。进入子页面后，除了常规提醒外，针对护肤、钓鱼、穿衣，均有与之相关的资讯。第二个版块是商业入口版块。其中墨迹洗车为自家入口，其他皆为第三方入口。商家从性质定位上勉强能和生活指数这个版块有联系。（本文将在稍后具体分析商业模式这一块，在这不做过多解释。 ）</p>
<blockquote>
<ul>
<li>产品logo：</li>
</ul>
</blockquote>
<center><img src="http://image.woshipm.com/wp-files/2017/04/Q0wREWUuOz8dkcLxaoCs.png" alt=""></center>


<h3 id="用户构成"><a href="#用户构成" class="headerlink" title="用户构成"></a>用户构成</h3><p>墨迹天气的用户男女比例接近6:4，年龄集中在24-35岁之间，约占60%。用户集中在中端消费人群类，该类人群已基本实现生活小康。经济基础决定上层建筑，在人们满足基本温饱需求后，就上升到对生活品质、精神层面上的追求。如何去满足该类精神层面的需求并超出预期将是一个很好的拓展 。此外该类人群对健康和空气质量（间接影响健康）有较强的关注度。他们具备一定的消费能力，比较容易接受新生事物，但购买过程相对谨慎。</p>
<h3 id="核心用户"><a href="#核心用户" class="headerlink" title="核心用户"></a>核心用户</h3><p>主流用户为上班族。</p>
<p>该类用户在年龄、消费属性上符合墨迹天气用户的主流用户属性特征。</p>
<p>上班族产生看天气的需求主要表现在一下几种场景：</p>
<p>晚上(早上起床) 查看天气，确定明天（今天）的大致天气、空气状况，来作出上班的着装、是否需要带雨具、戴口罩等决定。<br>制定相应出行（聚会、旅游、出差）计划时，查看出行时间段的天气状况，从而决定是否需要更改计划。<br>自然灾害（暴雨、台风、泥石流） 多发地区，查看预警提前做好相关防灾准备。</p>
<h3 id="用户画像"><a href="#用户画像" class="headerlink" title="用户画像"></a>用户画像</h3><p>顾明，在沿海一线城市某互联网公司担任web前端工程师，单身。顾明在工作日的生活基本上是朝九晚九，经常加班。因为天气状况很不稳定，因此在每天晚上顾明都要打开墨迹天气确定明天是否带带雨具、是否要备上衣服。周末，除了加班之外，经常去参加一些文体活动或者出游。在这个过程中，需要根据墨迹天气上的天气状况决定是否要调整时间或者改变活动方式。</p>
<h3 id="核心竞争力"><a href="#核心竞争力" class="headerlink" title="核心竞争力"></a>核心竞争力</h3><center><img src="http://image.woshipm.com/wp-files/2017/04/Vv3PbdhNOouuFQhyopSt.png" alt=""></center><br>据Analysys易观最新发布的《中国天气应用市场季度监测报告2016年第3季度》显示，墨迹天气的市场占有率以55.2%大幅度领先，多出第二名天气通41个百分比。面对天气应用APP同质化非常严重的情况，之所以墨迹天气占据着强势的市场份额，离不开其先入为主，在蓝海阶段抢占市场的原因。墨迹天气出生自塞班时代，发力较早，此外抓准了用户查看天气的刚需。其核心竞争力总结来说是：大量早期用户的积累以及用户使用习惯的培养.<br>—————-（这一块格式出问题了）<br>## 功能分析<br><br>### 版本记录（只记录了有具体功能产出的版本）<br>—————-（这一块格式出问题了）<br>2016.05.03 5.8.5<br>首页搜索地名，智能推荐周边景点&amp;时景美图<br>时景相机优化，没网先保存，先拍再发省流量。<br><br>2016.06.02 5.8.7<br>积分商城，泡墨圈，玩时景，聊话题。每日赚积分，开心兑好礼。<br>墨圈全新改版，发现有趣的墨友和圈子。<br>墨迹咨询新改版，内容更丰富<br><br>2016.06.23 5.8.8<br>短时预报：完美躲过短时阵雨<br>明星家族穿衣助手<br>首页搜索地名、周边景点、当地天气一键获取<br><br>2016.08.04 6.0<br>地图模式呈现空气质量、查找身边的空气监测站<br>墨妹对话框，更丰富的天气内容<br>首页模块全新整合，精准咨询快速到达、<br><br>2016.09.07 6.0.6<br>台风预警<br><br>2016.09.27 6.0.8<br>“我”页面全新改版。<br>精准城市定位<br><br>2016.11.22 6.1.6<br>个性助手优化升级<br>资讯详情页新增关联阅读<br>增加分享功能<br><br>2016.12.07 6.1.9<br>视频频道上线<br>评论功能登录墨迹专题<br><br>2017.1.10 6.2.2<br>空气质量24小时逐时查询<br>降雪信息加入短时预报<br>优化系统更新体验<br>优化天气单位设置功能<br>从最近9个月主要版本更新记录来看（数据来源于APPStore，部分版本没有新功能记载，因此选择忽略），墨迹天气在三个主板块都有动作。<br><br>### 天气板块<br><br>1. 增加首页搜索地名、智能推荐周边景点，查看时景美图<br><br>该功能满足用户对旅行目的地天气状况存在疑惑时，能够查询目的地最近的天气状况、实景的需求。<br><br>进入天气页后，在没有广告的情况下，搜索入口时隐藏的。下拉当前页，搜索框显示。进入搜索页面。除了搜索框外。还有”猜你想找“，”墨友都在搜“、”历史纪录“三个板块。”猜你想找“板块主要是根据定位，自动推荐周边景点。点击某一景点后，有该地区最近五天的天气信息，此刻的实景，以及百度搜索当地的入口（见下图2）。<br><br>分析：该功能基于基础需求服务，为用户提供目的地的天气状况和实景。在这个功能中大致包含两个盈利点。一是“墨友都在搜”的字段，二是目的地的百度入口。<br><center><img src="http://image.woshipm.com/wp-files/2017/04/tsNdaaCZvKR6MZ9BGxVI.png" alt=""></center><br>点击图中的1、2处，都会直接跳转到百度该信息的搜索页。<br>是否还有可增加的盈利点？有，用户点击搜索框的动机为：<br>有出行想法，想搜索一下某地的最近的天气状况。<br>已经在大致目的地，想了解具体位置的天气状况。<br>用户短期出行主要包括出差、旅行。因此在搜索某地后，除了有当地的热门景点外，还可以考虑添加住宿、车票预定等多个板块。目前流量主要是导向百度，然后通过百度分发给其他OTA。完全可以直接跳过中间商，与OTA寻求合作。<br><br>2. 短时预报：完美躲过短时阵雨<br><br>该功能解决了用户在短期时间内（按小时计）不能了解具体天气状况的痛点。<br><br>是否还有可增加的盈利点：提醒文案除了用小墨外，可以用第三方商家。参考“美的动车组提醒您，……”。之所以没有去开发这个盈利点的原因可能是：该方法对自身品牌有影响，容易喧宾夺主。短期时报是以通知的形式告知用户，加入广告，会让用户产生反感情绪。<br><br>3. 视频频道<br><center><img src="http://image.woshipm.com/wp-files/2017/04/81t8OWDYvR9kZAWqdR7q.png" alt=""></center><br>前三张图将所有资讯功能的入口标明，墨迹资讯的入口达三个之多，可见墨迹对这资讯功能的重视程度。<br><br>资讯功能类似于一个内容聚合平台。用户可以自动订阅想要看得内容。包含基础的增、删、排序功能。首先，针对墨迹天气这样一款工具软件而言，资讯功能对用户来说属于无差异型需求，有没有这个功能，对用户的使用这个产品的影响不大。用户使用天气APP的刚需是看天气。我们也可以从上图2的今日推荐评论数量看出用户对该板块的喜好程度。<br><br>资讯功能最新上线了视频频道。墨迹天气设置视频频道为必须显示频道。即用户不订阅该频道或者删除该频道，实际上操作都是无效的，用户依然可以在图4的顶部看到该频道。墨迹资讯页面的底部功能标签<br><br>出来常规刷新功能外，还有视频功能标签。从以上两点墨迹天气对视频频道的重视程度是非常大的。<br><br>视频频道内的内容主要来自于秒拍视频、快视频、梨视频等。普通视频播放量在20次左右，部分视频（两性）播放量次数稍高，这也印证了用户比例男性稍多的事实。<br><br><strong>建议</strong>：<br>图4，刷新视频列表除了可以通过下拉列表激活也可以通过点击底部标签实现。切换到视频频道可以通过点击顶部标签和底部标签切换。根据奥多姆剃刀原则，如无必要，勿增实体。建议去掉底部标签。重复的标签反而会让用户的选择更加困难，增加用户的疑惑，此外，功能的重复也显得格外臃肿。<br><br>据体验发现，有关两性的视频播放量相对于其他视频播放量较高。建议对各类型视频播放量进行分析，将视频分类归纳，更能有针对性的吸引用户。<br><br>### 时景版块<br><br>墨迹天气时景版块的icon会不定期更新，与其他两个icon相比，更加吸引人眼球，这也是墨迹天气最想突出的重点。<br><center><img src="http://image.woshipm.com/wp-files/2017/04/ojNkPr8XUHX0F18HVvc3.png" alt=""></center><br>时景做的是图片社交，并且是以场景驱动的基于地理位置图片社交。用户认为某地方的景色好，照一张照片并上传，在此过程个中，其他用户可以直接点赞、或者点击图片进行评论。<br><center><img src="http://image.woshipm.com/wp-files/2017/04/P2vfijJKZC4W5k3jbOzX.png" alt=""></center><br>首先图片的质量参差不齐，内容不丰富，无法去吸引用户进一步的了解后面的深意，无法让用户产生深入挖掘信息的欲望。其次，目前图片的展示形式为两列六张。该种形式分散了用户的注意力，无法集中精力去欣赏一张图，这样的后果就是加快了用户浏览图片的速率，然而却降低了用户的互动深度，无法带来沉浸式的感受。<br><br>墨迹天气吸引用户去点击时景，去浏览美图，去参与互动。然而，根据版本记录的记录情况，墨迹天气在该版本的更新迭代很慢。最近一次更新为2016.05.03 5.8.5版本，优化时景相机，没网先保存，先拍再发省流量。然而，作为一个以内容驱动的板块，却没有在如何激励用户产出优质内容上做工作，着实令人费解。<br><br>根据社交网络三元素定义：连接关系（通过什么媒介去结交新朋友，管理老朋友，通过什么去建立社会连接），传染物（内容）（通过什么媒介传递思想，传递情绪，促使互动 ），互动（通过互动，来使内容发布者得到认同感以及尊重等）。作为工具型产品，用户本身是没有注册会员的习惯的，这无疑是给做社交增加了一道大槛。此外，图片的视觉表达缺乏语义上的精确描述，不适合用户进行准确的双向沟通。通过一张图片激发的互动也是暂时性的，通过一张图片建立的连接关系是无法沉淀的。因此，连接关系的建立对于墨迹天气是一块短板，传染物质量不齐无法激发持续互动，更无法沉淀关系。针对传染物，建议提供添加滤镜功能。滤镜可以弱化图片瑕疵，使图片质量整体上升。<br><br>### “我”版块——积分商城<br><center><img src="http://image.woshipm.com/wp-files/2017/04/23En8YMr1mi916eAdBb4.png" alt=""></center><br>一款优秀的工具型应用应该是用完即走的，因此注册对于用户来说是不必要的，然而每一款工具型产品转型社区，做的第一步就是增加注册用户。墨迹天气引进用户激励体系—用户积分制度。通过做日常任务来换取积分，积分可以在积分商城兑换。<br><br>首先，积分制的引入确实可以增加注册用户，然而积分商城内的商品对用户来说吸引力不大。积分只能兑换抽奖机会和折扣券，带给用户不真实的感觉。<br><br><strong>建议</strong>：兑换奖品分为抽奖机会、虚拟商品（充值卡，折扣券）、实物。根据加个档次来制定兑换规则。<br><br>### 总结<br><br>墨迹天气在版本迭代中不断增添社交功能，除了不断完善的时景版块外，在天气（首页）版块，添加了一键分享按钮，见下图。页面右上角分别为资讯和一键分享按钮。<br><br>两功能放置在首页右上角，位置显眼，一键分享作为社交功能的一部分，通过社群力量，扩大墨迹天气的影响力，资讯是偏社区的功能， 可以猜测墨迹天气目前阶段的延展方向是社区化。<br><br>一个社区的正常运转离不开内容的驱动。然而就目前情况来看，无论是资讯、还是时景板块，其内容的驱动力还是较弱的。资讯板块的内容主要是诸多第三方提供，无论是内容、展现形式都各有差异。此外，广告的硬性插入更是给用户带来强烈的反感。如下图的搜狐新闻广告（点进去后，进入搜狐新闻下载页）。<br><br><br><br>时景板块内容为UGC，同样也存在着质量问题，如何激励用户产生优质内容，以及发掘优质内容产生者应该是目前主要的问题。<br><br>此外，就目前墨迹天气聚合了多家第三方入口的情况来看，墨迹天气的第二个还有第二个延展方向也很明显，工具型产品向平台型产品延展。从墨迹天气现有的信息架构可以看出，平台化相对于社区化是比较成功的。首页（天气）的生活指数子版块共有第三方入口5个，搜索功能中包含第三方入口1个，“我”版块中包含第三方入口有19个。平台化的顺利发展离不开墨迹天气的用户体量。墨迹天气拥有5亿用户，月活一亿。超大的流量资源更容易去吸引第三方平台合作，然而“量 ”达到了，“质” 是否跟得上是墨迹天气现阶段需要考虑的问题。<br><br>墨迹天气在向平台化和社区化两个方向同时延展，然而这两个方向却有着不可避免的冲突。前者提供诸多第三方入口，将用户引流至第三方。而后者则是尽可能的让用户长时间停留在该应用上，去产生内容，去互动。到底是流入他方，还是留存，其中的度需要把握好。<br><br>## 盈利模式分析<br><br>墨迹天气得益于早起的人口红利，积累了大量用户，大流量以压倒性优势竞争对手无法证明对抗。墨迹天气的盈利模式以广告、流量导入第三方为主，自营商城（墨迹商城）、智能硬件为辅。<br><br>### 广告<br><br>墨迹商城的广告位存在于应用个板块中。保守统计有12个。<br><br>主要分类为：<br><br>     启动页广告<br>     顶部banner<br>     商家icon<br>     小墨助手着装<br>     资讯页banner<br>     搜索框（如果有商家买下搜索框广告位，搜索框不隐藏，直接展现）<br>     线下活动<br><br><center><img src="http://image.woshipm.com/wp-files/2017/04/qPXEAdxcq6R4VHKYGSCD.png" alt=""></center><br>其中启动页广告、资讯页banner、商家icon、部分顶部banner为硬广告。这类广告是传统PC广告的延续，是目前移动产品最主要的一种广告形式，但是用户会习惯性过滤掉该类广告。<br><br>部分顶部banner、小墨助手卡通人物着装为软广，这类广告一般为第三方与墨迹深入定制合作的产物。如上图所示，顶部banner专题活动，首先时景版块主要功能为用户拍照分享。一加手机与使用该功能的用户群重合度高，采用这种方式略显创意，商业性质不明显，不会引起用户的强烈反感，还会带来口碑传播。<br><br>### 第三方引流<br><br>墨迹天气与第三方合作，入口遍布整个应用。主要存在于生活指数子板块、今日推荐子板块、休闲娱乐子版块，功能服务子版块，入口保守估计达25个。<br><br>墨迹天气的大用户数量优势对第三方商户来说是一个亮点。众多的第三方入口，让墨迹天气扮演者分类信息平台的角色，如何提升点击量，提升转化率是目前需要考虑的问题。<br><br>### APP推荐<br><br>墨迹天气拥有5亿的用户量，墨迹天气的”发现app”为应用分发入口。但是大部分APP都与墨迹的使用情景不符合，相关性不大。<br><br>### 智能硬件<br><br>墨迹自主研发的智能能空气质量检测仪——空气果，售价999元，售价较昂贵。<br><br>### 墨迹商城<br><br>除了售卖自家空气果外，还包含其他各类智能硬件，以空气净化器为主。<br><center><img src="http://image.woshipm.com/wp-files/2017/04/u6QV8Cih40NQ32bEV0OY.png" alt=""></center><br>上图是2016，1-2季度墨迹天气的营收构成，可以看到，墨迹天气的主要营收来源于广告，约占99%。然而部分硬广告对用户来说无疑是反感的，如何去平衡用户与商户，是墨迹天气需要考虑的问题<br><br>## 总结<br><br>作为工具型产品的代表性应用，墨迹天气具备大多数工具应用低技术门槛、无内容继承、无社交属性、同质化严重的特点。他在转型路上的探索值得所有工具类APP借鉴，但是在思考转型的前提是思考产品是否满足了用户的刚需，解决了他们的痛点并且拥有良好的用户体验。<br><br>目前，工具类型延展方向主要是两个：<br><br><strong>（1）社区化</strong><br><br>墨迹天气的社区化探索主要体现在：<br><br>图片社区，该板块属于UGC形式；<br>资讯，接入第三方内容。图片的质量无法激发用户互动的欲望的问题仍需改善。由第三方导入的资讯质量更是参差不齐。<br>工具类型APP的社区化，首先要保证社区内的内容质量；其次，要考虑如何能够持续的生成优秀的内容；此外，还要考虑采用什么用户激励体系才促进用户互动。目前适用于工具类的激励体系主要是用户积分制度和用户等级制度。<br><br><strong>（2）平台化</strong><br><br>但是向这个方向延展时，首先需要考虑当前APP是否拥有足够大的流量。墨迹天气向平台化的延展离不开其大流量优势，然而，其平台内容分类杂且散。所以如何根据场景，或者用户重合度来聚合不同的第三方入口、第三方APP需要仔细考虑。<br><br>墨迹天气的盈利主要来源于广告，然而部分广告是以牺牲用户体验为代价的。因此，工具类型APP在打广告时，需要根据实际情况选择广告模式。例如结合广告商的产品形式，策划相关的专题活动。另外可以根据用户使用APP的情景插入符合情景的广告，在恰当的场景中让用户关注广告，能提高转化率。此外，第三方引流和APP推荐都是工具类APP可参考的盈利模式。<br>### 小样有话说：<br><center style="color:green;font-weight: Bold;border:1px dotted #999">拥抱变化</center>

<center><div style="border: 2px solid #999;border-top:none;border-left:none;width: 20px;height:20px;transform:rotate(45deg);"></div></center><br><center style="dispaly:block;width:300px;margin:0 auto"><span style="display:inline-block;float:left;width:100px;height:10px;border-top:1px solid #999;margin-top:15px;"></span><span><a href="https://github.com/Gong-Elory" target="_blank" rel="external">龚小样</a></span><span style=" display:inline-block;float:right;width:100px;height:10px;border-top:1px solid #999;margin-top:15px;"></span></center><br><center><span style="font-size:14px;line-height:14px;margin-top:0;">2017-04-20</span></center>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要针对商业模式以及未来转型两方面对墨迹天气进行分析。&lt;br&gt;文章排版格式出了问题，如果是处女座或者完美主义者，请移步人人都是产品经理&lt;a href=&quot;http://www.woshipm.com/evaluating/641182.html&quot;&gt;墨迹天气产品分析报告：工具类APP普适性延展方向与盈利模式思索&lt;/a&gt;。&lt;br&gt;
    
    </summary>
    
      <category term="产品分析" scheme="http://ielory.com/categories/%E4%BA%A7%E5%93%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="用户体验" scheme="http://ielory.com/tags/%E7%94%A8%E6%88%B7%E4%BD%93%E9%AA%8C/"/>
    
      <category term="PM" scheme="http://ielory.com/tags/PM/"/>
    
      <category term="产品分析" scheme="http://ielory.com/tags/%E4%BA%A7%E5%93%81%E5%88%86%E6%9E%90/"/>
    
      <category term="墨迹天气" scheme="http://ielory.com/tags/%E5%A2%A8%E8%BF%B9%E5%A4%A9%E6%B0%94/"/>
    
  </entry>
  
  <entry>
    <title>谈谈柴静的书与纪录片</title>
    <link href="http://ielory.com/2017/02/12/%E8%B0%88%E8%B0%88%E6%9F%B4%E9%9D%99%E7%9A%84%E4%B9%A6%E4%B8%8E%E7%BA%AA%E5%BD%95%E7%89%87/"/>
    <id>http://ielory.com/2017/02/12/谈谈柴静的书与纪录片/</id>
    <published>2017-02-12T13:27:44.000Z</published>
    <updated>2017-02-12T13:34:10.351Z</updated>
    
    <content type="html"><![CDATA[<p>一支烟放在医学家面前，让他据此写三千字。他肯定会写尼古丁含量，几支烟就可以毒死一只小白鼠。放在美术设计师面前，同样的要求。他肯定会标志的特色，烟纸的设计。同样让经济学家，他会写，烟草是国家税收大户。<br><a id="more"></a><br>上面这段话出自《看见》，道理很浅显：同样的事物在不同人眼中会有不同的定义。作者柴静，一名记者，通过他的视角向我们讲述了当时社会上一些热点事件背后的故事。但我不是记者，我相信他的很多读者也不是记者。我们各自汲取着自己所需的东西，或许有些道理并不是她想要向我们表达的，但我们有我们的吸收方式。</p>
<p>看完这本书，让我深刻的东西不多。哪怕有些章节，譬如《沉默在尖叫》，为监狱中的女人湿过眼，但由于这些真正发生的事离我太远，我也只能在章节完毕时，祈祷反家庭暴力法快点拥有具体的操作程序，而不是一纸空文，不在让悲剧一次次发生。祈祷那些仍受到迫害的女性能够拿起手法律武器抗争下去。祈祷完毕，继续读下一章。但又几段话，我却记得深刻。</p>
<hr>
<blockquote>
<p>为了一个目的，哪怕是一个正义的目的，就像车轮一样狠狠輾过人心，也是另一种戾气。</p>
</blockquote>
<hr>
<blockquote>
<p>自由是针对外面的束缚而言的，独立是你们自己的事，给你自由而不独立，仍是奴隶。独立要不盲从，不受欺骗，不依赖门户，不依赖别人，这就是独立的精神。</p>
</blockquote>
<hr>
<blockquote>
<p>探寻就是要不断相信、不断怀疑、不断幻灭、不断摧毁、不断重塑、为的只是避免成为偏见的附庸。</p>
</blockquote>
<hr>
<blockquote>
<p>“念起即觉，觉即不随” 人是不能清空自己的情绪判断的，但要有个戒备，念头起来要能察觉，察觉之后就不跟随他。</p>
</blockquote>
<hr>
<blockquote>
<p>和解，是在心里留一个位置，让那个人可以进来。</p>
</blockquote>
<hr>
<blockquote>
<p>不要因为走的太远，而忘记为什么出发的。</p>
</blockquote>
<p>这些话和那些鸡汤没多大区别，但是理解他们的过程，就是构建一套属于自己的价值观的过程。知道如何分析事物，评判事物的正误。</p>
<p>之前，柴静的《穹顶之下》引发了一场风波。当时我记得在纪录片推出时，空间，朋友圈几乎一致性的转发这个视频，并配上“同呼吸，共命运”的标语。我看到是关于雾霾，我看都没看，就转发了。之后，柴静阴谋论甚嚣尘上。有趣的事，我最敬爱的思修老师前一天还在跟着我们一起“同呼吸，共命运”，第二天就来了个180度大转弯，着实让人忍俊不禁。我看完《看见》之后，第一时间恶补了这个纪录片。老实说，看完后，感觉还不错。</p>
<p>我先抛开柴静阴谋论不说，单纯说说这部记录片的正面效应。从《看见》到《穹顶之下》，柴静的中心都在人上，她关心的是人，尤其是在这个浮夸风盛行的年代，都想搞个大新闻吸引眼球的年代。他的女儿因为长期的雾霾，只能被关在家，后来他看见楼下学校一群学生在雾霾天还在外面玩耍，她知道她不可能关她的女儿一辈子，女儿迟早要接触社会，接触雾霾。于是他做了很多新闻人不做的事，找根源，提建议。想想，每天这么多新闻报道，播报雾霾的数不胜数，但有多少是会去深入的探寻的，我想有部分原因是因为身处体制内，有些事不是因为自己想做就做的，另外，则可能是因为思想深远的记者太少了。</p>
<p>片子里讲到雾霾是什么，是什么产生了雾霾。说实话，看的时候我都不敢呼吸，哪怕我窗外阳光正好。左小祖咒配音的雾霾侵入人体的动画更是给了我震撼，原来雾霾就是这样伤害人体的。其中讲到雾霾产生外在原因：煤、油气。内在原因：监督主体不明、油标不行。等，我能记住的就这么多。最后讲的解决办法，与我相关的则是：路程短别开车，举报污染企业，记住12369这个举报电话。</p>
<p>我相信，大部分的观众在看完纪录片之后能够想起的就是这些东西。我也相信记住这些东西的都是支持柴静的，他说了很多我们想知道却不知道的事，想说却不敢说的事，想做不敢做的事。我记得最深刻一件事就是这个纪录片播出后，微博了出现了很多拍污染企业艾特相关部门的微博，因为这是《穹顶之下》给我们的建议，是它让我们做了以前不敢做的事。</p>
<blockquote>
<p>今天你可以失去获得它的权利，你不抗争，明天你同样会失去更多的权利。</p>
</blockquote>
<p>这句话出自《看见》。我们都有权利保护身处的环境，《穹顶之下》告诉了我们，我们是有这个权利的。柴静带领我们，走了第一步。</p>
<p>这部纪录片火爆的时候，我没有看。因为我能想到里面说了些什么。无非就是该如何如何保护环境，治理雾霾，从我做起。我以为这部记录片能推动群众投入到环保中来。后来发生的一切让人诧异。纪录片被封杀，反柴静一派开始壮大，我当时很好奇，这个社会怎么了，播雾霾也能有人喷，这个社会没救了。</p>
<p>今天，我看了这部记录片，知道了一些里面的细节，我才觉得发生的一切是多么的正常。第一：播出的时间太敏感。两会即将召开，此时视频爆发赚足了眼球。这种运营手段很容易让人产生遐想。第二：数据造假。作为一个纪录片，最重要的就是真实，造假明显是越了红线。第三：说是自费，事实却是有利益相关的金主指导。第四：提出的解决方法太有针对性。说实话，这些是我的价值观无法接受的，但是这些不针对人的证据是符合道德标准的。然而，提出另外一些证据的人我实在无言以对：<br>孩子肿瘤推动舆论，柴静是个大烟民，一切后果源于她自己。我看过视频，柴静并没有说孩子患肿瘤是因为雾霾引起的，开头就说出生后就做了肿瘤移除手术。然而一些别有用心的人，为了达到他们火上浇油，黑柴静黑到彻底的目的，恶意捏造事实。</p>
<blockquote>
<p>为了一个目的，哪怕是一个正义的目的，就像车轮一样狠狠輾过人心，也是另一种戾气。</p>
</blockquote>
<p>这句话出自《看见》,我觉得很好地形容了这群捏造证据的人。</p>
<p>还有些人谈到柴静拥有大排量的SUV。强行把这件事与阴谋联系在一起。难道我播个纪录片，我就只能过回原始人生活，难道就因为我知道二氧化碳会引起全球变暖，我就不准呼吸吗？这是何等滑稽。</p>
<p>当然柴静并非没有不妥的地方，提出问题可以，但请别把答案定的太死。《看见》一书中就有说到，然而柴静本人就是说说而已，并没有记在心底并执行。柴静在记录片中给出了一条解决方案：天然气开发私有化。没有任何前提，也没有做过多的条件分析，不谈任何基础。首先我是认同竞争能促进市场的良性发展，我也知道垄断带来的不良后果。然而只提私有化，真的能完美的解决问题吗？私有化怎么私，一家一个天然气标准，你确定你敢用？这是这个记录片最大的缺陷之一。</p>
<p>这部纪录片被封杀我觉得在情理之中。因为不是所有的人都知道取其精华，弃其糟粕。但是如果都以一个否定的眼光去看待事情，我想以后像这样敢于跳出来说话的人都没有了。这个社会要有反对的声音，但同样需要有支持的声音。</p>
<blockquote>
<p>唯有完人才能向罪人扔石子，但是这世界上不存在完人。</p>
</blockquote>
<p>这句话出自《看见》，我把这句话献给所有人。</p>
<p>这部记录片有其发人深省的一面，同样有其阴暗的一面。但如何看它，则取决于看它的人了。</p>
<h2 id="小样有话说："><a href="#小样有话说：" class="headerlink" title="小样有话说："></a>小样有话说：</h2><center style="color:green;font-weight: Bold;border:1px dotted #999">对于挺柴和砍柴，我选择中立。她不是完人，我也不是。</center>

<center><div style="border: 2px solid #999;border-top:none;border-left:none;width: 20px;height:20px;transform:rotate(45deg);"></div></center><br><center style="dispaly:block;width:300px;margin:0 auto"><span style="display:inline-block;float:left;width:100px;height:10px;border-top:1px solid #999;margin-top:15px;"></span><span><a href="https://github.com/Gong-Elory" target="_blank" rel="external">龚小样</a></span><span style=" display:inline-block;float:right;width:100px;height:10px;border-top:1px solid #999;margin-top:15px;"></span></center><br><center><span style="font-size:14px;line-height:14px;margin-top:0;">2017-2-12</span></center>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一支烟放在医学家面前，让他据此写三千字。他肯定会写尼古丁含量，几支烟就可以毒死一只小白鼠。放在美术设计师面前，同样的要求。他肯定会标志的特色，烟纸的设计。同样让经济学家，他会写，烟草是国家税收大户。&lt;br&gt;
    
    </summary>
    
      <category term="随笔" scheme="http://ielory.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="书评" scheme="http://ielory.com/tags/%E4%B9%A6%E8%AF%84/"/>
    
  </entry>
  
  <entry>
    <title>Kindle，不曾遇见的惊喜</title>
    <link href="http://ielory.com/2017/01/10/Kindle%EF%BC%8C%E4%B8%8D%E6%9B%BE%E9%81%87%E8%A7%81%E7%9A%84%E6%83%8A%E5%96%9C/"/>
    <id>http://ielory.com/2017/01/10/Kindle，不曾遇见的惊喜/</id>
    <published>2017-01-10T06:50:22.000Z</published>
    <updated>2017-01-14T09:57:58.932Z</updated>
    
    <content type="html"><![CDATA[<p>在我没接触到Kindle之前，我对它是嗤之以鼻的。我认为电子书再怎么注重用户体验，它能模仿纸质书那种翻书的感觉吗?它能有纸质书那种对眼睛温和的感觉吗？我对纸质书产生的好感，或许是从小到大对它接触得多，没有看电子书的习惯。习惯翻页时纸张摩擦的声音，习惯左手上的页数慢慢增加而带来的满足与自豪，习惯在停顿的时候折叠小角来保存进度。此外，也从来没有过这样一件为看书而生的装备。<br><a id="more"></a></p>
<h2 id="手机、平板看书弱在哪？"><a href="#手机、平板看书弱在哪？" class="headerlink" title="手机、平板看书弱在哪？"></a>手机、平板看书弱在哪？</h2><p>智能手机的兴起，各种应用随之诞生。在手机上看电子书的历史还早于智能手机诞生，我想很多90后应该有过用诺基亚看小说的经历。当时的手机功能单一，而在如今，智能手机俨然成了一些人的全世界，你在看电子书的同时，或许还在担心会不会错过QQ好友的信息，会查看淘宝的物流信息，会惦记着刚刚用美团点好的外卖怎么还不到，亦或是有没有收到好友的游戏邀请。单单其中一条就足以让你分心，而无法专注于书中的内容。如今的智能手机都采用液晶显示屏，此类屏靠不断地刷新（闪烁）来更新内容，只不过频率高，肉眼感觉不到，这样很容易造成眼疲劳。长时间的用手机看电子书给眼镜带来很大的负担。商人从中发现商机，推出各类贴膜例如防蓝光，防辐射膜等等。后者纯属是收智商税，前者有一定作用，主要是可缓解眩光，减轻部分视疲劳症状。所以，尽管用手机看书的历史悠久，但是对它没有半点兴趣，最多便是看一下讲义，答案罢了。</p>
<h2 id="为什么要买Kindle？"><a href="#为什么要买Kindle？" class="headerlink" title="为什么要买Kindle？"></a>为什么要买Kindle？</h2><p>第一次动摇想买一个Kindle是因为买书的钱对我来说是一笔大的费用。以致于不得不常年光顾孔夫子旧书网、闲鱼等二手书交易市场。此外，有些书动辄400页，出行带着着实在太笨重。但这个念头产生不久之后就不了了之了。直到几天后，亲手试用了朋友入手的Kindle，在无背光条件下，屏幕上的文字就和纸质书一般，清晰不刺眼。我是信天命的人，有些东西命中注定会与你相见就一定会，Kindle就是如此，从第一次遇见，我就对它表现出好感，以致于当晚便下了订单。</p>
<h2 id="Kindle受宠有其原因"><a href="#Kindle受宠有其原因" class="headerlink" title="Kindle受宠有其原因"></a>Kindle受宠有其原因</h2><p>Kindle之所以从推出之后，备受好评，最主要的原因就是接近于纸质书，细心的人会发现Kindle屏幕并不是光滑的，而是接近于磨砂的，这种细节上的打磨对于那些喜欢纸质书手感的人来说无疑不是一个入手的好理由。此外Kindle采用的Elnk屏（电子纸/墨水屏），这种屏幕是全反射式，会随着环境光的变化有不同的效果。在户外，其体验完全和纸质书一样。在夜晚，则可以通过调整背光达到光线柔和不刺眼的效果，这是手机，Pad等电子产品不能比拟的。但是说Elnk不伤眼，纯属胡说，看纸质书都伤眼，何况是在电子产品上看书呢，只不过该屏幕对眼睛的伤害小于LED/LCD。</p>
<h2 id="初次使用Kindle要克服的障碍"><a href="#初次使用Kindle要克服的障碍" class="headerlink" title="初次使用Kindle要克服的障碍"></a>初次使用Kindle要克服的障碍</h2><p>初次使用Kindle的人肯定会有很多的不习惯，我长期使用IOS系统，对响应速度极度苛求。然而Kindle的响应速度实在不敢恭维，尤其是在打字做笔记的时候。此外，Kindle在跳转到图片页的时候，会出现闪屏，具体表现是屏幕会在极短的时间内黑一下屏。其原因并不是因为机器出故障，而是这种屏幕的刷新机制。总之，一句话：天然去雕饰，习惯成自然。不过有人给了我一个信服的理由，让我不再去抱怨闪屏：实体书翻页的时候还有“闪屏”呢，也不见你抱怨啊。想想还似乎很有道理，翻实体书页的时间刚好抵消了闪屏的时间，我是不是应该感谢一下Kindle解放了我手指。</p>
<hr>
<blockquote>
<p>警告，从这里开始将会有不断地干货涌现，可能会引起某些正版主义者的不适。在这里声明一下我的立场：我支持正版。也希望大家跟我一起支持正版！！！</p>
</blockquote>
<h2 id="服务号推荐"><a href="#服务号推荐" class="headerlink" title="服务号推荐"></a>服务号推荐</h2><p>Kindle是用来读书的，资源肯定不能少。亚马逊商城上有不少免费书籍，可以订阅。此外，会有各种优惠活动，供大家选择。然而这并不是我说的重点，对于大部分学生党来说，钱总是不够的，我也是如此。</p>
<h3 id="kindle推吧"><a href="#kindle推吧" class="headerlink" title="kindle推吧"></a>kindle推吧</h3><p>在众多电子书推送平台中，我最推荐的是它 ———— <code>kindle推吧</code>：<br><img src="http://oeqcvcrxo.bkt.clouddn.com/tuiba.png" alt="kindle推吧"><br>这个公众号给我的体验非常完美。</p>
<pre><code>优点：
    1.新用户可享受为期5天的vip服务。
    2.vip用户每天可推送30本电子书，普通用户每天3本。
    3.推送时间极快（10s内）。
缺点：暂时没有发现
</code></pre><p>我觉得这个公众号给我的印象是：近乎全免的服务，服务质量也很高。我希望在享受优质服务的同时，也为他们贡献自己的绵薄之力，定个会员，帮他们优化服务。<br><img src="http://www.biaoqingjia.com/biaoqing/201607/857d1b3cfde301032c7dcb2206cfad22.gif" alt="不就是钱嘛？"></p>
<h3 id="Kindle电子书库"><a href="#Kindle电子书库" class="headerlink" title="Kindle电子书库"></a>Kindle电子书库</h3><p>第二个公众号，服务质量稍逊于<code>kindle推吧</code>，它叫———— <code>Kindle电子书库</code>：<br><img src="http://oeqcvcrxo.bkt.clouddn.com/shuku.png" alt="kindle电子书库"></p>
<pre><code>优点：
    1.免费推送
    2.书目较多
缺点：
    1.推送时间不稳定（5分钟~无穷）
    2.每天最多推送10本，不然更不稳定（无穷~无穷）
</code></pre><p>声明一下，第一个公众号的书目也不少，并且更新得快。</p>
<h3 id="Kindle同步推"><a href="#Kindle同步推" class="headerlink" title="Kindle同步推"></a>Kindle同步推</h3><p>第三个公众号主要用于免费订阅公众号文章————<code>Kindle同步推</code>。<br><img src="http://oeqcvcrxo.bkt.clouddn.com/gongzhong.png" alt="Kindle同步推"><br>至于订书的功能，还是用上面的两个吧。</p>
<h2 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h2><h3 id="技巧一：书可以多囤，但必须分好类"><a href="#技巧一：书可以多囤，但必须分好类" class="headerlink" title="技巧一：书可以多囤，但必须分好类"></a>技巧一：书可以多囤，但必须分好类</h3><p>有人不同意多囤书，认为书屯多了，反倒吃着碗里的，看着锅里的，因此建议Kindle一次只放三本书，看完再下。</p>
<p>说的很有道理，我表示部分认同。我相信很多人都有同感，无论是手机还是其他电子产品，买回来的第一件事就是下APP，什么都下，然后慢慢删除，这是人的本性，有的时候很难改变。此外，对与有屯书习惯的，肯定有考虑自己可能在某一段时间接触不到Wi-Fi,因此会本能的多下几本，以备后用。</p>
<p>因此我建议，能做到不屯书，尽量不屯书。要屯书也不要超过100本。书屯多了，会造成机子部分功能卡顿。<br>如果你已经屯了，并不想改掉这个习惯。那么请做好一下事情。</p>
<pre><code>1.把所有的书按照书本属性分好类
2.给最近三个月定好计划书单
举例： 一月书单、二月书单、考前必读书单等。
</code></pre><p><img src="http://oeqcvcrxo.bkt.clouddn.com/shudan.png" alt="书单"><br><strong>注意：计划书单内的书不能过多，最多三本，看完再加，不然跟属性书单没什么区别了</strong><br>很多人屯完书后，很少会去想，我什么时候才能把这些书读完。而是只有一个模糊的概念：我要读完。一般这样说的最后都没有读完，因此必须有非常明确的计划。</p>
<h3 id="技巧二：-截屏位置要注意"><a href="#技巧二：-截屏位置要注意" class="headerlink" title="技巧二： 截屏位置要注意"></a>技巧二： 截屏位置要注意</h3><p>Kindle有截屏的手势，就是同时按下屏幕的对角。新手注意：一定要按<code>最靠边</code>的对角，不然没效果。如果成功截屏，会出现闪屏提醒（黑屏一下）。<br><img src="http://oeqcvcrxo.bkt.clouddn.com/kindle.jpg" alt="截屏"></p>
<h3 id="技巧三：-关闭特惠广告"><a href="#技巧三：-关闭特惠广告" class="headerlink" title="技巧三： 关闭特惠广告"></a>技巧三： 关闭特惠广告</h3><p>无论是进入Kindle主页还是在待机的时候，Kindle都会播放广告。看起来很烦人。解决办法很简单。点击【全部设置】-&gt; 【设备选项】-&gt;【个性化您的Kindle】-&gt;【高级选项】-&gt;【特惠】就可以根据需求关闭广告了。</p>
<h3 id="技巧四：-不要贴膜"><a href="#技巧四：-不要贴膜" class="headerlink" title="技巧四： 不要贴膜"></a>技巧四： 不要贴膜</h3><p>很多人有贴膜加套症，什么电子产品在手上都要贴膜加套。对与Kindle我想说放过它吧，她还是个孩子啊。给它安装一个自己喜欢的保护套有必要，皮套不仅暖手，还经摔。PU套个性独特，还可当鼠标垫。必要的时候可以盖泡面。但是贴膜真的就没必要。至于为什么，看对比图。<br><img src="http://oeqcvcrxo.bkt.clouddn.com/tiemo.jpg" alt="别贴膜"><br>上部分我用高清膜遮盖，有强烈的反光啊，我要的纸质感全被这一张膜弄没了.磨砂膜据说贴了效果也一样，稍微好一些不过会影响看书体验，变模糊了。</p>
<h3 id="技巧五：-笔记导出"><a href="#技巧五：-笔记导出" class="headerlink" title="技巧五： 笔记导出"></a>技巧五： 笔记导出</h3><p>我尝试过通过手机Kindle APP发送笔记到<code>印象笔记私人邮箱</code>的方法来将笔记导入到印象笔记中，结果是没有结果，导出失败。只能采用手动导出的方法，具体如下：</p>
<p>将Kindlel连接到电脑，进“documents”文件夹，找到“My Clippings.txt”。然后用<a href="https://www.clippings.io/" target="_blank" rel="external">Clippings</a>导入到印象笔记。具体过程问度娘。</p>
<h2 id="针对Kindle越狱现象的一些看法"><a href="#针对Kindle越狱现象的一些看法" class="headerlink" title="针对Kindle越狱现象的一些看法"></a>针对Kindle越狱现象的一些看法</h2><p>Kindle有一个反常理的地方，它居然不能自定义壁纸，而是系统自带的壁纸。于是有很多人想尽办法给自家Kindle越狱。越狱后的Kindle可以说功能多样，不仅可以换壁纸，没有做不到的只有你想不到的。有人越狱后安装计算器、小游戏。有人安装画图软件，有人把Kindle当显示屏，有人用Kindle写HelloWorld，等等。鬼知道Kindle经历了些什么。我就想问了，这些人当初买Kindle的初衷是为了啥，就为了功能多样，堪比智能平板的吗。那为啥要花这么多钱买个黑白屏，还这么卡顿的平板呢。Kindle为阅读而生，之所以买它，是要好好阅读，充实自己的啊。希望少折腾它，把时间留给书籍，留给知识吧！</p>
<h2 id="小样有话说："><a href="#小样有话说：" class="headerlink" title="小样有话说："></a>小样有话说：</h2><center style="color:green;font-weight: Bold;border:1px dotted #999">人丑就要多读书</center>

<center><div style="border: 2px solid #999;border-top:none;border-left:none;width: 20px;height:20px;transform:rotate(45deg);"></div></center><br><center style="dispaly:block;width:300px;margin:0 auto"><span style="display:inline-block;float:left;width:100px;height:10px;border-top:1px solid #999;margin-top:15px;"></span><span><a href="https://github.com/Gong-Elory" target="_blank" rel="external">龚小样</a></span><span style=" display:inline-block;float:right;width:100px;height:10px;border-top:1px solid #999;margin-top:15px;"></span></center><br><center><span style="font-size:14px;line-height:14px;margin-top:0;">2017-1-10</span></center>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在我没接触到Kindle之前，我对它是嗤之以鼻的。我认为电子书再怎么注重用户体验，它能模仿纸质书那种翻书的感觉吗?它能有纸质书那种对眼睛温和的感觉吗？我对纸质书产生的好感，或许是从小到大对它接触得多，没有看电子书的习惯。习惯翻页时纸张摩擦的声音，习惯左手上的页数慢慢增加而带来的满足与自豪，习惯在停顿的时候折叠小角来保存进度。此外，也从来没有过这样一件为看书而生的装备。&lt;br&gt;
    
    </summary>
    
      <category term="用户体验" scheme="http://ielory.com/categories/%E7%94%A8%E6%88%B7%E4%BD%93%E9%AA%8C/"/>
    
    
      <category term="Kindle" scheme="http://ielory.com/tags/Kindle/"/>
    
      <category term="用户体验" scheme="http://ielory.com/tags/%E7%94%A8%E6%88%B7%E4%BD%93%E9%AA%8C/"/>
    
      <category term="小技巧" scheme="http://ielory.com/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>百度贴吧你隐藏的动态访客真的看不见吗？</title>
    <link href="http://ielory.com/2016/12/11/%E7%99%BE%E5%BA%A6%E8%B4%B4%E5%90%A7%E4%BD%A0%E9%9A%90%E8%97%8F%E7%9A%84%E5%8A%A8%E6%80%81%E8%AE%BF%E5%AE%A2%E7%9C%9F%E7%9A%84%E7%9C%8B%E4%B8%8D%E8%A7%81%E5%90%97%EF%BC%9F/"/>
    <id>http://ielory.com/2016/12/11/百度贴吧你隐藏的动态访客真的看不见吗？/</id>
    <published>2016-12-11T03:44:49.000Z</published>
    <updated>2016-12-11T04:26:06.375Z</updated>
    
    <content type="html"><![CDATA[<p>百度贴吧你隐藏的动态访客真的看不见吗？非也，由于年久，百度贴吧一些问题不断地凸现出来，这篇文章将要讲解的是一个关乎广大贴吧用户都会在意的问题 – 信息安全。<br><a id="more"></a><br>或许是又要到年关了，程序员们都无心思查bug了。淘宝网的登录系统居然出现了随机bug（加入购物车就不断地登录，循环往复）。百度统计也在4.0版本更新后也成功的让一些常用功能失效（以我的暴脾气，肯定要到百度统计贴吧去讨个说法，或许是骂声一片，压力倍增，终于在上线不久后恢复正常）。腾讯产品我现在关注最多的就是王者荣耀了，然而光顾着挣钱了，游戏却抄的一点都不走心。拿来历史人物就用，感谢王者荣耀让我知道了花木兰是唐朝的守卫军，让我知道了荆轲是女的。咨询了一下律师，才发现高明的是用这些历史人物都不用担心版权，难道用三国演义的人物还要给罗贯中交版费吗？想来也是挺有道理。另外一个问题则是关于退赛惩罚的问题，为此专门和英雄联盟对比了一下。后者随意一个退赛轻则就是匹配队列优先级下降，让你每次匹配都要等个5分钟。重则就不用说了。然而企鹅家的亲生儿子可是赚钱的利器，如此爱用户以及用户手里的RMB的企鹅怎么可能让她亲爱的用户玩不了游戏，花不了钱呢？王者荣耀的惩罚机制我经历的最多也就只是禁赛几个小时而已。挂机成本如此之低，你能奈小学生何？不过这次的重点最终还是落到了百度的头上。</p>
<p>百度贴吧算是百度拿得出手的社交应用。然而由于产品有了一些年头，只顾去添加一些功能，却忘记梳理了原有功能的条理性和重复性。百度贴吧有隐藏自己动态的功能，当你设置了这个功能后，别人访问你的关注的贴吧，发的帖子是看不到任何东西的。相信一大批用户在早些年间已经设置了隐藏动态。</p>
<p>这样访客通过id直接访问就跳到了这个链接。</p>
<pre><code>http://tieba.baidu.com/home/achievement?un=用户ID&amp;fr=home
</code></pre><p><img src="http://oeqcvcrxo.bkt.clouddn.com/1.png" alt="百度贴吧你隐藏的动态访客真的看不见吗？图1"></p>
<p>显示如图所示，然而你的动态别人真的看不见吗？当然不是。早些年间或许真的看不到，但是粗心的百度在多次改版之后，留下的访问个人主页的入口越来越多，自己都忘记要将这些入口也设置访问权限了，于是乎就出现了这样的乌龙。我们通过下面这个入口进入你的贴吧个人主页，呈现的则是另一番景象。</p>
<pre><code>https://www.baidu.com/p/用户ID?from=tieba
</code></pre><p><img src="http://oeqcvcrxo.bkt.clouddn.com/2.png" alt="百度贴吧你隐藏的动态访客真的看不见吗？图2"><br>那么真的对于所有人都是这样的吗？于是继续做了深入调查，我写了一个爬虫（随便进入一个贴吧，获取用户ID，然后按照上述链接依次访问所有ID的个人主页抓取关注的贴吧名。），抓取成功率90%以上。结果表明，大部分的用户都被蒙骗了。</p>
<p>有人会问，谁能知道我的贴吧ID，我可是连身边人都不告诉的，然而事实证明，你的贴吧ID被知道的概率达5层。用过贴吧或者其他社交网站的都应该有过这样的经历：</p>
<pre><code>10106***@qq.com  楼主好人，楼主长命百岁

1557272**** 麻烦给我一份资料 蟹蟹
</code></pre><p>更有甚者，将自己的身份证号码，醒目都暴露在这种场合。实在是令人惊诧。（此人不点名）</p>
<p>针对贴吧权限问题一事，解决方案就是</p>
<pre><code>进入https://www.baidu.com/p/setting/privacy/tieba 重新设置权限，并点击保存。
进入https://www.baidu.com/p/setting/privacy/tieba 重新设置权限，并点击保存。
进入https://www.baidu.com/p/setting/privacy/tieba 重新设置权限，并点击保存。
</code></pre><p>那么针对信息泄露问题，想想自己暴露的隐私能不能尽量删除，避免被人利用。</p>
<p>另外我发现一个问题，我的QQ好友中，有人的爱奇艺账号也被攻破啦，并且被分享，赶紧查查看自己的这些账号是不是存在登录异常或者可疑记录。</p>
<p>因为有些情况，不得不公布联系方式，那么请妥善保管自己的隐私，谨慎发言，不要给予犯罪分子可乘之机。</p>
<hr>
<h2 id="小样有话说："><a href="#小样有话说：" class="headerlink" title="小样有话说："></a>小样有话说：</h2><center style="color:green;font-weight: Bold;border:1px dotted #999">今天就说到这里。也欢迎在文章底下评论，爆出更多的料。<br>也欢迎大家转发，让身边喜欢用贴吧的人都注意一下。</center>

<center><div style="border: 2px solid #999;border-top:none;border-left:none;width: 20px;height:20px;transform:rotate(45deg);"></div></center><br><center style="dispaly:block;width:300px;margin:0 auto"><span style="display:inline-block;float:left;width:100px;height:10px;border-top:1px solid #999;margin-top:15px;"></span><span><a href="https://github.com/Gong-Elory" target="_blank" rel="external">龚小样</a></span><span style=" display:inline-block;float:right;width:100px;height:10px;border-top:1px solid #999;margin-top:15px;"></span></center><br><center><span style="font-size:14px;line-height:14px;margin-top:0;">2016-12-11</span></center>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;百度贴吧你隐藏的动态访客真的看不见吗？非也，由于年久，百度贴吧一些问题不断地凸现出来，这篇文章将要讲解的是一个关乎广大贴吧用户都会在意的问题 – 信息安全。&lt;br&gt;
    
    </summary>
    
      <category term="用户体验" scheme="http://ielory.com/categories/%E7%94%A8%E6%88%B7%E4%BD%93%E9%AA%8C/"/>
    
    
  </entry>
  
  <entry>
    <title>JS中事件冒泡与事件捕获的定义与应用</title>
    <link href="http://ielory.com/2016/11/27/JS%E4%B8%AD%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1%E4%B8%8E%E4%BA%8B%E4%BB%B6%E6%8D%95%E8%8E%B7%E7%9A%84%E5%AE%9A%E4%B9%89%E4%B8%8E%E5%BA%94%E7%94%A8/"/>
    <id>http://ielory.com/2016/11/27/JS中事件冒泡与事件捕获的定义与应用/</id>
    <published>2016-11-27T14:02:19.000Z</published>
    <updated>2016-11-27T14:04:33.621Z</updated>
    
    <content type="html"><![CDATA[<p>事件流描述了从页面中接收事件的顺序。事件冒泡与事件捕获是两种完全不同的事件流顺序概念。分别出自IE与Netscape。<br><a id="more"></a></p>
<p>##事件冒泡<br>该事件流描述了事件开始时是有目标元素接收，然后逐级向上传播到不具体的节点（Document元素）。这是书中给的定义，晦涩难懂，我们用更形象的比喻来表述（虽然图片更直观，请容笔者偷个懒。）</p>
<p>比喻（讲个故事）：<br>天气冷了，在老家都会烤火炉。我们把事件比作烧柴火生的烟。点燃柴<code>[事件触发]</code>之后呢，烟先经过炉子<code>[当前元素]</code>冒到房子<code>[父元素]</code>里，把你熏成腊肉。然后又从房子里冒到大气中<code>[祖先元素...一直冒到Document对象结束]</code>，污染了空气。（有点可怕，哈哈！）</p>
<p>总结的说就是</p>
<blockquote>
<p>从触发事件的元素[目标元素]开始逐级向父元素-&gt;爷爷元素-&gt;太爷爷元素-&gt;猿人元素[Document对象]传播，然后终止。这就是冒泡过程.</p>
</blockquote>
<h2 id="事件捕获"><a href="#事件捕获" class="headerlink" title="事件捕获"></a>事件捕获</h2><p>该事件流描述了，当事件触发时，不具体的节点应该先收到事件，而最具体的事件最后接受事件。其用意在于事件到达预定目标时捕获它。</p>
<p>比喻（讲个故事）：<br>外面正在下着暴雨，我没有水喝。房子是破的。雨水先穿过云层，然后穿透我的破房子滴到了我的杯子里。哈哈，有水喝了。这里把水比作事件。云层相当于[Document对象……祖先元素],破房子[父元素],杯子[目标元素]。这是雨最后的归宿。</p>
<p>总结的说就是</p>
<blockquote>
<p>从猿人元素[Document对象]……-&gt;太爷爷元素-&gt;爷爷元素-&gt;父元素-&gt;目标元素传播，然后终止。这就是捕获过程.</p>
</blockquote>
<h2 id="DOM2级事件流规定"><a href="#DOM2级事件流规定" class="headerlink" title="DOM2级事件流规定"></a>DOM2级事件流规定</h2><p>为了考虑IE和Netscape的感受，DOM2级事件规定事件流包含三个阶段。事件捕获阶段-&gt;处于目标阶段-&gt;事件冒泡阶段。形成一个完美的<code>U</code>型。</p>
<h2 id="如何将事件处理程序添加到不同的阶段呢？"><a href="#如何将事件处理程序添加到不同的阶段呢？" class="headerlink" title="如何将事件处理程序添加到不同的阶段呢？"></a>如何将事件处理程序添加到不同的阶段呢？</h2><p>DOM2级事件添加事件处理程序的方法为addEventListener（）。这个方法有三个参数，分别为：事件类型，事件处理函数，以及最最最最最关键的<code>布尔值阶段选择参数</code>（这是我取得名）。<br>举个栗子：</p>
<pre><code>&lt;div id=&quot;father&quot;&gt;
    &lt;input type=&quot;button&quot; value=&quot;Click me&quot; id=&quot;myBtn&quot;/&gt;
&lt;/div&gt;
var btn = document.getElementById(&quot;myBtn&quot;);
btn.addEventListener(&quot;click&quot;,function(){
    alert(&quot;nothing&quot;);
    },false);
</code></pre><p>第三个参数，也就是我们的布尔值阶段选择参数。当其为true时，规定在<code>捕获阶段</code>调用事件处理程序。为false时，则在<code>冒泡阶段</code>调用事件处理程序.</p>
<p>上面的例子，在按钮被按下之后，触发了click事件，事件从input元素开始向上传播，看当前的元素是否有相应的事件处理程序。由于input绑定了事件处理程序，于是执行。然后向上访问div元素，看是否有事件处理程序。发现没有，于是继续向上访问document元素，发现还是没有，于是冒泡结束。</p>
<p>恩，没了。<br>没了？有人肯定要问：</p>
<blockquote>
<ul>
<li><p>问：你只说了DOM2级事件啊，DOM0呢，IE呢？不可能要求都用addEventListener方法吧?</p>
</li>
<li><p>答：我们都知道DOM0级绑定事件处理程序的方法是：<code>element.onclick = function（）{}；</code><br>没有设置阶段的参数，IE的是:<code>attachEvent(&quot;onclick&quot;,function(){});</code>也没有。首先说IE，冒泡事件流就是IE提出的概念啊，他怎么可以允许在他的浏览器中实现捕获阶段呢？这不是啪啪啪打脸吗？多以在IE中，绑定的事件都是在冒泡阶段执行的。而针对DOM0级等等，添加的事件在大部分情况下也是添加到事件流的冒泡阶段，因为这样可以最大限度的兼容各色浏览器。书上说：没什么特别需要，不建议在事件捕获阶段注册事件处理程序。</p>
</li>
</ul>
</blockquote>
<h2 id="冒泡的运用"><a href="#冒泡的运用" class="headerlink" title="冒泡的运用"></a>冒泡的运用</h2><h3 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h3><p>事件委托利用了事件冒泡的原理，只指定了一个时间处理程序，就可以管理某一类型的所有事件。<br>举个栗子：</p>
<pre><code>&lt;ul id=&quot;admin&quot;&gt;
    &lt;li id=&quot;eat&quot;&gt;eat&lt;/li&gt;
    &lt;li id=&quot;drink&quot;&gt;drink&lt;/li&gt;
    &lt;li id=&quot;sleep&quot;&gt;sleep&lt;/li&gt;
&lt;/ul&gt;
</code></pre><p>我现在想给每一个li标签注册一个click事件。这样我点击他的时候，显示在干嘛？<br>按照常规的方法：</p>
<pre><code>var eat = document.getElementById(&quot;eat&quot;);
var drink = document.getElementById(&quot;drink&quot;);
var sleep = document.getElementById(&quot;sleep&quot;);
btn.addEventListener(&quot;click&quot;,function(){
    alert(&quot;eat&quot;);
    },false);
drink.addEventListener(&quot;click&quot;,function(){
    alert(&quot;drink&quot;);
    },false); 
sleep.addEventListener(&quot;click&quot;,function(){
    alert(&quot;sleep&quot;);
    },false);
</code></pre><p>我要抱怨了，虽然是复制粘贴，但是真的好麻烦啊。三个都这么麻烦，要是有100个呢？我得摔电脑了。<br>用事件委托法：</p>
<pre><code>var admin = document.getElementById(&quot;admin&quot;);
btn.addEventListener(&quot;click&quot;,function(event){
    switch(event.target.id){
        case &quot;eat&quot;:
            alert(&quot;eat&quot;);
            break;
        case &quot;drink&quot;:
            alert(&quot;drink&quot;);
            break;
        case &quot;sleep&quot;:
            alert(&quot;sleep&quot;);
            break;
    }
},false);
</code></pre><p>我们可以看到，此时事件处理函数不是绑到li元素上面的，而是其父元素ul上。由于是冒泡阶段处理。当我们点击li时，先访问li有没有绑定事件处理函数，发现没有，于是向上访问ul，发现有，这时处理完上面的事件程序内的事情后，继续冒泡知道document终止。</p>
<h3 id="事件委托优点"><a href="#事件委托优点" class="headerlink" title="事件委托优点"></a>事件委托优点</h3><blockquote>
<ul>
<li>代码消耗低，尤其是需要大批量绑定click事件时体现出来的优越性。</li>
<li>事件处理程序数量会直接影响整个页面的整体运行性能。函数也是对象，对象需要占用内存，绑定的事件处理函数越多，占据的内存越大，这样可能会延迟整个页面的交互。</li>
<li>动态添加元素时，不需要单独为他绑定事件处理程序。用上面的例子来说：添加一个li后，不需要单独为他绑定，只需在现有的程序中添加相应判断机制即可。同样，删除某元素时，不用担心空事件处理程序占用内存的问题。</li>
</ul>
</blockquote>
<h2 id="如何阻止冒泡"><a href="#如何阻止冒泡" class="headerlink" title="如何阻止冒泡"></a>如何阻止冒泡</h2><p>任何事物都有两面性，有些时候我们并不希望冒泡。那该如何办？<br>上一篇博文<a href="http://gelory.me/2016/11/27/%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1%E4%B8%AD%E6%98%93%E6%B7%B7%E6%B7%86%E7%9A%84%E5%AE%9A%E4%B9%89%E4%B8%8E%E8%BF%90%E7%94%A8/" target="_blank" rel="external">事件对象中易混淆的定义与运用</a>中讲到事件对象event。该对象中有一个方法可以阻止冒泡。它是stopPropagation（）。当然，哪里都少不了IE这个特殊分子。他的event对象中有这样一个属性代替上面的方法起到相同的作用。它是cancelBubble。默认false，表示允许事件冒泡。</p>
<p>当然为了兼容所有大部分的浏览器，建议这样重写阻止冒泡方法：</p>
<pre><code>function（event）{
    if(event.stopPropagation())
    {
        event.stopPropagation();
    }else{
        event.cancelBubble = true;
    }
}
</code></pre><center><div style="border: 2px solid #999;border-top:none;border-left:none;width: 20px;height:20px;transform:rotate(45deg);"></div></center><br><center style="dispaly:block;width:300px;margin:0 auto"><span style="display:inline-block;float:left;width:100px;height:10px;border-top:1px solid #999;margin-top:15px;"></span><span><a href="https://github.com/Gong-Elory" target="_blank" rel="external">龚小样</a></span><span style=" display:inline-block;float:right;width:100px;height:10px;border-top:1px solid #999;margin-top:15px;"></span></center><br><center><span style="font-size:14px;line-height:14px;margin-top:0;">2016-11-27</span></center>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;事件流描述了从页面中接收事件的顺序。事件冒泡与事件捕获是两种完全不同的事件流顺序概念。分别出自IE与Netscape。&lt;br&gt;
    
    </summary>
    
      <category term="JS" scheme="http://ielory.com/categories/JS/"/>
    
    
      <category term="JS" scheme="http://ielory.com/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>事件对象中易混淆的定义与运用</title>
    <link href="http://ielory.com/2016/11/27/%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1%E4%B8%AD%E6%98%93%E6%B7%B7%E6%B7%86%E7%9A%84%E5%AE%9A%E4%B9%89%E4%B8%8E%E8%BF%90%E7%94%A8/"/>
    <id>http://ielory.com/2016/11/27/事件对象中易混淆的定义与运用/</id>
    <published>2016-11-27T11:32:26.000Z</published>
    <updated>2016-11-27T14:09:14.160Z</updated>
    
    <content type="html"><![CDATA[<p>在学习js，jQuery的过程中遇到了几种标书对象的写法，他们看似作用相同，但其实还是有那么一些差异的。<br><a id="more"></a><br>在学习js，jQuery的过程中遇到了几种标书对象的写法，他们看似作用相同，但其实还是有那么一些差异的。</p>
<p>在指定时间处理程序的时候，我们常常会遇见这种形式</p>
<pre><code>&lt;div id=&quot;father&quot;&gt;
    &lt;input type=&quot;button&quot; value=&quot;Click me&quot; id=&quot;myBtn&quot;/&gt;
&lt;/div&gt;

var btn = document.getElementById(&quot;myBtn&quot;);
btn.onclick = function(event){
//注意下面这条语句中的event.target
    alert(event.target.id);
}
</code></pre><p>或者是这种：</p>
<pre><code>var btn = document.getElementById(&quot;myBtn&quot;);
btn.onclick = function(event){
//注意下面这条语句中的this
    alert(this.id);
}
</code></pre><p>又或者是在jquery中看见这种:</p>
<pre><code>$(&quot;#myBtn&quot;).click(function(){
//注意下面这条语句中的$(this)
    alert($(this).id);
});
</code></pre><p>无论用上面的哪种方式去点击，最后弹出的对话框中出现的都是—–“myBtn”<br>是不是因此可以下定论，他们就是指的同一样东西呢？<br>不一定</p>
<p>使用event.target首先得明白什么是事件对象</p>
<h2 id="事件对象定义"><a href="#事件对象定义" class="headerlink" title="事件对象定义"></a>事件对象定义</h2><p>在触发DOM上的某个事件后，会产生一个事件对象event（名字可以随便取），无论是采用什么事件处理方式都会向处理程序传入该对象。这个对象包含着所有与事件有关的信息。譬如导致事件的元素，事件类型等。</p>
<h3 id="事件处理程序种类"><a href="#事件处理程序种类" class="headerlink" title="事件处理程序种类"></a>事件处理程序种类</h3><p>HTML事件处理程序：</p>
<pre><code>&lt;input type=&quot;button&quot; value=&quot;Click me&quot; id=&quot;myBtn&quot; onclick=&quot;alert(event.type)&quot;/&gt;
</code></pre><p>DOM0级事件处理程序：</p>
<pre><code>btn.onclick = function(){
//do something
}
</code></pre><p>DOM2级事件处理程序:</p>
<pre><code>btn.addEventListener（&quot;click&quot;,function(){
//do something
});
</code></pre><p>IE事件处理程序:</p>
<pre><code>btn.attachEvent(&quot;onclick&quot;,function(){
    //do something
});
</code></pre><h2 id="event-target-this-this-的区别与联系"><a href="#event-target-this-this-的区别与联系" class="headerlink" title="event.target,this,$(this)的区别与联系"></a>event.target,this,$(this)的区别与联系</h2><h3 id="event-target"><a href="#event-target" class="headerlink" title="event.target"></a>event.target</h3><p>前面说到事件对象会包含所有关于事件有关的信息。而target正是其中的一项。target属性表示事件的目标元素。所以，上例中event.target指的就是input元素。常见的还有type，代表事件类型。上例中的event.type为click。还有一个与target类似的属性currentTarget。指的是其事件处理程序当前正在处理事件的那个元素。</p>
<h3 id="target与currentTarget"><a href="#target与currentTarget" class="headerlink" title="target与currentTarget"></a>target与currentTarget</h3><p>有人会感到疑惑，这两个不就是一样东西吗？为什么要用两个属性表示。常言道：存在即合理。其实这两个并不是指同一样东西。</p>
<blockquote>
<p>target：事件的实际目标。<br>currentTarget：正在处理事件的元素，我们可以说谁绑定了事件，这个属性就指向谁。</p>
</blockquote>
<p>重新搬回这个例子：</p>
<pre><code>&lt;div id=&quot;father&quot;&gt;
    &lt;input type=&quot;button&quot; value=&quot;Click me&quot; id=&quot;myBtn&quot;/&gt;
&lt;/div&gt;   
</code></pre><p>我们设置这样的处理程序</p>
<pre><code>var fath = document.getElementById(&quot;father&quot;);
fath.onclick = function(event){
//alert(event.currentTarget.id); 显示为 father。div元素的id
alert(event.Target.id); //显示为 myBtn。input元素的id
}
</code></pre><p>这回我们把单击事件处理程序绑定在input的父元素div元素上。此时单击按钮，由于事件冒泡的原因（关于事件冒泡，这篇文章有介绍：<a href="http://gelory.me/2016/11/27/JS%E4%B8%AD%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1%E4%B8%8E%E4%BA%8B%E4%BB%B6%E6%8D%95%E8%8E%B7%E7%9A%84%E5%AE%9A%E4%B9%89%E4%B8%8E%E5%BA%94%E7%94%A8/" target="_blank" rel="external">JS中事件冒泡与事件捕获的定义与应用</a>），会触发父元素的事件处理程序。可以明显的看到target和currentTarget指向的元素不是同一个。</p>
<p>前者指向事件实际目标，这里是input实际出发的click事件，所以target指向他。而后者是处理事件的元素。因为事件处理程序绑定在div元素上，所以currentTarget指向div元素。实际上，还有一种表示法也是始终和currentTarget的值相等的，也就是—this。this很熟悉，我们对他的认识是他指的是调用当前函数的对象。用在这里也合乎情理。</p>
<h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><p>上节说道，currentTarget的值和this始终相等，指的是正在处理事件的元素，也就是我们绑定事件处理程序的那个元素。<br>因此 event.target与this的值不总是相等的。除非把事件处理程序绑定在实际触发事件的元素上。如上例：</p>
<pre><code>var btn = document.getElementById(&quot;myBtn&quot;);
btn.onclick = function(event){
//注意下面这条语句中的event.target
    alert(event.target.id);
}
</code></pre><p>input元素是实际出发click事件的元素，儿我们也将处理程序绑定在input元素上。因此，此时event.target与this相等。</p>
<h3 id="this-与this的区别"><a href="#this-与this的区别" class="headerlink" title="$(this)与this的区别"></a>$(this)与this的区别</h3><p>$(this)指的是jquery对象，而this指代的是DOM对象。就这么简单。需要注意的是，因为对象不同，他们拥有的属性不同，尽管他们都是指向某一元素。</p>
<blockquote>
<p>世界上总有一些特立独行的人，也有这样特例独行的浏览器，他就是IE。</p>
</blockquote>
<h2 id="IE中的事件对象"><a href="#IE中的事件对象" class="headerlink" title="IE中的事件对象"></a>IE中的事件对象</h2><p>要访问IE中的事件对象，取决于指定事件处理程序的方法。<br>使用DOM0级方法，此时event对象是作为window对象的属性存在的，因此访问event就这样做。</p>
<pre><code>btn.onclick = function(){
    var event = window.event;
    alert(event.target.id);
}
</code></pre><p>当然啦，IE也有它自己的事件处理程序：</p>
<pre><code>var btn = document.getElementById(&quot;myBtn&quot;);
btn.attachEvent(&quot;onclick&quot;,function(event){
    //do something
});
</code></pre><p>该方法与DOM0级的方法的区别在于事件处理程序的作用域。前者会在全局作用域下运行，后者在所属元素的作用域下运行。因此，前者的this指向的是window对象。</p>
<h3 id="IE中替代target的属性"><a href="#IE中替代target的属性" class="headerlink" title="IE中替代target的属性"></a>IE中替代target的属性</h3><p>前面说到，在IE中event是作为window的属性存在的，那么要像访问事件的目标。可以通过srcElement这个属性访问。</p>
<center><div style="border: 2px solid #999;border-top:none;border-left:none;width: 20px;height:20px;transform:rotate(45deg);"></div></center><br><center style="dispaly:block;width:300px;margin:0 auto"><span style="display:inline-block;float:left;width:100px;height:10px;border-top:1px solid #999;margin-top:15px;"></span><span><a href="https://github.com/Gong-Elory" target="_blank" rel="external">龚小样</a></span><span style=" display:inline-block;float:right;width:100px;height:10px;border-top:1px solid #999;margin-top:15px;"></span></center><br><center><span style="font-size:14px;line-height:14px;margin-top:0;">2016-11-27</span></center>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在学习js，jQuery的过程中遇到了几种标书对象的写法，他们看似作用相同，但其实还是有那么一些差异的。&lt;br&gt;
    
    </summary>
    
      <category term="JS" scheme="http://ielory.com/categories/JS/"/>
    
    
      <category term="JS" scheme="http://ielory.com/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>JS闭包</title>
    <link href="http://ielory.com/2016/11/18/JS%E9%97%AD%E5%8C%85/"/>
    <id>http://ielory.com/2016/11/18/JS闭包/</id>
    <published>2016-11-18T10:15:29.000Z</published>
    <updated>2016-11-18T12:26:53.725Z</updated>
    
    <content type="html"><![CDATA[<p>介绍闭包相关知识。<br><a id="more"></a></p>
<h2 id="闭包的定义"><a href="#闭包的定义" class="headerlink" title="闭包的定义"></a>闭包的定义</h2><p><strong>闭包是</strong>指有权访问另一个函数作用域中的变量的<strong>函数</strong>。我们常常通过在一个函数内部创建另外一个函数来形成闭包。</p>
<h2 id="作用域以及作用域链的回顾"><a href="#作用域以及作用域链的回顾" class="headerlink" title="作用域以及作用域链的回顾"></a>作用域以及作用域链的回顾</h2><p><a href="http://gelory.me/2016/11/06/JS%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83%E5%8F%8A%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84%E7%90%86%E8%A7%A3/" target="_blank" rel="external">JS执行环境及作用域的理解</a>这篇文章对这些名词做了很好的解释，但是如果不代入使用环境的话，总觉得云里雾里，似懂非懂的样子。</p>
<p>当一个函数被调用的时候，就会创建一个<code>执行环境</code>（执行环境定义了变量和函数有权访问其他数据）以及相对应的<code>作用域链</code>（规定访问变量和函数的顺序）。然后使用arguments和其他命名参数来初始化函数的活动对象。</p>
<h2 id="变量对象与活动对象的区别与联系"><a href="#变量对象与活动对象的区别与联系" class="headerlink" title="变量对象与活动对象的区别与联系"></a>变量对象与活动对象的区别与联系</h2><p>其实变量对象与活动对象的关系是包含与被包含的关系。也就是说活动对象是变量对象的一部分。<br>活动对象正如其名，活动，表示一种状态，也可以称为活动的变量对象，其实活动这个名词也是翻译过来的。英文名叫<code>Activation Object</code>，意思是激活，我们也可以理解为正在用的意思。<br>用例子来解释：</p>
<pre><code>var a = 1;
function func(){
    var b =2;
    return a+b;
}
alert(func());
</code></pre><p>我们在全局环境下定义了变量a和函数func。当我们打开浏览器时，全局环境的执行环境就存在了。此时的变量对象包括a,func.<br><strong>在func函数创建之初</strong>，会预先创建一个包含全局变量对象的作用域链（scope chain），这个作用域链被保存在函数对象的scope属性中。<br><strong>当我们调用函数func时</strong>，会创建func的执行环境。然后复制scope属性中的对象（此时只有全局变量对象），构建执行环境的作用域链，之后把pub函数中的变量对象（包含this，arguments，b）放入执行环境中，该对象被推入到作用域链的前端。此时，执行环境的作用域链（本质是一个指针列表）包含两个变量对象（全局变量对象，pub函数的变量对象），而func函数的变量对象也就是活动对象。<br>我们可以说活动对象就是当前正在被执行或者被引用的变量对象。</p>
<h2 id="闭包案例解析"><a href="#闭包案例解析" class="headerlink" title="闭包案例解析"></a>闭包案例解析</h2><pre><code>var a = 1;
function func(){
    var b =2;
    return function(){
    alert(a+b);
}
var sonfunc = func();//创建函数
sonfunc();//调用函数
</code></pre><p>在一个函数（本例中的func）内部定义另外一个函数（本例中返回的函数），这就是闭包的常见形式.<br>当执行</p>
<pre><code>var sonfunc = func();//创建函数
</code></pre><p>这条语句时,引用了func函数，此时func函数的变量对象被称为活动对象。包括（this，arguments，b，内部function）。<br>当执行</p>
<pre><code>sonfunc();//调用函数
</code></pre><p>这条语句时，sonfunc（闭包）的变量对象被添加到其作用域链的最前端，其作用域链将包含本地活动对象（this，arguments），func活动对象（this，arguments，b，内部function）以及全局变量对象。</p>
<p>细心的人可能会发现：<br>此时执行的时函数sonfunc，而不是func，按照你刚才对活动对象的定义，<strong>活动对象就是当前正在被执行或者被引用的变量对象。</strong>那么为什么……<br>看到这里是不是恍然大悟，<strong>被引用</strong>，<strong>被引用</strong>，<strong>被引用</strong>，重要的事说三遍。没错，之所以把此时func函数的变量对象也称之为活动对象，就是因为他符合活动对象定义的第二个条件：被引用。</p>
<p>func函数执行完后，作用域链会被立即销毁，但是活动对象任然留在内存中，原因是sonfunc函数依旧在引用变量b。直到sonfunc被销毁后，func的活动对象才会被销毁。</p>
<h2 id="闭包优点"><a href="#闭包优点" class="headerlink" title="闭包优点"></a>闭包优点</h2><p>普通的函数执行完毕后，其活动对象就会被销毁，仅有全局变量被保存在内存中，但是如果包含闭包则不一样，他需要等闭包被销毁后，其活动对象才会被销毁。</p>
<h2 id="闭包缺点"><a href="#闭包缺点" class="headerlink" title="闭包缺点"></a>闭包缺点</h2><p>由于闭包会携带包含它的函数的作用域，因此会比其他函数更占用内存。</p>
<h2 id="闭包副作用案例分析"><a href="#闭包副作用案例分析" class="headerlink" title="闭包副作用案例分析"></a>闭包副作用案例分析</h2><pre><code>function cFunc(){
    var arr = new Array();
    for (var i =0 ; i&lt;10 ;i++)
    {
        arr[i] = function()
        {
            return i;
        }
    }
    return arr;
}
</code></pre><p>该函数本意是让每个数组元素返回自己的索引值。但是实际上背个数组元素的值都是10.<br>原因就是因为每个闭包引用的变量i是同一个变量对象。for执行完后,i的值为10，所以同步到每一个引用，i都是10，因此每个元素的值都是10.</p>
<p>让函数符合预期的改进方法</p>
<pre><code>function cFunc(){
    var arr = new Array();
    for (var i =0 ; i&lt;10 ;i++)
    {
        arr[i] = function(num)
        {
           //return num; 直接返回参数的方式
           return function(){
            return num;
            }//用闭包的方式
        }(i);//立即执行匿名函数的写法
    }
    return arr;
}
</code></pre><blockquote>
<p>闭包可以访问外部函数中的变量，但是只能取得外部函数变量的最终值。</p>
</blockquote>
<h2 id="匿名函数与闭包"><a href="#匿名函数与闭包" class="headerlink" title="匿名函数与闭包"></a>匿名函数与闭包</h2><p>上一节提到了匿名函数，书上说有很多开发人员总是搞不清匿名函数与闭包的区别。这就尴尬了，在我看来，他们俩最大的共同点：<code>他们都是函数</code>。然后没了。</p>
<h3 id="匿名函数定义"><a href="#匿名函数定义" class="headerlink" title="匿名函数定义"></a>匿名函数定义</h3><p>function关键字后没有标识符的函数，就是匿名函数（拉姆达函数）。简而言之就是没有函数名。</p>
<h3 id="匿名函数与闭包的联系"><a href="#匿名函数与闭包的联系" class="headerlink" title="匿名函数与闭包的联系"></a>匿名函数与闭包的联系</h3><p>我们经常用匿名函数去创建闭包。</p>
<h3 id="匿名函数的this对象"><a href="#匿名函数的this对象" class="headerlink" title="匿名函数的this对象"></a>匿名函数的this对象</h3><p>匿名函数的执行对象具有全局性，因此this指向window。</p>
<h2 id="内存泄露问题"><a href="#内存泄露问题" class="headerlink" title="内存泄露问题"></a>内存泄露问题</h2><p>IE9之前版本对JS与DOM对象使用不同的垃圾收集方法，因此闭包会产生一些问题。</p>
<pre><code>function test(){
    var a = document.getElementById(&apos;lala&apos;);
    a.onclick = function(){
        alert(a.id);
        //此处形成了循环引用。a对象的click属性引用了function这个函数，而这个函数又引用了a对象的id属性
    }
}
test（）；
</code></pre><p>a的引用次数不止一次，因此a会永远占据内存，不会被回收。<br>解决方案</p>
<pre><code>function test(){
    var a = document.getElementById(&apos;lala&apos;);
    var id = a.id;
    a.onclick = function(){
        alert(id);
    }
}
test（）；
</code></pre><p>此时，消除了循环引用，但是a依旧无法被回收。因为闭包的存在，变量a依旧是闭包可引用的活动对象。即使不引用a，a也不能释放内存，此外DOM对象也保存一个引用，因此设置a为null，可以清除DOM对象所占的内存。闭包执行完后，活动对象被销毁，此时a也就释放了内存。（这段话如果有问题的话，请评论）</p>
<h2 id="为什么JS中会有闭包的存在呢？"><a href="#为什么JS中会有闭包的存在呢？" class="headerlink" title="为什么JS中会有闭包的存在呢？"></a>为什么JS中会有闭包的存在呢？</h2><p>我认为是为了解决全局变量滥用的问题。全局变量正如其名，存在的意义应该是很多函数都会用到的，但是为了满足一个函数某种特殊的需求（譬如想要在某个函数中多次利用已经计算的变量）去声明全局变量实在是大材小用。此外，全局变量所占的内存只有在退出浏览器后才得以释放，这样就会发生内存泄漏。<br>闭包应运而生，既满足了需求，将这个变量保存在外部函数内，可以利用已经计算的变量，此外，等闭包执行完后，该变量内存就会释放。一举两得。</p>
<blockquote>
<p>当一个函数中的变量或者函数能够访问另外一个函数作用域中的变量或者函数时，就产生了闭包。</p>
</blockquote>
<center><div style="border: 2px solid #999;border-top:none;border-left:none;width: 20px;height:20px;transform:rotate(45deg);"></div></center><br><center style="dispaly:block;width:300px;margin:0 auto"><span style="display:inline-block;float:left;width:100px;height:10px;border-top:1px solid #999;margin-top:15px;"></span><span><a href="https://github.com/Gong-Elory" target="_blank" rel="external">龚小样</a></span><span style=" display:inline-block;float:right;width:100px;height:10px;border-top:1px solid #999;margin-top:15px;"></span></center><br><center><span style="font-size:14px;line-height:14px;margin-top:0;">2016-11-18</span></center>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;介绍闭包相关知识。&lt;br&gt;
    
    </summary>
    
      <category term="JS" scheme="http://ielory.com/categories/JS/"/>
    
    
  </entry>
  
  <entry>
    <title>JS中实现继承的方法</title>
    <link href="http://ielory.com/2016/11/17/JS%E4%B8%AD%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>http://ielory.com/2016/11/17/JS中实现继承的方法/</id>
    <published>2016-11-17T08:16:49.000Z</published>
    <updated>2016-11-19T01:21:16.657Z</updated>
    
    <content type="html"><![CDATA[<p>总结继承方法，并且有针对性的分析一下优缺点。由于讲继承，为了便于理解，采用父类这种叫法而不是超类。<br><a id="more"></a></p>
<h2 id="方法一：原型链法"><a href="#方法一：原型链法" class="headerlink" title="方法一：原型链法"></a>方法一：原型链法</h2><p>利用原型让一个引用类型继承另外一个引用类型的属性和方法。<br>基本模式：</p>
<pre><code>function Imtree()
{
    this.tree = true;
}

Imtree.prototype.getTreeValue = function()
{
    return this.tree;
}

function Imleaf()
{
    this.leaf = false;
}

Imleaf.prototype = new Imtree();//这一步实现继承

Imleaf.prototype.getLeaf = function()
{
    return this.leaf;
}

var test = new Imleaf();
test.leaf = false;
test.getLeaf() = false;
test.tree = true;//访问父类属性
test.getTreeValue = true;//访问父类方法
</code></pre><blockquote>
<p>本质就是把父类的实例赋值给子类的原型，其实就是相当于子类原型指向了父类原型。参考实例指向原型。</p>
</blockquote>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><blockquote>
<ul>
<li>包含引用类型值的属性会被共享，如果子类的多个实例访问父类原型中某引用类型值属性的话，只要该属性值被改变，所有子类实例访问到的该属性都会同步变化。</li>
</ul>
</blockquote>
<h3 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h3><pre><code>function Imtree()
{
    this.colors = [&quot;yellow&quot;,&quot;green&quot;,&quot;gray&quot;];
}

function Imleaf(){}
Imleaf.prototype = new Imtree();
var a = new Imleaf();
a.colors.push(&quot;black&quot;);
alert(a.colors);// &quot;yellow&quot;,&quot;green&quot;,&quot;gray&quot;,&quot;black&quot;
var b = new Imleaf();
//注意，此时b访问父类的colors属性，返回的也是四个元素，说明已经同步了。
alert(b.colors);// &quot;yellow&quot;,&quot;green&quot;,&quot;gray&quot;,&quot;black&quot;
</code></pre><p>如果这正是你想要的形态，那无话可说。</p>
<blockquote>
<ul>
<li>在创建子类型的实例时，不能向父类的构造函数中传递参数</li>
</ul>
</blockquote>
<h2 id="方法二-借用构造函数法（伪造对象-经典继承）"><a href="#方法二-借用构造函数法（伪造对象-经典继承）" class="headerlink" title="方法二 借用构造函数法（伪造对象/经典继承）"></a>方法二 借用构造函数法（伪造对象/经典继承）</h2><p>在子类构造函数的内部调用父类（超类）构造函数。</p>
<pre><code>function Imtree（）
{
    this.colors = [&quot;yellow&quot;,&quot;green&quot;,&quot;gray&quot;];
}

function Imleaf()
{
    Imtree.call(this);//此时继承了Imtree类
}

var a =new Imleaf();
a.colors.push(&quot;black&quot;);
alert(a.colors);// &quot;yellow&quot;,&quot;green&quot;,&quot;gray&quot;,&quot;black&quot;
var b = new Imleaf();
alert(b.colors);// &quot;yellow&quot;,&quot;green&quot;,&quot;gray&quot;
</code></pre><h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><p>构造函数模式的通病，方法无法复用。</p>
<h2 id="方法三-组合继承法（伪经典继承）"><a href="#方法三-组合继承法（伪经典继承）" class="headerlink" title="方法三 组合继承法（伪经典继承）"></a>方法三 组合继承法（伪经典继承）</h2><p>使用原型链实现对原型属性和方法的继承，通过借用构造函数法来实现对实例属性的继承</p>
<pre><code>function Imtree(name)
{
    this.tree = name;
    this.colors = [&quot;yellow&quot;,&quot;green&quot;,&quot;gray&quot;];
}

Imtree.prototype.sayTreeName()
{
    alert(this.tree);
}

function Imleaf(name,age) 
{
    Imtree.call(this,name); //第二次调用  
    this.age = age;
}

Imleaf.prototype = new Imtree();//第一次调用
Imleaf.prototype.constructor = Imleaf;
Imleaf.prototype.sayAge = function(){
    alert(this.age);
}

var a = new Imleaf(&quot;aTree&quot;,10);
a.colors.push(&quot;black&quot;);
alert(a.colors);//&quot;yellow&quot;,&quot;green&quot;,&quot;gray&quot;,&quot;black&quot;
alert(a.sayAge());//10
alert(a.sayName));//&quot;aTree&quot;

var b = new Imleaf(&quot;bTree&quot;,50);
alert(b.colors);//&quot;yellow&quot;,&quot;green&quot;,&quot;gray&quot;
alert(a.sayAge());//50
alert(a.sayName));//&quot;bTree&quot;
</code></pre><p>该方法结合了方法一和二的优点，避开了他们的缺点，使用的很广泛。</p>
<h3 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h3><p>调用两次父类构造函数。一次是在创建子类原型时，调用构造函数，将实例赋给子类原型。另外一次是在子类构造函数内。</p>
<h2 id="方法四-原型式继承"><a href="#方法四-原型式继承" class="headerlink" title="方法四 原型式继承"></a>方法四 原型式继承</h2><pre><code>function object(o){
    function F（）{}
    F.prototype = o ;
    return new F();
    }

var person = {
    name: &quot;aa&quot;,
    frineds:&quot;ab&quot;,&quot;ac&quot;
}

var a = object(person);
a.friends.push(&quot;lll&quot;);
alert(a.friends);//&quot;ab&quot;,&quot;ac&quot;,&quot;lll&quot;
var b = object(person);
b.friends.push(&quot;nnn&quot;);
alert(b.friends);//&quot;ab&quot;,&quot;ac&quot;,&quot;lll&quot;,&quot;nnn&quot;
</code></pre><p>该方法的规范方法：Object.create()<br>Object.create()拥有两个参数，第一个参数为（第二声）为（第四声）新对象定义额外属性的对象，第二个参数为自定义属性。</p>
<pre><code>var person = {
        name: &quot;aa&quot;,
        frineds:&quot;ab&quot;,&quot;ac&quot;
    }

var a = object(person,{name:{value:&quot;zz&quot;}});
alert(a.name);//&quot;zz&quot;
</code></pre><p>支持该方法的有IE9+,FF4+,Safari5+，Opera12+和Chrome。</p>
<h2 id="方法五-寄生式继承"><a href="#方法五-寄生式继承" class="headerlink" title="方法五 寄生式继承"></a>方法五 寄生式继承</h2><p>创建一个封闭继承过程的函数，与方法四类似。<br>function createAnother(a)<br>{<br>    var clone = object(a);//不一定是object方法，任何能返回新对象的方法都可以<br>    clone.sayHi = function（）<br>    {<br>        alert(“Hi”);<br>    }<br>    return clone;<br>}</p>
<h2 id="方法六-寄生组合式继承"><a href="#方法六-寄生组合式继承" class="headerlink" title="方法六 寄生组合式继承"></a>方法六 寄生组合式继承</h2><p>通过借用构造函数来继承属性，通过原型链的混合形式来继承方法。基本思路为：不必为了指定子类的原型而调用父类的构造函数。而是创建一个父类的副本。</p>
<pre><code>function inheritPrototype(mtree,mleaf)
{
    var prototype = object(mtree.prototype);//创建父类原型的副本
    prototype.constructor = mleaf;//为副本添加constructor属性
    mleaf.prototype = prototype; //实现继承
}

 function Imtree(name)
{
    this.tree = name;
    this.colors = [&quot;yellow&quot;,&quot;green&quot;,&quot;gray&quot;];
}

Imtree.prototype.sayTreeName()
{
    alert(this.tree);
}

function Imleaf(name,age) 
{
    Imtree.call(this,name); 
    this.age = age;
}
function inheritPrototype(Imtree,Imleaf);
Imleaf.prototype.sayAge = function(){
    alert(this.age);
}
</code></pre><p>此方法是实现类型继承的最有效方法。只调用了一次构造函数。</p>
<h2 id="小样有话说："><a href="#小样有话说：" class="headerlink" title="小样有话说："></a>小样有话说：</h2><center style="color:green;font-weight: Bold;border:1px dotted #999">JS的学习继续。</center>

<center><div style="border: 2px solid #999;border-top:none;border-left:none;width: 20px;height:20px;transform:rotate(45deg);"></div></center><br><center style="dispaly:block;width:300px;margin:0 auto"><span style="display:inline-block;float:left;width:100px;height:10px;border-top:1px solid #999;margin-top:15px;"></span><span><a href="https://github.com/Gong-Elory" target="_blank" rel="external">龚小样</a></span><span style=" display:inline-block;float:right;width:100px;height:10px;border-top:1px solid #999;margin-top:15px;"></span></center><br><center><span style="font-size:14px;line-height:14px;margin-top:0;">2016-11-17</span></center>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;总结继承方法，并且有针对性的分析一下优缺点。由于讲继承，为了便于理解，采用父类这种叫法而不是超类。&lt;br&gt;
    
    </summary>
    
      <category term="JS" scheme="http://ielory.com/categories/JS/"/>
    
    
      <category term="JS" scheme="http://ielory.com/tags/JS/"/>
    
  </entry>
  
</feed>
