<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>龚小样儿</title>
  <subtitle>写一些小事，做一些大事</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://gelory.me/"/>
  <updated>2016-11-11T07:47:25.626Z</updated>
  <id>http://gelory.me/</id>
  
  <author>
    <name>龚志强</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JS对象创建方法</title>
    <link href="http://gelory.me/2016/11/11/JS%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E6%96%B9%E6%B3%95/"/>
    <id>http://gelory.me/2016/11/11/JS对象创建方法/</id>
    <published>2016-11-11T07:31:28.000Z</published>
    <updated>2016-11-11T07:47:25.626Z</updated>
    
    <content type="html"><![CDATA[<p>对JS创建对象的方法进行总结<br><a id="more"></a></p>
<h2 id="对象的定义"><a href="#对象的定义" class="headerlink" title="对象的定义"></a>对象的定义</h2><blockquote>
<p>在JS中，对象是拥有属性和方法的数据。</p>
</blockquote>
<h2 id="如何创建对象"><a href="#如何创建对象" class="headerlink" title="如何创建对象"></a>如何创建对象</h2><h3 id="Object实例法"><a href="#Object实例法" class="headerlink" title="Object实例法"></a>Object实例法</h3><p>创建自定义对象最简单的方式是创建一个Object实例，然后添加属性，方法。</p>
<pre><code>var a = new Object();
a.name = &quot;elory&quot;;
a.age = &quot;100&quot;;
a.gender = function()
{
    alert(&quot;no sex&quot;);
}
</code></pre><h3 id="对象字面量法"><a href="#对象字面量法" class="headerlink" title="对象字面量法"></a>对象字面量法</h3><p>其次是使用对象字面量的方法来创建。字面量是一种表示值的记法。</p>
<pre><code>var a = {
    name: &quot;elory&quot;,//注意，这里是逗号
    age: 100,
    gender: function(){
    alert(nothing);
    }
}
</code></pre><p>我们发现，这样建对象有一个好处，就是不用重复的写实例对象名</p>
<h3 id="以上两种方式的缺点"><a href="#以上两种方式的缺点" class="headerlink" title="以上两种方式的缺点"></a>以上两种方式的缺点</h3><p>假如我们要创建两个对象，那么以上两种方法就会产生很多重复的代码。譬如又要写一遍age，name，and so on。</p>
<h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>所谓工厂模式，就是给一套流程，可以重复创建多个对象的方法。正规的说：该模式抽象创建对象的具体过程，用函数来封装以特定接口来创建对象。</p>
<pre><code>function createObj(name,age,gender)
{
    var aaa = new Object();
    aaa.name = name;
    aaa.age = age;
    aaa.gender = gender；
    return a;
}
</code></pre><p>比如我想在要创建两个对象，并分别给其属性赋值，就可以酱。</p>
<pre><code>var b = createObj(&quot;imb&quot;,10,function(){alert(&quot;no sex&quot;);});
var c = createObj(&quot;imc&quot;,60,function(){alert(&quot;man&quot;);});
</code></pre><h4 id="工厂模式的优缺点"><a href="#工厂模式的优缺点" class="headerlink" title="工厂模式的优缺点"></a>工厂模式的优缺点</h4><p>优点：可以创建相似的多个对象。<br>缺点：无法知道创建对象的类型。</p>
<h3 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h3><p>先甩代码：</p>
<pre><code>function Elory(name,age,gender)
{
    this.name = name;
    this.age = age;
    this.gender = gender;
}
var b = new Elory(&quot;imb&quot;,10,function(){alert(&quot;no sex&quot;);});
var c = new Elory(&quot;imc&quot;,60,function(){alert(&quot;man&quot;);});
</code></pre><p>一看代码，这不就是普通函数吗？<br>首先，注意函数的名称，<code>首字母是大写的</code>，这是按照惯例来区别于非构造函数的。<br>此时要创建对象实例，需要使用new操作符。<br>我们可以用instanceof来检测对象类型。</p>
<p><code>此方法就解决了工厂模式不能识别对象类型的问题。</code></p>
<h4 id="构造函数与普通函数的区别"><a href="#构造函数与普通函数的区别" class="headerlink" title="构造函数与普通函数的区别"></a>构造函数与普通函数的区别</h4><p>之前说到的构造函数首字母大写只是人为的规定，便于识别构造函数和普通函数的。他们最大的不同在于他们的调用方式。<br>只要通过new操作符来调用，就可以当做是构造函数。</p>
<h4 id="构造函数的缺点"><a href="#构造函数的缺点" class="headerlink" title="构造函数的缺点"></a>构造函数的缺点</h4><p>明显的问题就是构造函数内的方法都会在实例中重新创建，比如之前我们创建的两个Elory实例，他们中的function实例也是不同的。也就是说通过构造函数创建对象会产生不同的作用域链。</p>
<pre><code>alert(b.gender == c.gender); //返回false；
</code></pre><p>那这样创建这么多function实例有必要吗？显然没必要，正如其名，方法，一套做事的方法，有方法就行，都是完成相同的任务要这么多没必要。况且我们有this这个可以替代调用当前函数的对象在。</p>
<h4 id="该模式的改进版"><a href="#该模式的改进版" class="headerlink" title="该模式的改进版"></a>该模式的改进版</h4><p>把方法放到构造函数外，此时gender方法为全局的,这样，每次在设置gender属性的时候，其实就是设置了一个指向该函数的指针。<br>该方法的缺点：gender方法只在调用该构造函数的时候才有用，设置成全局的，转为他服务，岂不是大材小用。如此一来，构造函数一多，全局方法岂不是满天飞？于是有一种明星级的模式闪亮登场！</p>
<h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><p>用自己的话来解释这个模式就是：<br>我们每创建一个函数，都会自动生成一个prototype属性，该属性以指针的形式存在，指向一个公共的名叫<code>原型对象</code>的东西，这个原型对象里面呢，存在着所有实例<code>共享</code>的属性和方法。看起来就像是构造函数把需要共享的东西放到另外一个对象里，然后用prototype属性指针指向他。实际上就是这样的哈！（有错误请评论指出，欢迎指正，么么）。这样，实例对象们就可以用同一个方法和属性了。</p>
<pre><code>function Elory(){}
Elory.prototype.name = &quot;eeelory&quot;;
Elory.prototype.age = 100;
Elory.prototype.gender = function(){
    alert(&quot;就不说&quot;);
};
var b = new Elory();
b.gender();//就不说
var c = new Elory();
c.gender();//就不说
alert(b.gender == c.gender); //返回true；
</code></pre><p>如果我们在实例对象中设置与原型对象中同名的属性值，那么前者中的值会屏蔽后者的值，也就是添加这个属性，会阻止我们访问原型对象中的属性的值。</p>
<pre><code>function Elory(){}
Elory.prototype.name = &quot;eeelory&quot;;
Elory.prototype.age = 100;
Elory.prototype.gender = function(){
    alert(&quot;就不说&quot;);
};
var b = new Elory();
var c = new Elory();
b.name = &quot;imb&quot;;
alert(b.name);//imb
alert(c.name);//eeelory
</code></pre><p>那如何重新访问原型对象中的属性呢？</p>
<pre><code>//接上例
delete b.name 
alert(b.name);//eeelory
</code></pre><p>答案就是使用<code>delete</code>操作符。</p>
<p>那怎样检测实例中存在某属性呢？</p>
<pre><code>//接上例
alert(b.name);//eeelory 因为上一步删除了实例中的name属性，所以此时访问的是原型对象中的name属性
alert(b.hasOwnProperty(&quot;name&quot;));//false 表示不存在于实例中
b.name = &quot;imb&quot;; //在实例对象中设置name属性
alert(b.hasOwnProperty(&quot;name&quot;));//true 表示存在于实例中
</code></pre><p>答案就是使用<code>hasOwnProperty（）</code>方法。</p>
<h4 id="该模式的改进版-1"><a href="#该模式的改进版-1" class="headerlink" title="该模式的改进版"></a>该模式的改进版</h4><p>字面量法定义原型对象。<br>我们在添加属性和方法时，都加上了Object.prototype前缀，但是如果属性数量很多，这样也太复杂了，于是用字面量来重写原型对象。</p>
<pre><code>function Elory(){}
Elory.prototype ={
name : &quot;eeelory&quot;,
age : 100,
gender : function(){alert(&quot;就不说&quot;);}
};
</code></pre><p>此时我们通过字面量的形式创建了一个新对象，但是这个新对象又拥有了自己的原型对象。画个图大概是这样：<br><img src="http://oeqcvcrxo.bkt.clouddn.com/js%E5%AF%B9%E8%B1%A1.png" alt="js-modle"><br>可以看到该原型对象的constructor并不指向Elory函数了。所以我们需要手动设置constructor的值为Elory.<br>其实这个属性值是否设置对我们要调用属性和方法好像没有太大用处，所以不用在意。</p>
<h4 id="原型模式的缺点"><a href="#原型模式的缺点" class="headerlink" title="原型模式的缺点"></a>原型模式的缺点</h4><p>1.省略了为构造函数传递初始化参数，这样导致新建的实例对象属性值都是相同的。<br>2.针对包含引用类型值的属性来说，实例就无法拥有自己的单独属性。（引用类型是一种数据结构，用于将数据和功能组织在一起）<br>举个例子：</p>
<pre><code>function Elory(){}
Elory.prototype ={
name : &quot;eeelory&quot;,
age : 100,
friends :[&quot;abc&quot;,&quot;def&quot;],
gender : function(){alert(&quot;就不说&quot;);}
};
var b = new Elory();
var c = new Elory();
b.friends.push(&quot;kkk&quot;);
alert(b.friends);//&quot;abc&quot;,&quot;def&quot;,&quot;kkk&quot;
alert(c.friends);//&quot;abc&quot;,&quot;def&quot;,&quot;kkk&quot;
alert(c.friends === b.friends);//true
</code></pre><p>从这里看出，实例不一定能拥有属于自己的全部属性。<br>如何改进上述两个缺点？</p>
<h3 id="组合使用构造函数模式和原型模式"><a href="#组合使用构造函数模式和原型模式" class="headerlink" title="组合使用构造函数模式和原型模式"></a>组合使用构造函数模式和原型模式</h3><p>构造函数模式用于定义实例属性，原型模式负责定义共享属性和方法。此外还支持向构造函数传递参数。</p>
<pre><code>function Elory(name,age)
{
    this.name = name;
    this.age = age;
    this.friends = [&quot;aaa&quot;,&quot;bbb&quot;];
}
Elory.prototype = {
constructor: Elory;
gender:function(){
alert(this.name);
}
var b = new Elory(&quot;imb&quot;,100);
var c = new Elory(&quot;imc&quot;,40);
b.friends.push(&quot;ccc&quot;);
alert(b.friends);//&quot;aaa&quot;,&quot;bbb&quot;,&quot;ccc&quot;
alert(c.friends);//&quot;aaa&quot;,&quot;bbb&quot;
alert(c.friends === b.friends);//false 专有属性
alert(c.gender === b.gender);//true  共享属性
</code></pre><h3 id="动态原型模式"><a href="#动态原型模式" class="headerlink" title="动态原型模式"></a>动态原型模式</h3><p>动态原型模式把所有信息封装在构造函数中，在必要的情况下通过构造函数初始化原型。</p>
<pre><code>function Elory(name,age)
{
    this.name = name;
    this.age = age;
    if(typeof this.gender != &quot;function&quot;){
            Elory.prototype.gender = function(){
            alert(this.name+&quot;have no sex&quot;);
            };
        }
}
</code></pre><p>if块内的代码只在初次调用构造函数时执行，此时原型对象已经完成初始化，具备gender属性，被所有实例共享。</p>
<h3 id="寄生构造函数模式"><a href="#寄生构造函数模式" class="headerlink" title="寄生构造函数模式"></a>寄生构造函数模式</h3><p>该模式的思想是创建一个函数，该函数的作用只是去封装创建对象所用的代码，然后返回新创建的对象。</p>
<pre><code>function SpecialArray(){
var values = new Array();
values.push.apply(values,arguments);
values.toPipedString = function(){
    return this.join(&quot;|&quot;);
    };
return values;
}
var colors = new SpecialArray(&quot;r&quot;,&quot;g&quot;,&quot;b&quot;);
alert(colors.toPipedString());//&quot;r&quot;|&quot;g&quot;|&quot;b&quot;
</code></pre><p>该模式需要注意的地方是：返回的对象和构造函数没有任何关系，从代码中可以看到。因此他也有工厂模式的缺点，不能识别对象类型。因此不建议使用该方法。</p>
<h3 id="稳妥构造函数模式"><a href="#稳妥构造函数模式" class="headerlink" title="稳妥构造函数模式"></a>稳妥构造函数模式</h3><h4 id="稳妥对象"><a href="#稳妥对象" class="headerlink" title="稳妥对象"></a>稳妥对象</h4><p>没有公共属性，其方法不引用this的对象。适用于安全环境中（这些环境禁止使用this和new），或者是防止数据被其他程序改动的时候使用。</p>
<h4 id="与寄生构造函数的差异"><a href="#与寄生构造函数的差异" class="headerlink" title="与寄生构造函数的差异"></a>与寄生构造函数的差异</h4><ol>
<li>新创建对象的实例方法不引用this；</li>
<li>不使用new操作符调用构造函数。</li>
</ol>
<p>重写Elory构造函数为：</p>
<pre><code>function Elory(name,age,gender)
{
    var o = new Object();

    o.readName = function(){
    alert(name);
    }
    return o;
}
</code></pre><p>这种模式创建的对象除了readName方法可以读取大name外，没有其他的方法能够访问数据。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>创建类的方法笼统的可以分三类。<br>工厂模式 构造模式 原型模式</p>
<blockquote>
<ul>
<li>工厂模式缺点<br>1.无法知道创建对象的类型。</li>
<li>构造模式的缺点<br>1.构造函数内的方法都会在实例中重新创建.</li>
<li>原型模式的缺点<br>1.省略了为构造函数传递初始化参数，这样导致新建的实例对象属性值都是相同的。<br>2.针对包含引用类型值的属性来说，实例就无法拥有自己的单独属性。</li>
</ul>
</blockquote>
<h2 id="小样有话说"><a href="#小样有话说" class="headerlink" title="小样有话说"></a>小样有话说</h2><center style="color:green;font-weight: Bold;border:1px dotted #999">这篇文章写了很多天了，并不是因为太难以理解导致的而是因为小样最近回学校忙着叙旧了。哇咔咔</center>

<center><div style="border: 2px solid #999;border-top:none;border-left:none;width: 20px;height:20px;transform:rotate(45deg);"></div></center><br><center style="dispaly:block;width:300px;margin:0 auto"><span style="display:inline-block;float:left;width:100px;height:10px;border-top:1px solid #999;margin-top:15px;"></span><span><a href="https://github.com/Gong-Elory" target="_blank" rel="external">龚小样</a></span><span style=" display:inline-block;float:right;width:100px;height:10px;border-top:1px solid #999;margin-top:15px;"></span></center><br><center><span style="font-size:14px;line-height:14px;margin-top:0;">2016-11-11</span></center>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对JS创建对象的方法进行总结&lt;br&gt;
    
    </summary>
    
      <category term="JS" scheme="http://gelory.me/categories/JS/"/>
    
    
      <category term="JS" scheme="http://gelory.me/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>JS执行环境及作用域的理解</title>
    <link href="http://gelory.me/2016/11/06/JS%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83%E5%8F%8A%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>http://gelory.me/2016/11/06/JS执行环境及作用域的理解/</id>
    <published>2016-11-06T04:02:07.000Z</published>
    <updated>2016-11-06T04:04:15.152Z</updated>
    
    <content type="html"><![CDATA[<p>对执行环境，作用域以及作用域链的理解。<br><a id="more"></a></p>
<h2 id="什么是执行环境"><a href="#什么是执行环境" class="headerlink" title="什么是执行环境"></a>什么是执行环境</h2><p>执行环境定义了变量和函数有权访问其他的数据，决定各自的行为。每个执行环境都有一个变量对象来存储所有的变量和函数。web浏览器的全局执行环境是window对象。对象会因ECMAScript实现的宿主环境不同而有差异。</p>
<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>指变量的适用范围。</p>
<h2 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h2><p>当代码在一个环境中执行，会创建变量对象的作用域链。用途是<strong>保证对执行环境有权访问的变量和函数进行有序的访问</strong></p>
<h3 id="作用域链顺序"><a href="#作用域链顺序" class="headerlink" title="作用域链顺序"></a>作用域链顺序</h3><p>作用域链的前端始终为 — 当前执行代码所在的环境的变量对象。譬如在函数中，就是arguments对象。<br>下个变量对象来自于包含当前环境的环境。<br>…<br>这样一直延续到全局执行环境。</p>
<h3 id="延长作用域链"><a href="#延长作用域链" class="headerlink" title="延长作用域链"></a>延长作用域链</h3><p>当执行流进入 try-catch语句中的catch块时，或者进入with语句时，作用域链得以加长。<br>这两个语句都会在作用域链的前端添加一个变量对象。对with来说，将语句指定的对象添加到作用域链.</p>
<pre><code>function(){
var color = &quot;red&quot;;
with(location)
{
    var ii =  href+color;//href为location对象的属性。此时location这个变量对象被加入到当前作用域链的前端
}
return ii;
}
</code></pre><h3 id="js中没有块级作用域"><a href="#js中没有块级作用域" class="headerlink" title="js中没有块级作用域"></a>js中没有块级作用域</h3><p>通俗的将就是for，if/else,while等用花括号括起来的代码块中定义的变量在当前执行环境中的任意地方都可以使用。</p>
<center><div style="border: 2px solid #999;border-top:none;border-left:none;width: 20px;height:20px;transform:rotate(45deg);"></div></center><br><center style="dispaly:block;width:300px;margin:0 auto"><span style="display:inline-block;float:left;width:100px;height:10px;border-top:1px solid #999;margin-top:15px;"></span><span><a href="https://github.com/Gong-Elory" target="_blank" rel="external">龚小样</a></span><span style=" display:inline-block;float:right;width:100px;height:10px;border-top:1px solid #999;margin-top:15px;"></span></center><br><center><span style="font-size:14px;line-height:14px;margin-top:0;">2016-11-6</span></center>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对执行环境，作用域以及作用域链的理解。&lt;br&gt;
    
    </summary>
    
      <category term="JS" scheme="http://gelory.me/categories/JS/"/>
    
    
      <category term="JS" scheme="http://gelory.me/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>JS垃圾回收机制</title>
    <link href="http://gelory.me/2016/11/05/JS%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"/>
    <id>http://gelory.me/2016/11/05/JS垃圾回收机制/</id>
    <published>2016-11-05T12:39:47.000Z</published>
    <updated>2016-11-05T12:42:48.148Z</updated>
    
    <content type="html"><![CDATA[<p>JavaScript具有自动垃圾收集机制，也就是说，执行环境会负责管理代码执行过程中使用的内存。<br><a id="more"></a><br>在浏览器中实现垃圾回收，通常有两个策略。</p>
<h2 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h2><p>垃圾收集器会在运行的时候，给所有存储在内存中的变量加上标记。然后去掉执行环境中的变量以及被环境中变量引用的变量的标记。而在此之后再被加上标记的变量被视为要删除的变量。因为这些变量再被加上标记的时候就是这些不需要这些变量的时候。譬如在执行完某个函数体后，跳出该函数体，里面的局部变量在就会重新被添加标记。此时垃圾收集器就会清除他们的内存。</p>
<p>现在，所有的现代浏览器基本上都是用标记清除算法，改进也是基于此改进的。</p>
<h2 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h2><p>跟踪记录每个值被引用的次数。如果为0，就收回内存。<br>举个例子</p>
<pre><code>var a = new Object()；
// 变量a对该对象进行首次引用
var b =a; 
// b也引用了这个对象 1+1=2
a=1; 
//此时a不在引用这个对象 1+1-1=1
//如果此时 b=2;那么b不在引用这个对象。此时就会释放这个对象实例的内存了。
c = b.name 
/*
     *此时c引用了这个对象的name属性，于是乎，即使b不再引用这个对象，在是这个对象的属性name还在被引用，因此也无法清除这个对象。
*/
b=2;
c=3;//此时，垃圾收集器就会释放这个对象内存啦
</code></pre><h2 id="例外-循环引用（导致退出函数体后无法自动清除内存）"><a href="#例外-循环引用（导致退出函数体后无法自动清除内存）" class="headerlink" title="例外-循环引用（导致退出函数体后无法自动清除内存）"></a>例外-循环引用（导致退出函数体后无法自动清除内存）</h2><pre><code>function pro()
{
var a = new Object();
var b = new Object();
a.name = b; //a的name属性引用了b
b.age = a;//b的age属性引用了a
}
</code></pre><p>如果采用标记清除法，会因为退出函数体而自动清除内存.但是如果用引用计数法，此时两个对象都被引用了两次，于是无法自动清除内存了。<br>如果这个函数被大量调用，就会导致大量内存被占用不能回收。因此要手动取消循环引用.</p>
<pre><code>a.name = null;
b.age = null;
此时a，b的内存就被回收啦。
a=null;
b=null;//两个对象的内存就被清除啦。
</code></pre><p>如有错误，评论。</p>
<center><div style="border: 2px solid #999;border-top:none;border-left:none;width: 20px;height:20px;transform:rotate(45deg);"></div></center><br><center style="dispaly:block;width:300px;margin:0 auto"><span style="display:inline-block;float:left;width:100px;height:10px;border-top:1px solid #999;margin-top:15px;"></span><span><a href="https://github.com/Gong-Elory" target="_blank" rel="external">龚小样</a></span><span style=" display:inline-block;float:right;width:100px;height:10px;border-top:1px solid #999;margin-top:15px;"></span></center><br><center><span style="font-size:14px;line-height:14px;margin-top:0;">2016-11-5</span></center>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JavaScript具有自动垃圾收集机制，也就是说，执行环境会负责管理代码执行过程中使用的内存。&lt;br&gt;
    
    </summary>
    
      <category term="前端" scheme="http://gelory.me/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JS" scheme="http://gelory.me/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>JS实现快速排序</title>
    <link href="http://gelory.me/2016/11/05/Js%E5%AE%9E%E7%8E%B0%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    <id>http://gelory.me/2016/11/05/Js实现快速排序/</id>
    <published>2016-11-05T06:57:08.000Z</published>
    <updated>2016-11-05T07:14:02.789Z</updated>
    
    <content type="html"><![CDATA[<p>关于快速排序的理解。<br><a id="more"></a><br>快速排序的思想是：<br>1.从数列中找一个基准数。<br>2.把小于他的数放在基准数左边，剩余的放右边。<br>3.分别对左边和右边进行步骤1,2，知道区间内只有一个数。</p>
<p>其实可以把快排分为两个部分，<code>分</code>与<code>治</code>。因此用两个函数体概括两部分更加明了。</p>
<h2 id="治部分"><a href="#治部分" class="headerlink" title="治部分"></a>治部分</h2><p>该部分规定每一次排序采用的方法</p>
<pre><code>function cover(arr,left,right)
{
    var i = left;
    var j = right;
    var based = arr[i]; //去数列的第一个为基准数
    while(i&lt;j)
    {
        while(i&lt;j &amp;&amp; arr[j]&gt;=x) j--;
        if(i&lt;j) arr[i++] = arr[j];
        while(i&lt;j &amp;&amp; arr[i]&lt;=x) i++;
        if(i&lt;j) arr[j--] = arr[i];
    }
    arr[i] = based;
    return i//运行到这，其实i与j相等了，这一轮就弄完了
}
</code></pre><p>治部分可以这样理解。</p>
<p><div><span style="border:1px solid;padding:0.5rem">0</span><span style="border:1px solid;padding:0.5rem">1</span><span style="border:1px solid;padding:0.5rem">2</span><span style="border:1px solid;padding:0.5rem">3</span><span style="border:1px solid;padding:0.5rem">4</span></div><br></p>
<p><div><span style="color:#666;border:1px solid;padding:0.5rem">88</span><span style="border:1px solid;padding:0.5rem">21</span><span style="border:1px solid;padding:0.5rem">35</span><span style="border:1px solid;padding:0.5rem">12</span><span style="border:1px solid;padding:0.5rem">6</span><span style="color:#fff;background:#666;border:1px solid;padding:0.5rem">88</span></div><br></p>
<h3 id="步骤1：找基准数"><a href="#步骤1：找基准数" class="headerlink" title="步骤1：找基准数"></a>步骤1：找基准数</h3><p>这里有5个萝卜坑，每个坑里有一个萝卜。我现在去<code>arr[0]</code>为基准数，并赋值给<code>based</code>，就相当于把第一个坑里的萝卜放篮子里。</p>
<pre><code>var based = arr[i]; 
</code></pre><h3 id="步骤2：从后向前找小于基准数的数"><a href="#步骤2：从后向前找小于基准数的数" class="headerlink" title="步骤2：从后向前找小于基准数的数"></a>步骤2：从后向前找小于基准数的数</h3><p>然后从4开始往前找一个比篮子里的萝卜88更小的。<br>譬如，在图中我们就把<code>4号坑</code>里的萝卜放到了<code>0号坑</code>。<br>如果当前坑没有就继续往下找（<code>j--</code>）。这里用<code>i&lt;j</code>来限制什么时候停止寻找。<br>找到后，填到第一个坑里，即<code>arr[i]=arr[j]</code><br>之后是从前往后找大萝卜，是从刚填了小萝卜的后一个坑开始。所以是<code>i++</code>.合并了就是<code>arr[i++] = arr[j];</code><br>这就是代码中的这一段：</p>
<pre><code>while(i&lt;j &amp;&amp; arr[j]&gt;=x) j--; //挨个从后向前找小萝卜
if(i&lt;j) arr[i++] = arr[j]; //用小萝卜填坑
</code></pre><h3 id="步骤3：从前向后找大于基准数的数"><a href="#步骤3：从前向后找大于基准数的数" class="headerlink" title="步骤3：从前向后找大于基准数的数"></a>步骤3：从前向后找大于基准数的数</h3><p>此时<code>0号坑</code>里有了萝卜，但是<code>4号坑</code>没了。<br>那<code>4号坑</code>谁来填，我们从<code>1（步骤2中的i++导致的）号坑</code>开始向后寻找一个比<code>篮子里的萝卜</code>大的放在<code>4号坑</code>。坑里没有就<code>i++</code>，到下一个坑里找.这就是代码中的这一段：</p>
<pre><code>while(i&lt;j &amp;&amp; arr[i]&lt;=x) i++;// 挨个从前向后找大萝卜
if(i&lt;j) arr[j--] = arr[i]; //用大萝卜填坑
</code></pre><p><strong>这就是代码段中的循环过程：</strong></p>
<blockquote>
<p>从后向前（<code>j--</code>）找小萝卜填上一个坑<br>从前向后（<code>i++</code>）找大萝卜填上一个坑<br>从后向前（<code>j--</code>）找小萝卜填上一个坑<br>从前向后（<code>i++</code>）找大萝卜填上一个坑<br>…<br>直到 从前向后以及从后向前遇到了同一个坑<code>i=j</code>。</p>
</blockquote>
<pre><code>while(i&lt;j){
    //找萝卜。当i=j时就不会执行了
}
</code></pre><h3 id="步骤4-回填基准数"><a href="#步骤4-回填基准数" class="headerlink" title="步骤4 回填基准数"></a>步骤4 回填基准数</h3><p>最后，我们把篮子里的萝卜填到<code>i=j</code>的那个坑<code>arr[i] = based;</code></p>
<h2 id="分部分"><a href="#分部分" class="headerlink" title="分部分"></a>分部分</h2><p>该部分规定如何去调用治。</p>
<pre><code>function quick_sort(arr,l,r){
    if(l&lt;r)
    {
        var m = cover(arr,l,r); 
        quick_sort(arr,l,m-1);
        quick_sort(arr,m+1,r);
    }
}
</code></pre><p>经过第一次的治：<code>首次执行cover(arr,l,r)</code>，我们已经通过基准数把大于他的数放到了右边，小于他的数放在了左边。</p>
<p><div><span style="border:1px solid;padding:0.5rem">0</span><span style="border:1px solid;padding:0.5rem">1</span><span style="border:1px solid;padding:0.5rem">2</span><span style="border:1px solid;padding:0.5rem">3</span><span style="border:1px solid;padding:0.5rem">4</span></div><br></p>
<p><div><br><span style="border:1px solid;padding:0.5rem">6</span><span style="border:1px solid;padding:0.5rem">21</span> <span style="border:1px solid;padding:0.5rem">35</span><span style="border:1px solid;padding:0.5rem">12</span><span style="border:1px solid;padding:0.5rem">88</span><span style="color:#fff;background:#666;border:1px solid;padding:0.5rem">88</span></div><br><br>这个例子中，88最大所以他成了最后一个，小于他的全部在左边。但是发现没有，左边的数并不是从大到小的。于是我们把除开88之后，其他的坑在来进行一次换坑操作。如果88不是最大的。譬如</p>
<p><div><span style="border:1px solid;padding:0.5rem">6</span><span style="border:1px solid;padding:0.5rem">21</span> <span style="border:1px solid;padding:0.5rem">35</span><span style="border:1px solid;padding:0.5rem">12</span><span style="border:1px solid;padding:0.5rem">88</span><span style="border:1px solid;padding:0.5rem">106</span><span style="border:1px solid;padding:0.5rem">90</span> </div><br><br>那我们也要对88右边也进行换坑操作。</p>
<p>对左边的坑进行操作：</p>
<p><div><span style="border:1px solid;padding:0.5rem">6</span><span style="border:1px solid;padding:0.5rem">21</span><span style="border:1px solid;padding:0.5rem">35</span><span style="border:1px solid;padding:0.5rem">12</span></div><br><br>调用的是：</p>
<pre><code>quick_sort(arr,l,m-1);//m-1是为了排除88这个萝卜坑
//在这里面就会执行如下代码
if(i&lt;j)
    {
        var m = cover(arr,l,m-1); 
        quick_sort(arr,l,m-1);
        quick_sort(arr,m+1,m-1);
    }
</code></pre><p>对右边的坑进行操作：</p>
<p><div><span style="border:1px solid;padding:0.5rem">106</span><span style="border:1px solid;padding:0.5rem">90</span></div><br><br>调用的是：</p>
<pre><code>quick_sort(arr,m+1,r);//m+1是为了排除88这个萝卜坑
//在这里面就会执行如下代码
if(i&lt;j)
    {
        var m = cover(arr,m+1,r); 
        quick_sort(arr,m+1,m-1);
        quick_sort(arr,m+1,r);
    }
</code></pre><p>就这样不停地迭代调用 quick_sort 直到不能满足<code>if(l&lt;r)</code>就停止啦。</p>
<p>然后我们随便定义一个数组，试试看？</p>
<pre><code>var array = [9,8,5,8,7,6,5];
quick_sort(array,0,array.length-1);
alert(array);
</code></pre><h2 id="最后贴上合并版本的代码。"><a href="#最后贴上合并版本的代码。" class="headerlink" title="最后贴上合并版本的代码。"></a>最后贴上合并版本的代码。</h2><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><pre><code>//原地排序，不产生新的数组
function quicksorter(arr,start,end)
{
    var i =start;
    var j =end;
    var m;
    if(i&lt;j)
    {
        var x = arr[i];
        while(i &lt; j)
        {
            while(i &lt; j &amp;&amp; arr[j]&gt;=x) j--;
            if(i&lt;j )arr[i++]=arr[j];
            while(i&lt;j &amp;&amp; arr[i]&lt;=x) i++;
             if(i&lt;j) arr[j--]=arr[i];    
        }
        arr[i]=x;
        m=i;
        console.log(m);
        quicksorter(arr,start,m-1);
        quicksorter(arr,m+1,end);
    }
}
var array = [9,8,5,8,7,6,5];
var lili =quicksorter(array,0,array.length-1);
alert(array);
</code></pre><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><pre><code>//利用新数组来排序
var quicksort = function(arr)
{
    if(arr.length &lt;= 1) return arr;
    var based_var = arr[0];
    var left = [];
    var right = [];
    for(var i=1;i&lt;arr.length;i++)
    {
        if(arr[i]&lt;=based_var)
            left.push(arr[i]);
        else
            right.push(arr[i]);
    }
    return quicksort(left).concat(based_var,quicksort(right));
}
var array = [2,3,4,13,89,72,4,20,3,3,3,3,3,3,1,2];
var lili =quicksort(array)
alert(lili);
</code></pre><center><div style="border: 2px solid #999;border-top:none;border-left:none;width: 20px;height:20px;transform:rotate(45deg);"></div></center><br><center style="dispaly:block;width:300px;margin:0 auto"><span style="display:inline-block;float:left;width:100px;height:10px;border-top:1px solid #999;margin-top:15px;"></span><span><a href="https://github.com/Gong-Elory" target="_blank" rel="external">龚小样</a></span><span style=" display:inline-block;float:right;width:100px;height:10px;border-top:1px solid #999;margin-top:15px;"></span></center><br><center><span style="font-size:14px;line-height:14px;margin-top:0;">2016-11-5</span></center>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于快速排序的理解。&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="http://gelory.me/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="JS" scheme="http://gelory.me/tags/JS/"/>
    
      <category term="算法" scheme="http://gelory.me/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>call与apply，caller与callee</title>
    <link href="http://gelory.me/2016/11/04/call%E4%B8%8Eapply%EF%BC%8Ccaller%E4%B8%8Ecallee/"/>
    <id>http://gelory.me/2016/11/04/call与apply，caller与callee/</id>
    <published>2016-11-04T13:38:42.000Z</published>
    <updated>2016-11-06T07:05:05.573Z</updated>
    
    <content type="html"><![CDATA[<p>讲一下这两对的区别。<br><a id="more"></a></p>
<h2 id="call与apply"><a href="#call与apply" class="headerlink" title="call与apply"></a>call与apply</h2><p>call和apply都具有相同的作用，就是借别人的方法用，一句话，简洁明了。<br>什么意思呢？一个表达式表达出来：<code>b方法</code>.<code>call</code>(<code>a对象</code>,<code>a带的参数（可选）</code>);<br>这样a就可以用b方法啦。<br>具体到实例：</p>
<pre><code>function b(x，y){
    alert(&quot;我是&quot;+x+y)；
}
function a(){
    b.call(this,&quot;a&quot;,&quot;吧&quot;);//我是a吧
}

function  c(m,n){
    b.apply(this,arguments);//我是mn
    b.apply(this,[m,n])；// 我是mn
}
a();
c(&quot;m&quot;,&quot;n&quot;);
</code></pre><p>区别在于：call是直接把参数传过去，apply是把参数先放到一个数组，然后一块传。</p>
<p>那什么时候用哪一种呢？<br>明确参数的个数时，就用call，不知道有多少个参数时，就用apply。</p>
<h2 id="caller"><a href="#caller" class="headerlink" title="caller"></a>caller</h2><p>caller，该属性中保存着调用当前函数的函数的引用，简洁的说就是找出是<code>谁调用了</code>正在运行我的<code>这个函数体</code><br>举个栗子：</p>
<pre><code>function a()
{
 alert(a.caller)
}

function b(){
 a();
}
a();// null
b();//b
</code></pre><p>执行a();时，是js顶层调用的，所以返回null<br>执行b();时，是b调用了a，所以返回的是b的方法名。</p>
<h2 id="callee"><a href="#callee" class="headerlink" title="callee"></a>callee</h2><p>这个在匿名递归时用的最多。指向拥有arguments对象的函数，简洁的说就是找出callee运行的那个函数体<br>举个栗子：</p>
<pre><code>setTimeout(function(){
/*
*do something
*/
setTimeout(arguments.callee,100);//指向当前执行的函数，此时指向的是匿名函数。
},100)
</code></pre><p>当然，不嫌麻烦可以这样写。</p>
<pre><code>function bb(){
/*
*do something
*/
setTimeout(bb(),100);
}

setTimeout(bb(),100);
</code></pre><h2 id="使用caller，callee要注意的地方"><a href="#使用caller，callee要注意的地方" class="headerlink" title="使用caller，callee要注意的地方"></a>使用caller，callee要注意的地方</h2><p>在严格模式下，访问arguments.callee会报错。ES5也定义了arguments.caller。同样也会报错。在非严格模式下arguments.caller始终返回undefined。在严格模式下,为函数的caller赋值也会报错。</p>
<center><div style="border: 2px solid #999;border-top:none;border-left:none;width: 20px;height:20px;transform:rotate(45deg);"></div></center><br><center style="dispaly:block;width:300px;margin:0 auto"><span style="display:inline-block;float:left;width:100px;height:10px;border-top:1px solid #999;margin-top:15px;"></span><span><a href="https://github.com/Gong-Elory" target="_blank" rel="external">龚小样</a></span><span style=" display:inline-block;float:right;width:100px;height:10px;border-top:1px solid #999;margin-top:15px;"></span></center><br><center><span style="font-size:14px;line-height:14px;margin-top:0;">2016-11-4</span></center>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;讲一下这两对的区别。&lt;br&gt;
    
    </summary>
    
      <category term="前端" scheme="http://gelory.me/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="http://gelory.me/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="Js" scheme="http://gelory.me/tags/Js/"/>
    
  </entry>
  
  <entry>
    <title>setTimeout与setInterval的区别与互补</title>
    <link href="http://gelory.me/2016/11/04/setTimeout%E4%B8%8EsetInterval%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E4%BA%92%E8%A1%A5/"/>
    <id>http://gelory.me/2016/11/04/setTimeout与setInterval的区别与互补/</id>
    <published>2016-11-04T12:10:55.000Z</published>
    <updated>2016-11-04T12:15:57.347Z</updated>
    
    <content type="html"><![CDATA[<p>我们经常用这两种方法来处理延时或者定时任务。但是其中还是有一点区别与联系的。<br><a id="more"></a><br>setTimeout用于在<code>指定毫秒数后</code>进行相关操作。<code>只会执行一次。</code><br>setInterval用于<code>每隔指定毫秒数后循环</code>进行相关操作。<code>执行N次。</code></p>
<h2 id="定时并非那么精准"><a href="#定时并非那么精准" class="headerlink" title="定时并非那么精准"></a>定时并非那么精准</h2><p>原因：js运行在单线程中，当定时时间到后，并不是立即执行相关操作，而是把代码放到队列里等候执行。做好了执行的准备。至于为什么等，因为浏览器要先执行一些优先级较高的代码。</p>
<h2 id="既然setInterval可以重复定时，为什么要用setTimeout来实现重复定时。"><a href="#既然setInterval可以重复定时，为什么要用setTimeout来实现重复定时。" class="headerlink" title="既然setInterval可以重复定时，为什么要用setTimeout来实现重复定时。"></a>既然setInterval可以重复定时，为什么要用setTimeout来实现重复定时。</h2><p>setInterval在执行代码时，可能因为前一次代码执行时间超出了指定时间间隔，而导致下一次的的代码在队列中等待，直到前一次代码执行完。<br>js不允许一个队列中出现同一定时器的多次代码。因此只要队列中有一个，间隔时间到了，后面的代码将会被丢弃。<br><a href="http://qingbob.com/difference-between-settimeout-setinterval/" target="_blank" rel="external">这里没有图片，不直观，可以点击这里！</a><br>于是就会出现问题：<br>1.有些间隔就被忽略了。<br>2.假设间隔为100ms，如果前一次在190ms的时候结束，后一次的代码会在200ms时开始执行，因此实际运行间隔就不是100ms了<br>于是，鉴于这些缺点，setTimeout很好地弥补了这个缺点。因为如果这样写</p>
<pre><code>  setTimeout(function repeatMe() {     
/* Some long block of code... */   
setTimeout(repeatMe, 10);          
}, 10);
</code></pre><p>这样写的话，每次都是先执行外代码，然后创建了一个新的定时器，开始计时，于是就保证了间隔永远是指定时间</p>
<p>此外setTimeout还可以用在发生时间冒泡时，设置事件发生顺序。有时间在深入讨论冒泡捕获相关内容。</p>
<center><div style="border: 2px solid #999;border-top:none;border-left:none;width: 20px;height:20px;transform:rotate(45deg);"></div></center><br><center style="dispaly:block;width:300px;margin:0 auto"><span style="display:inline-block;float:left;width:100px;height:10px;border-top:1px solid #999;margin-top:15px;"></span><span><a href="https://github.com/Gong-Elory" target="_blank" rel="external">龚小样</a></span><span style=" display:inline-block;float:right;width:100px;height:10px;border-top:1px solid #999;margin-top:15px;"></span></center><br><center><span style="font-size:14px;line-height:14px;margin-top:0;">2016-11-4</span></center>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们经常用这两种方法来处理延时或者定时任务。但是其中还是有一点区别与联系的。&lt;br&gt;
    
    </summary>
    
      <category term="前端" scheme="http://gelory.me/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="http://gelory.me/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="Js" scheme="http://gelory.me/tags/Js/"/>
    
  </entry>
  
  <entry>
    <title>innerHTML相关知识点总结</title>
    <link href="http://gelory.me/2016/11/03/innerHTML%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"/>
    <id>http://gelory.me/2016/11/03/innerHTML相关知识点总结/</id>
    <published>2016-11-03T14:25:28.000Z</published>
    <updated>2016-11-03T14:26:38.761Z</updated>
    
    <content type="html"><![CDATA[<p>这里总结了和innerHTML有联系的一些知识点。<br><a id="more"></a></p>
<h2 id="innerHTML相关属性的区别"><a href="#innerHTML相关属性的区别" class="headerlink" title="innerHTML相关属性的区别"></a>innerHTML相关属性的区别</h2><p>innerHTML:获取或者设置位于对象起止标签内的HTML<br>innerText：获取设置位于对象起止标签内的文本<br>outerHTML：获取设置包括对象起止标签的HTML<br>outerText：设置包括标签的文本，获取不包括标签的文本。<br>譬如：</p>
<pre><code>&lt;div&gt;content&lt;br/&gt;&lt;/div&gt;
</code></pre><p>innerHTML：<code>content&lt;br/&gt;</code><br>innerText： <code>content</code><br>outerHTML： <code>&lt;div&gt;content&lt;br/&gt;&lt;/div&gt;</code><br>outerText： <code>content</code>//如果修改该值的话，会把<code>&lt;div&gt;content&lt;br/&gt;&lt;/div&gt;</code>覆盖掉。</p>
<p>innerHTML虽然并不是W3C DOM标准的组成部分，但是符合HTML5规范。innerText只适用于IE浏览器，所以考虑兼容性的话，尽量使用innerHTML。如果只需要标签内文本的话，可以使用正则表达式过滤。</p>
<h2 id="innerHTML与document-write-的区别"><a href="#innerHTML与document-write-的区别" class="headerlink" title="innerHTML与document.write()的区别"></a>innerHTML与document.write()的区别</h2><blockquote>
<ul>
<li>定义：innerHTML是DOM元素对象的一个属性，write是document对象的一个方法。</li>
<li>用途：innerHTML属性可以用来获取、修改指定元素内的所有标签和内容。而document.write()对整个文档流进行重写。</li>
<li>原理：innerHTML是对属性设置，代表的是该元素的HTML内容，可以精准的对某一元素进行修改。document.write()创建一个新的文档输出流，向HTML输出流写内容，如果在文档渲染完毕后使用，则会迫使浏览器重新渲染。</li>
<li>优劣：document.write（）最大的缺点是违背了<code>行为应为与结构分离</code>的原则，也就是js应该与html代码分离。<br>innerHTML在很多情况下优于document.write()，原因是前者允许精准修改某一部分。缺点：相对于DOM方法和属性，innerHTML没有细节而言，他获取的是整个内容。</li>
</ul>
</blockquote>
<center><div style="border: 2px solid #999;border-top:none;border-left:none;width: 20px;height:20px;transform:rotate(45deg);"></div></center><br><center style="dispaly:block;width:300px;margin:0 auto"><span style="display:inline-block;float:left;width:100px;height:10px;border-top:1px solid #999;margin-top:15px;"></span><span><a href="https://github.com/Gong-Elory" target="_blank" rel="external">龚小样</a></span><span style=" display:inline-block;float:right;width:100px;height:10px;border-top:1px solid #999;margin-top:15px;"></span></center><br><center><span style="font-size:14px;line-height:14px;margin-top:0;">2016-11-3</span></center>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这里总结了和innerHTML有联系的一些知识点。&lt;br&gt;
    
    </summary>
    
      <category term="前端" scheme="http://gelory.me/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="http://gelory.me/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="DOM" scheme="http://gelory.me/tags/DOM/"/>
    
  </entry>
  
  <entry>
    <title>JS中全局变量和局部变量的区别</title>
    <link href="http://gelory.me/2016/11/03/JS%E4%B8%AD%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%92%8C%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://gelory.me/2016/11/03/JS中全局变量和局部变量的区别/</id>
    <published>2016-11-03T06:12:17.000Z</published>
    <updated>2016-11-03T06:14:06.022Z</updated>
    
    <content type="html"><![CDATA[<p>什么是局部变量，用var操作符定义的变量将成为该变量作用域中的局部变量。其实可以这样理解，全局变量也是局部变量，只不过他是在<code>&lt;script&gt;&lt;/script&gt;</code>包含的作用域下的局部变量。但是通常情况下，我们参考的标准的function域，也就是说在<code>function域中用var定义的变量称为在该作用域下的局部变量</code>，那么剩余的就是全局变量了。<br><a id="more"></a></p>
<h2 id="哪些方式可以生成全局变量与局部变量："><a href="#哪些方式可以生成全局变量与局部变量：" class="headerlink" title="哪些方式可以生成全局变量与局部变量："></a>哪些方式可以生成全局变量与局部变量：</h2><pre><code>var a=0; //全局变量1
b=0; //全局变量2
window.str3 = &quot;hello3&quot;; //全局变量3
function(){
    var d = 0；//局部变量4
    e=0; //全局变量5
}
</code></pre><p>全局变量2，5，虽说这样可以定义全局变量，但是不推荐这样做，因为如果你养成了这样定义全局变量的习惯，如果有一天一不小心，原本应该定位为局部变量的变量，由于忘记了var，变成了全局变量，那么找bug将会很困难，因为在你潜意识中，看到这个变量，你以为是在这里定义了个全局变量，其实是忘写var了。<strong>所以，不要有意识的去不写var</strong>。 此外给未经声明的变量赋值，在严格模式下会抛出<code>ReferenceError</code>错误。</p>
<h2 id="局部变量的陷阱"><a href="#局部变量的陷阱" class="headerlink" title="局部变量的陷阱"></a>局部变量的陷阱</h2><h3 id="陷阱1"><a href="#陷阱1" class="headerlink" title="陷阱1"></a>陷阱1</h3><p>在作用域当中，在声明前使用局部变量不会报错，但因为没有赋值，所以返回的是undefined。</p>
<pre><code>function test(){  
    alert(a);  //1.此时显示的为undefined
    var a=4;
    alert(a); //2.此时显示的是4
} 
</code></pre><p>原因：js在执行前会对整个脚本文件分析，因此1不会报错，而只是因为在此前没对a赋值，所以显示undefined。<br>之所以2处会显示a，是因为在此之前对a进行赋值了。<br>因此需要注意两点：</p>
<blockquote>
<ul>
<li><p>在引用局部变量时，与局部变量的声明地点无关，局部变量的作用域为整个function域。</p>
</li>
<li><p>在使用局部变量的值时，与局部变量的赋值地点有关，赋值的作用域起于赋值地点，止于function域结束，可以被覆盖。</p>
</li>
</ul>
</blockquote>
<h3 id="陷阱2"><a href="#陷阱2" class="headerlink" title="陷阱2"></a>陷阱2</h3><p>局部变量的划分是以function块为标准，而for、while、if块不是。</p>
<pre><code>function test(){  
        for(var i=0;i&lt;3;i++)
        {
            alert(i); //1.此时显示的是0,1,2
        }
        alert(i) //2.此时显示的是2
    } 
</code></pre><p>原因：在for内进行声明的变量属于局部变量，他的作用域在整个function域内，而不仅仅只for域内，因此2处显示的是2，而不是报错。<br>因此注意一点</p>
<blockquote>
<ul>
<li>局部变量的划分是以function块为标准。</li>
</ul>
</blockquote>
<h3 id="陷阱3"><a href="#陷阱3" class="headerlink" title="陷阱3"></a>陷阱3</h3><p>如果全局变量和局部变量的变量名相同，采取的是谁近听谁的原则。</p>
<pre><code>var a = 0;
function test(){  
        var a = 1;
        alert(a); //1.此时显示的是1
    }
alert(a); //2.此时显示的是0
</code></pre><p>原因：1在function域下,其直接父域是function，所以听局部声明。2.的直接父域是script域,所以听全局声明<br>注意一点</p>
<blockquote>
<ul>
<li>重名时，局部变量覆盖全局变量声明，跳出局部变量所在域后，由全局声明决定变量值。</li>
</ul>
</blockquote>
<p>那怎样才能在这种情况下，在function域中使用全局变量呢？<br>1.改名。天涯何处无芳草，何必吊死于一树。<br>2.在function域中使用<code>window.变量名</code>就可以调用全局变量啦。</p>
<pre><code>alert(window.a); //此时显示的是0
</code></pre><center><div style="border: 2px solid #999;border-top:none;border-left:none;width: 20px;height:20px;transform:rotate(45deg);"></div></center><br><center style="dispaly:block;width:300px;margin:0 auto"><span style="display:inline-block;float:left;width:100px;height:10px;border-top:1px solid #999;margin-top:15px;"></span><span><a href="https://github.com/Gong-Elory" target="_blank" rel="external">龚小样</a></span><span style=" display:inline-block;float:right;width:100px;height:10px;border-top:1px solid #999;margin-top:15px;"></span></center><br><center><span style="font-size:14px;line-height:14px;margin-top:0;">2016-11-3</span></center>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;什么是局部变量，用var操作符定义的变量将成为该变量作用域中的局部变量。其实可以这样理解，全局变量也是局部变量，只不过他是在&lt;code&gt;&amp;lt;script&amp;gt;&amp;lt;/script&amp;gt;&lt;/code&gt;包含的作用域下的局部变量。但是通常情况下，我们参考的标准的function域，也就是说在&lt;code&gt;function域中用var定义的变量称为在该作用域下的局部变量&lt;/code&gt;，那么剩余的就是全局变量了。&lt;br&gt;
    
    </summary>
    
      <category term="前端" scheme="http://gelory.me/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JS" scheme="http://gelory.me/tags/JS/"/>
    
      <category term="前端" scheme="http://gelory.me/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>Viewport的深入了解</title>
    <link href="http://gelory.me/2016/11/02/Viewport%E7%9A%84%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3/"/>
    <id>http://gelory.me/2016/11/02/Viewport的深入了解/</id>
    <published>2016-11-02T05:59:06.000Z</published>
    <updated>2016-11-02T06:00:35.197Z</updated>
    
    <content type="html"><![CDATA[<p>刚接触移动端网页开发，之前不知带要设置页面缩放属性，导致正常字体小的出奇，这次对viewport进一步深入学习。<br><a id="more"></a></p>
<h2 id="viewport定义"><a href="#viewport定义" class="headerlink" title="viewport定义"></a>viewport定义</h2><p>就像英文字面翻译一样，能看得到的区域。viewport指的是显示网页的区域。但是因为viewport按特性可以分为三类，所以viewport又不仅仅是浏览器可视区域那么大。</p>
<p>譬如一般移动端浏览器显示屏宽度都是320px 480px等。但是移动设备的viewport默认宽度是980px或者1024px。这个值可以自己设置。</p>
<h2 id="物理像素与CSS像素的区别与联系"><a href="#物理像素与CSS像素的区别与联系" class="headerlink" title="物理像素与CSS像素的区别与联系"></a>物理像素与CSS像素的区别与联系</h2><p>在桌面浏览器中，CSS的1px是等于屏幕上的1个物理像素的。 但是在移动设备中可就不一定，譬如Retina屏，一个CSS像素相当于两个物理像素。</p>
<h3 id="屏幕尺寸和像素尺寸的区别与联系"><a href="#屏幕尺寸和像素尺寸的区别与联系" class="headerlink" title="屏幕尺寸和像素尺寸的区别与联系"></a>屏幕尺寸和像素尺寸的区别与联系</h3><p>屏幕的尺寸和像素尺寸不是一样的  譬如ipone3和iphone4都是320px的宽屏。但是前者像素是320px，后者采用retina屏，像素是640px。<br>安卓设备也是一样，根据像素密度分为ldpi，mdpi，hdpi，xhdpi等不同等级。</p>
<h3 id="用户缩放导致CSS像素与物理像素的比值差异"><a href="#用户缩放导致CSS像素与物理像素的比值差异" class="headerlink" title="用户缩放导致CSS像素与物理像素的比值差异"></a>用户缩放导致CSS像素与物理像素的比值差异</h3><p>如果用户把页面放大一倍，首先，屏幕尺寸是不会变的，1个CSS像素如果以前相当于一个物理像素，此时，就相当于两个物理像素了，那么我们看到的景象就是字体什么的放大了。</p>
<h2 id="viewport按表现类型分三类"><a href="#viewport按表现类型分三类" class="headerlink" title="viewport按表现类型分三类"></a>viewport按表现类型分三类</h2><p>layout viewport 大于浏览器可视区域宽度<br>visual biewport 浏览器可视区域宽度<br>ideal viewport 完美适配移动端屏幕的宽度</p>
<p>只要在CSS中把某一元素的宽度设置为ideal viewport的宽度，那么这个元素的宽度就是设备屏幕的宽度。</p>
<h2 id="利用meta元标签对viewport进行控制"><a href="#利用meta元标签对viewport进行控制" class="headerlink" title="利用meta元标签对viewport进行控制"></a>利用meta元标签对viewport进行控制</h2><p>移动设备默认的是layout viewport。但是进行移动设备网站开发时，我们需要ideal viewport。</p>
<pre><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0&quot;&gt;
</code></pre><p>这个标签的作用就是让当前页面的宽度等于设备的宽度，不允许手动缩放。</p>
<h2 id="meta-viewport的6个属性"><a href="#meta-viewport的6个属性" class="headerlink" title="meta viewport的6个属性"></a>meta viewport的6个属性</h2><p>width：设置layout viewport的宽度。可以使整数，也可以设置为width-device。当设置为width-device时，自动适配屏幕宽度。<br>height：设置layout viewport的高度。<br>initial-scale：设置页面加载时的缩放值，可以是小数。相对于ideal-viewport值进行缩放。<br>minimum-scale：允许用户的最小缩放值。<br>maximum-scale：允许用户的最大缩放值。<br>user-scalable：是否允许用户手动缩放。 值为’yes’ or ‘no’。</p>
<p>经证明：<br>    <meta name="viewport" content="width=device-width, initial-scale=1"></p>
<p>可以让大部分的移动端设备的viewport设置为ideal viewport。</p>
<center><div style="border: 2px solid #999;border-top:none;border-left:none;width: 20px;height:20px;transform:rotate(45deg);"></div></center><br><center style="dispaly:block;width:300px;margin:0 auto"><span style="display:inline-block;float:left;width:100px;height:10px;border-top:1px solid #999;margin-top:15px;"></span><span><a href="https://github.com/Gong-Elory" target="_blank" rel="external">龚小样</a></span><span style=" display:inline-block;float:right;width:100px;height:10px;border-top:1px solid #999;margin-top:15px;"></span></center><br><center><span style="font-size:14px;line-height:14px;margin-top:0;">2016-11-2</span></center>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;刚接触移动端网页开发，之前不知带要设置页面缩放属性，导致正常字体小的出奇，这次对viewport进一步深入学习。&lt;br&gt;
    
    </summary>
    
      <category term="前端" scheme="http://gelory.me/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="http://gelory.me/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="CSS" scheme="http://gelory.me/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>Webkit内核显示字体自动放大问题</title>
    <link href="http://gelory.me/2016/10/26/Webkit%E5%86%85%E6%A0%B8%E6%98%BE%E7%A4%BA%E5%AD%97%E4%BD%93%E8%87%AA%E5%8A%A8%E6%94%BE%E5%A4%A7%E9%97%AE%E9%A2%98/"/>
    <id>http://gelory.me/2016/10/26/Webkit内核显示字体自动放大问题/</id>
    <published>2016-10-26T09:21:21.000Z</published>
    <updated>2016-10-26T09:23:02.519Z</updated>
    
    <content type="html"><![CDATA[<p>在做移动端页面时，出现了这么个抓狂的问题。明明设置的font-size值为20px，但是computed下的font-size值缺为56px，吓得我看是怀疑人生。<br><a id="more"></a><br>这个东西不是bug也不是hack，是Chromium内核为了提高移动端文本可读性，而增加的一个特性。还有个学名叫<code>Text Autosizer</code> 这个算法呢会根据缩放比例，字体大小，屏幕分辨率等特性，将开发人员设置的字体大小值做一系列运算，然后显示。意思就是：它认为你这样用户会看不清。于是助你一臂之力。</p>
<p>那如何禁用这个特性呢？有人说给文本增加宽高，真是脑洞大。<br>最直接的方法就是设置<br><code>max-height=100%；</code>设置元素的最大宽度。<br>当然你也可以设置viewport元标签内的initial-scale属性为1。initial-scale属性控制页面最初加载时的缩放等级。更多关于元标签的信息可以看我遇到的另一个问题<a href="http://gelory.me/2016/10/26/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%98%BE%E7%A4%BA%E6%97%B6%E9%A1%B5%E9%9D%A2%E7%BC%A9%E6%94%BE%E9%97%AE%E9%A2%98/">移动端显示时页面缩放问题</a>.</p>
<center><div style="border: 2px solid #999;border-top:none;border-left:none;width: 20px;height:20px;transform:rotate(45deg);"></div></center><br><center style="dispaly:block;width:300px;margin:0 auto"><span style="display:inline-block;float:left;width:100px;height:10px;border-top:1px solid #999;margin-top:15px;"></span><span><a href="https://github.com/Gong-Elory" target="_blank" rel="external">龚小样</a></span><span style=" display:inline-block;float:right;width:100px;height:10px;border-top:1px solid #999;margin-top:15px;"></span></center><br><center><span style="font-size:14px;line-height:14px;margin-top:0;">2016-10-26</span></center>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在做移动端页面时，出现了这么个抓狂的问题。明明设置的font-size值为20px，但是computed下的font-size值缺为56px，吓得我看是怀疑人生。&lt;br&gt;
    
    </summary>
    
      <category term="前端" scheme="http://gelory.me/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="http://gelory.me/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="CSS" scheme="http://gelory.me/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>移动端显示时页面缩放问题</title>
    <link href="http://gelory.me/2016/10/26/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%98%BE%E7%A4%BA%E6%97%B6%E9%A1%B5%E9%9D%A2%E7%BC%A9%E6%94%BE%E9%97%AE%E9%A2%98/"/>
    <id>http://gelory.me/2016/10/26/移动端显示时页面缩放问题/</id>
    <published>2016-10-26T08:47:07.000Z</published>
    <updated>2016-10-26T09:23:02.519Z</updated>
    
    <content type="html"><![CDATA[<p>在做简易自适应布局时，出现了一个问题，硬是折磨了我一天。同样是16px的字体，在手机上显示，连放大镜都找不到。此外，横屏的时候，字体又变得出奇的大。试了网上的某些添加属性值方法都不管用。其实问题出在页面身上，字体是无过的。<br><a id="more"></a><br>一个典型的针对移动端优化的站点会包含类似下面的内容。</p>
<p><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><br>width可以是固定值，也可以是device-width这一变量，代表虚拟窗口的宽度。</p>
<p>initial-scale属性控制页面最初加载时的缩放等级。<br>maximum-scale、minimum-scale控制页面最大缩放比例和最小缩放比例。<br>user-scalable属性控制允许用户缩放页面</p>
<p>我当初遇到的问题就是没有设置元标签的内容，导致手机为了适应屏幕宽度，而缩小页面。<br><strong>如果想要保证页面不缩放，可以设置maximum-scale、minimum-scale都为1.</strong><br>user-scalable=no这样设置有的浏览器不保证所有浏览器都会不缩放页面</p>
<center><div style="border: 2px solid #999;border-top:none;border-left:none;width: 20px;height:20px;transform:rotate(45deg);"></div></center><br><center style="dispaly:block;width:300px;margin:0 auto"><span style="display:inline-block;float:left;width:100px;height:10px;border-top:1px solid #999;margin-top:15px;"></span><span><a href="https://github.com/Gong-Elory" target="_blank" rel="external">龚小样</a></span><span style=" display:inline-block;float:right;width:100px;height:10px;border-top:1px solid #999;margin-top:15px;"></span></center><br><center><span style="font-size:14px;line-height:14px;margin-top:0;">2016-10-26</span></center>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在做简易自适应布局时，出现了一个问题，硬是折磨了我一天。同样是16px的字体，在手机上显示，连放大镜都找不到。此外，横屏的时候，字体又变得出奇的大。试了网上的某些添加属性值方法都不管用。其实问题出在页面身上，字体是无过的。&lt;br&gt;
    
    </summary>
    
      <category term="前端" scheme="http://gelory.me/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="http://gelory.me/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="HTML" scheme="http://gelory.me/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>px，em，rem单位的区别与联系</title>
    <link href="http://gelory.me/2016/10/26/px%EF%BC%8Cem%EF%BC%8Crem%E5%8D%95%E4%BD%8D%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E8%81%94%E7%B3%BB/"/>
    <id>http://gelory.me/2016/10/26/px，em，rem单位的区别与联系/</id>
    <published>2016-10-26T08:23:57.000Z</published>
    <updated>2016-10-26T09:08:04.537Z</updated>
    
    <content type="html"><![CDATA[<p>在重构页面时，经常会用到px，em等单位来设置距离，大小。但是用px还好，em时稍不留心，参考大小就弄错了，然后计算出一个错误的距离，还用得不亦乐乎。<br><a id="more"></a><br>px（Pixel）这个单位是相当于显示器的分辨率来说的。</p>
<h2 id="em的特点"><a href="#em的特点" class="headerlink" title="em的特点"></a>em的特点</h2><blockquote>
<ul>
<li>表示字体大小时，是相对其父元素字体大小的倍数而言的。<br>譬如该父元素字体大小为16px，那么1.5em=1.5*16px=24px</li>
<li>在表示距离，宽高的时候，是相对其自身元素字体大小而言的，这个极为重要。<br>譬如父元素字体大小为16px 自身元素字体大小为24px（或者（1.5em）），那么margin-top：2em，这里换算为px值是48px，而不是32px。</li>
</ul>
</blockquote>
<p>任何浏览器的默认字体大小都是16px，那我们每次算像素值，然后用em表示，岂不是相当麻烦。是的，很麻烦。为了简化运算，经常会在body选择器中声明</p>
<pre><code>font-size：62.5%
</code></pre><p>意思是参考值变为原来的.625倍，也就是16*0.625=10px。那么之后在算em就是以这个为基准了。譬如23像素就可以表示为2.3em。</p>
<p>但我还是觉得麻烦啊！每次还要考虑其父元素的大小，考虑自身元素字体大小，操着卖白粉的心啊！<br>是的！ 考虑到这个原因在CSS3中新增了rem这个相对单位。</p>
<h2 id="rem和em的区别"><a href="#rem和em的区别" class="headerlink" title="rem和em的区别"></a>rem和em的区别</h2><p>rem永远相对于根元素，也就是说不需要考虑他的父元素大小了，统一以根元素的字体大小作为基准。此时设置文档根元素html标签的字体</p>
<p>font-size：62.5%</p>
<p>来使1rem 代表 10px。</p>
<p>这个在自适应布局用途非常的广，譬如设计稿给的宽度是640px，此时根元素设置的是20px  那么10rem代表200px，如果想在屏幕宽度为320px的移动端也适用这一套，只需要根据屏幕宽度比去计算在320px下html的字体大小值就行了。不需要去具体改动其他元素的值。</p>
<h2 id="rem的兼容性"><a href="#rem的兼容性" class="headerlink" title="rem的兼容性"></a>rem的兼容性</h2><blockquote>
<ul>
<li>支持 IE9+</li>
</ul>
</blockquote>
<p>IE9/IE10在用于伪元素时或者使用字体简写声明时不支持rem；</p>
<blockquote>
<ul>
<li>支持 FireFox3.5+</li>
<li>支持Chrome 6+</li>
<li>支持 Safari 5+</li>
<li>支持Opera 11.6+</li>
<li>支持IOS Safari 4.1+</li>
</ul>
</blockquote>
<p>IOS Safari5.0-5.1虽然支持rem，但是在使用媒体查询时不支持rem。</p>
<blockquote>
<ul>
<li>支持Android2.1+ 微信页面可能不起作用</li>
</ul>
</blockquote>
<p>如果兼容性不支持，那么就采用px 和rem一起写的方式。</p>
<p>rem和em可以一起用，但是这样不嫌麻烦吗？</p>
<h2 id="小样有话说："><a href="#小样有话说：" class="headerlink" title="小样有话说："></a>小样有话说：</h2><center style="color:green;font-weight: Bold;border:1px dotted #999">能用rem尽量用，不兼容就混合用，迟早是它的天下！</center>

<center><div style="border: 2px solid #999;border-top:none;border-left:none;width: 20px;height:20px;transform:rotate(45deg);"></div></center><br><center style="dispaly:block;width:300px;margin:0 auto"><span style="display:inline-block;float:left;width:100px;height:10px;border-top:1px solid #999;margin-top:15px;"></span><span><a href="https://github.com/Gong-Elory" target="_blank" rel="external">龚小样</a></span><span style=" display:inline-block;float:right;width:100px;height:10px;border-top:1px solid #999;margin-top:15px;"></span></center><br><center><span style="font-size:14px;line-height:14px;margin-top:0;">2016-10-26</span></center>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在重构页面时，经常会用到px，em等单位来设置距离，大小。但是用px还好，em时稍不留心，参考大小就弄错了，然后计算出一个错误的距离，还用得不亦乐乎。&lt;br&gt;
    
    </summary>
    
      <category term="前端" scheme="http://gelory.me/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="http://gelory.me/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="CSS" scheme="http://gelory.me/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>Absolute定位的进一步认识</title>
    <link href="http://gelory.me/2016/10/24/Absolute%E5%AE%9A%E4%BD%8D%E7%9A%84%E8%BF%9B%E4%B8%80%E6%AD%A5%E8%AE%A4%E8%AF%86/"/>
    <id>http://gelory.me/2016/10/24/Absolute定位的进一步认识/</id>
    <published>2016-10-24T09:10:48.000Z</published>
    <updated>2016-10-24T09:12:24.176Z</updated>
    
    <content type="html"><![CDATA[<p>在我印象中，我一直认为absolute是离不开另外一个属性值：relative的。因为这种现象很常见：当我们要使用相对定位是，经常会给父元素设置一个relative属性值，然后给子元素设置一个absolute属性值。然后通过控制子元素top，left等样式来控制子元素的定位。这种使用方法没有错误？但是呢，却没有更好的利用absolute的属性，代码比较冗杂。absolute绝对定位还有很多不为人知的秘密，今天就来扒一扒。<br><a id="more"></a></p>
<h2 id="无依赖的absolute定位"><a href="#无依赖的absolute定位" class="headerlink" title="无依赖的absolute定位"></a>无依赖的absolute定位</h2><p>我们经常会遇到这样的案例：某个标题右上角打上hot标签，或者某个商品图片右上角打上特惠图片。<br>相信很多人第一想法是，先给包容图片和这个标签的父元素设置position属性值为relative，然后设置这个标签的该属性值为absolute，然后通过top和right值去设置相对位置。<br>然而如果知道absolute的无依赖定位后，你就不需要给父元素设置position值，不用top，right值去位置。<br>那怎么做呢？<br>我们只设置</p>
<pre><code>&lt;span class=&quot;biaoqian&quot; style=&quot;position:absolute;margin-left:-30px&quot;&gt;&lt;/span&gt;
</code></pre><p>类似这样的形式即可实现上述功能。原因是，当给某元素设置absolute后，他在屏幕中的位置是不变的，只不过宽高没有了，不存在于文档流中了。所以，如果这个标签放在图片的后面，absolute之后，位置依然在图片之后。想要把他移到图片上，只需给一个margin-left负值即可。</p>
<p>采用Relative遵循两个原则：</p>
<blockquote>
<ul>
<li>能不用就不用</li>
<li>要用尽量范围涉及小</li>
</ul>
</blockquote>
<h2 id="absolute定位的对宽高的替代性"><a href="#absolute定位的对宽高的替代性" class="headerlink" title="absolute定位的对宽高的替代性"></a>absolute定位的对宽高的替代性</h2><p>经常我们需要某元素能够自适应宽高其父元素？我们除了用width，height的100%外加top=0来实现外，还可以利用top，right，bottom，left同时为0时来显示。</p>
<h2 id="absolute定位对fixed定位的替代性"><a href="#absolute定位对fixed定位的替代性" class="headerlink" title="absolute定位对fixed定位的替代性"></a>absolute定位对fixed定位的替代性</h2><p>在整体布局时，尤其是为了适应移动端，经常会使用fixed来定位header和footer。除了可以用fixed定位外，absolute同样也适用。</p>
<pre><code>html body{
    width:100%;
    height:100%
}

header,footer{
display:absolute;
right:0;
lrft:0;
width:50px;
}

.content{
display:absolute;
top:50px;
bottom:50px;
overflow:auto;
}
</code></pre><p>这样就ok了。</p>
<h2 id="absolute与宽高百分比的合作性"><a href="#absolute与宽高百分比的合作性" class="headerlink" title="absolute与宽高百分比的合作性"></a>absolute与宽高百分比的合作性</h2><p>当我们同时设置top，right，bottom，left为0，设置width=50%时，此时改元素的宽度是50%。<br>那此时right，left岂不是打酱油了？没有。合作性在此处体现：<br>当满足上面条件的同时，在加上margin：auto，会产生绝对定位元素水平居中的效果。次特性支持IE8+。</p>
<center><div style="border: 2px solid #999;border-top:none;border-left:none;width: 20px;height:20px;transform:rotate(45deg);"></div></center><br><center style="dispaly:block;width:300px;margin:0 auto"><span style="display:inline-block;float:left;width:100px;height:10px;border-top:1px solid #999;margin-top:15px;"></span><span><a href="https://github.com/Gong-Elory" target="_blank" rel="external">龚小样</a></span><span style=" display:inline-block;float:right;width:100px;height:10px;border-top:1px solid #999;margin-top:15px;"></span></center><br><center><span style="font-size:14px;line-height:14px;margin-top:0;">2016-10-24</span></center>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在我印象中，我一直认为absolute是离不开另外一个属性值：relative的。因为这种现象很常见：当我们要使用相对定位是，经常会给父元素设置一个relative属性值，然后给子元素设置一个absolute属性值。然后通过控制子元素top，left等样式来控制子元素的定位。这种使用方法没有错误？但是呢，却没有更好的利用absolute的属性，代码比较冗杂。absolute绝对定位还有很多不为人知的秘密，今天就来扒一扒。&lt;br&gt;
    
    </summary>
    
      <category term="前端" scheme="http://gelory.me/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="http://gelory.me/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="CSS" scheme="http://gelory.me/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>外边距塌陷相关问题的解决方案</title>
    <link href="http://gelory.me/2016/10/23/%E5%A4%96%E8%BE%B9%E8%B7%9D%E5%A1%8C%E9%99%B7%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>http://gelory.me/2016/10/23/外边距塌陷相关问题的解决方案/</id>
    <published>2016-10-23T04:34:53.000Z</published>
    <updated>2016-10-23T04:38:31.139Z</updated>
    
    <content type="html"><![CDATA[<p>最近，在写代码时发现了这样一个问题。两个div元素的间距为0，我想为下面一个div元素的第一个子元素添加一个上外边距，结果该距离直接转化成了两个div元素的距离，于是只能用改变这个子元素的内边距去达到这个效果。后来知道这种现象又有个学名叫<code>外边距塌陷</code>.<br><a id="more"></a><br><code>外边距塌陷（margin collapse）</code>：块元素的外边距有时候会发生合并为单个外边距的现象，就称为外边距塌陷。</p>
<p>这个现象发生的原因是因为：按照规范，一个盒子没有padding-top和border-top，那么这个盒子的上边距会和其内部文档流中的第一个子元素的上边距重叠。</p>
<p>这种现象有多种表现形式（)：<br>1.块级父元素（该元素没有设置border，paddding，清除浮动属性时） 和第一个子元素的margin-top合并。<br>解决方法：</p>
<blockquote>
<ul>
<li>设置border padding值。</li>
<li>在第一个子元素与父元素之间添加一个空块，并设置padding值</li>
<li>给父元素设置overflow：hidden；</li>
<li>给内层或者外层div设置float，float:left;</li>
<li>给内层或者外层设置position，position:absolute;</li>
</ul>
</blockquote>
<p>2.块级父元素（该元素没有<code>height</code>，border，paddding，清除浮动属性时），与其最后一个子元素的margin-bottom也会产生这种现象。<br>解决方法同上。</p>
<p>3.两相邻兄弟元素（没限制条件）<br>前一个兄弟元素的下边距会和下一个兄弟元素的上边距重合，选最大的显示。譬如前者下边距是30px后者上边距是40px，最终两元素的间距是40px。<br>解决方法：</p>
<blockquote>
<ul>
<li>设置一个元素的边距值就行了。</li>
</ul>
</blockquote>
<p>4.空块元素的上下边距合并 该元素没有设置border，padding，height相关属性时。<br>解决方法：</p>
<blockquote>
<ul>
<li>设置border，padding，height相关属性时。</li>
</ul>
</blockquote>
<h2 id="小样有话说："><a href="#小样有话说：" class="headerlink" title="小样有话说："></a>小样有话说：</h2><center style="color:green;font-weight: Bold;border:1px dotted #999">这个现象很常见，总算是弄明白原因了。</center>

<center><div style="border: 2px solid #999;border-top:none;border-left:none;width: 20px;height:20px;transform:rotate(45deg);"></div></center><br><center style="dispaly:block;width:300px;margin:0 auto"><span style="display:inline-block;float:left;width:100px;height:10px;border-top:1px solid #999;margin-top:15px;"></span><span><a href="https://github.com/Gong-Elory" target="_blank" rel="external">龚小样</a></span><span style=" display:inline-block;float:right;width:100px;height:10px;border-top:1px solid #999;margin-top:15px;"></span></center><br><center><span style="font-size:14px;line-height:14px;margin-top:0;">2016-10-23</span></center>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近，在写代码时发现了这样一个问题。两个div元素的间距为0，我想为下面一个div元素的第一个子元素添加一个上外边距，结果该距离直接转化成了两个div元素的距离，于是只能用改变这个子元素的内边距去达到这个效果。后来知道这种现象又有个学名叫&lt;code&gt;外边距塌陷&lt;/code&gt;.&lt;br&gt;
    
    </summary>
    
      <category term="前端" scheme="http://gelory.me/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="http://gelory.me/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="CSS" scheme="http://gelory.me/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>inline-block元素之间间隙的去除法</title>
    <link href="http://gelory.me/2016/10/20/inline-block%E5%85%83%E7%B4%A0%E4%B9%8B%E9%97%B4%E9%97%B4%E9%9A%99%E7%9A%84%E5%8E%BB%E9%99%A4%E6%B3%95/"/>
    <id>http://gelory.me/2016/10/20/inline-block元素之间间隙的去除法/</id>
    <published>2016-10-20T06:57:01.000Z</published>
    <updated>2016-10-20T07:05:24.546Z</updated>
    
    <content type="html"><![CDATA[<p>inline-block元素，或者属性被设置为inline-block的元素。会出现一个问题：当水平显示的时候，两个inline-block元素间会有间隙。这个不是bug，是这个属性应有的表现。当时作为开发者来说，显得有些多余，我们要想尽方法来去除这个间隙。<br><a id="more"></a><br>之前看过一个教Psd重构Html的视频,里面说这种方法很常用，那么首先就说这种方法：</p>
<h2 id="font-size-0去除法"><a href="#font-size-0去除法" class="headerlink" title="font-size:0去除法"></a>font-size:0去除法</h2><p>做法是将父元素的font-size属性值设置为0，<br><strong>然后</strong>将父元素里面的子元素设置它应有的字体大小。</p>
<h2 id="不过听说这个方法在手机上行不通啊！兼容性最好的方法是消灭空格法，见下。"><a href="#不过听说这个方法在手机上行不通啊！兼容性最好的方法是消灭空格法，见下。" class="headerlink" title="不过听说这个方法在手机上行不通啊！兼容性最好的方法是消灭空格法，见下。"></a>不过听说这个方法在手机上行不通啊！兼容性最好的方法是消灭空格法，见下。</h2><p>第二个方法是在学习HTML5+CSS3视频的时候，老师演示的方法。我猜两inline-block之间的间隙应该与在HTML文档书写时换行有关。</p>
<h2 id="消灭空格法"><a href="#消灭空格法" class="headerlink" title="消灭空格法"></a>消灭空格法</h2><p>这个方法的好处就是不要设置样式值，把HTML书写的格式修改一下即可。<br>例如，原本排列的很整齐的两个元素</p>
<pre><code>&lt;span style=&quot;display:inline-block;width:50px;height:90px;&quot;&gt;第一个&lt;/span&gt;
&lt;span style=&quot;display:inline-block;width:50px;height:90px;&quot;&gt;第er个&lt;/span&gt;
</code></pre><p>把第二行的起始标签写在第一行终止标签后：</p>
<pre><code>&lt;span style=&quot;display:inline-block;width:50px;height:90px;&quot;&gt;第一个&lt;/span&gt;&lt;span style=&quot;display:inline-block;width:50px;height:90px;&quot;&gt;第er个&lt;/span&gt;
</code></pre><p>但是有没有发现，如果行数多了，这样写，别人来读你的代码岂不是一种折磨？我发现只要让两个标签中间没空格就行。可以这样做。</p>
<pre><code>&lt;span style=&quot;display:inline-block;width:50px;height:90px&quot;&gt;第一个&lt;/span&gt;&lt;!--
--&gt;&lt;span style=&quot;display:inline-block;width:50px;height:90px;&quot;&gt;第er个&lt;/span&gt;
</code></pre><p>我们用一个注释符号充当链接符，占据他们之间的空格。当然只要你能想法把两个元素之间的空格去掉就行。你要问我，啥是元素？<a href="http://gelory.me/2016/10/19/%E5%B1%9E%E6%80%A7%EF%BC%8C%E6%A0%B7%E5%BC%8F%EF%BC%8C%E6%A0%87%E7%AD%BE%EF%BC%8C%E5%85%83%E7%B4%A0%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E8%81%94%E7%B3%BB/">属性，样式，标签，元素的区别与联系</a>这篇文章给你一个好的解释。</p>
<hr>
<p>第三个方法有点死，就是当你发现空格后，利用浏览器的审查元素，定位元素后，给后面的元素设置margin-left为负数。</p>
<h2 id="设置margin法"><a href="#设置margin法" class="headerlink" title="设置margin法"></a>设置margin法</h2><p>这个方法没什么说的，对着浏览器，找到一个合适值就行。不过这个方法有点尴尬，要设置的多了，你是不是就麻木了，解决方法就是设置一个<code>公共样式</code>处理该类问题吧！</p>
<hr>
<h2 id="还有其他方法："><a href="#还有其他方法：" class="headerlink" title="还有其他方法："></a>还有其他方法：</h2><blockquote>
<ul>
<li>譬如设置父元素 dispaly:table，设置子元素为table-cell。</li>
<li>设置父元素letter-spacing为一个负值，设置子元素为0。</li>
<li>word-spacing类似。</li>
<li>还有，用js去解决。</li>
</ul>
</blockquote>
<center><div style="border: 2px solid #999;border-top:none;border-left:none;width: 20px;height:20px;transform:rotate(45deg);"></div></center><br><center style="dispaly:block;width:300px;margin:0 auto"><span style="display:inline-block;float:left;width:100px;height:10px;border-top:1px solid #999;margin-top:15px;"></span><span><a href="https://github.com/Gong-Elory" target="_blank" rel="external">龚小样</a></span><span style=" display:inline-block;float:right;width:100px;height:10px;border-top:1px solid #999;margin-top:15px;"></span></center><br><center><span style="font-size:14px;line-height:14px;margin-top:0;">2016-10-20</span></center>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;inline-block元素，或者属性被设置为inline-block的元素。会出现一个问题：当水平显示的时候，两个inline-block元素间会有间隙。这个不是bug，是这个属性应有的表现。当时作为开发者来说，显得有些多余，我们要想尽方法来去除这个间隙。&lt;br&gt;
    
    </summary>
    
      <category term="前端" scheme="http://gelory.me/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="http://gelory.me/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="CSS" scheme="http://gelory.me/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>FlexBox布局使用介绍</title>
    <link href="http://gelory.me/2016/10/19/FlexBox%E5%B8%83%E5%B1%80%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D/"/>
    <id>http://gelory.me/2016/10/19/FlexBox布局使用介绍/</id>
    <published>2016-10-19T09:03:42.000Z</published>
    <updated>2016-10-20T07:07:50.874Z</updated>
    
    <content type="html"><![CDATA[<p>之前在做垂直居中时，无论是采用三重定位法，还是采用表格布局法。<a href="http://gelory.me/2016/10/09/%E9%AB%98%E5%BA%A6%E4%B8%8D%E5%AE%9A%E7%9A%84%E5%AD%90%E5%85%83%E7%B4%A0%E5%9C%A8%E9%AB%98%E5%BA%A6%E4%B8%8D%E5%AE%9A%E7%9A%84%E7%88%B6%E5%85%83%E7%B4%A0%E4%B8%AD%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E9%97%AE%E9%A2%98/">高度不定的子元素在高度不定的父元素中垂直居中</a>都感觉好复杂啊，难道就没有简单的方法吗？就在昨天看教程时，学到了FlexBox布局，垂直居中，小case啦。<br><a id="more"></a></p>
<h2 id="FlexBox布局"><a href="#FlexBox布局" class="headerlink" title="FlexBox布局"></a>FlexBox布局</h2><p>为盒状模型提供更大的灵活度。<br>设置Flex布局后，子元素的float，clear，vertical-align属性失效</p>
<h3 id="有六个属性设置在容器上"><a href="#有六个属性设置在容器上" class="headerlink" title="有六个属性设置在容器上"></a>有六个属性设置在容器上</h3><p>1.flex-direction 决定是横向排列还是纵向排列</p>
<blockquote>
<ul>
<li>row（默认值）：从左到右 水平分布。</li>
<li>row-reverse：从右到左，水平分布。</li>
<li>column：从上到下，垂直分布。</li>
<li>column-reverse：从下到上，垂直分布。</li>
</ul>
</blockquote>
<p>2.flex-wrap 决定超出宽度/高度界限之后是否换行</p>
<blockquote>
<ul>
<li>nowrap 不换行。</li>
<li>wrap：换行，第一行在上。</li>
<li>wrap-reverse：换行，第一行在下。</li>
</ul>
</blockquote>
<p>3.flex-flow 将上面两项合并 默认 row nowrap</p>
<p>4.justify-content 水平对齐方式</p>
<blockquote>
<ul>
<li>flex-start 水平起点对齐（起终点取决于flex-direction）</li>
<li>flex-end 水平终点对齐</li>
<li>center 水平居中</li>
<li>space-between 两端对齐</li>
<li>space-around 项目两侧间隔相等间隔相等</li>
</ul>
</blockquote>
<p>5.align-items 垂直对齐方式</p>
<blockquote>
<ul>
<li>flex-start 纵向起点对齐</li>
<li>flex-end 纵向终点对齐</li>
<li>center 垂直居中</li>
<li>baseline 项目第一行的文字对齐</li>
<li>stretch 如果项目未设置高端或者设置为auto，默认占满</li>
</ul>
</blockquote>
<p>6.align-content 定义多行的垂直对齐方式</p>
<blockquote>
<ul>
<li>stretch（默认）：垂直填满拉伸</li>
<li>flex-start：纵向起点对齐。</li>
<li>flex-end：纵向终点对齐</li>
<li>center：整体垂直居中</li>
<li>space-between：上下对齐</li>
<li>space-around：上下间隔相等</li>
</ul>
</blockquote>
<h3 id="有六个属性设置在容器中的项目上"><a href="#有六个属性设置在容器中的项目上" class="headerlink" title="有六个属性设置在容器中的项目上"></a>有六个属性设置在容器中的项目上</h3><p>1.order 项目排列顺序<br>数值越小越靠前</p>
<p>2.flex-grow 放大比例，默认0，意思是即使有多的空间，项目也不放大。<br>如果为每个项目设置了该值，那么放大的比例为<br><code>（该项目值/所有项目总和值）*剩余空间值</code></p>
<p>3.flex-shrink 缩小比例，默认为1，意思是空间不足时，默认等比例缩小。设置为0则不缩。</p>
<p>4.flex-basis 项目在不缩不放之前本来的占据空间 水平排列的话指宽度，垂直排列的话指高度。<br>不设置的话，默认根据内容显示。如果以百分数形式显示，指的是占父元素宽/高的比例。</p>
<p>5.flex 集合上面的三种属性flex-grow flex-shrink flex-basis 后面两种属性可要可不要，也就是说只有一个值时，指的是flex-grow.<br>有三个快捷值：</p>
<blockquote>
<ul>
<li>auto（1 1 auto）</li>
<li>none（0 0 auto）</li>
<li>initial（0 1 auto）</li>
</ul>
</blockquote>
<p>6.align-self 设置单个项目的对齐方式 默认auto继承父元素的align-items属性。</p>
<h2 id="小样有歌唱-双语Lemon-Tree-："><a href="#小样有歌唱-双语Lemon-Tree-：" class="headerlink" title="小样有歌唱(双语Lemon Tree)："></a>小样有歌唱(双语Lemon Tree)：</h2><center><audio src="http://oeqcvcrxo.bkt.clouddn.com/%E6%96%B0%E5%BD%95%E9%9F%B3%205-1.m4a" controls="controls">您的浏览器不支持 audio 标签。</audio></center>

<center><div style="border: 2px solid #999;border-top:none;border-left:none;width: 20px;height:20px;transform:rotate(45deg);"></div></center><br><center style="dispaly:block;width:300px;margin:0 auto"><span style="display:inline-block;float:left;width:100px;height:10px;border-top:1px solid #999;margin-top:15px;"></span><span><a href="https://github.com/Gong-Elory" target="_blank" rel="external">龚小样</a></span><span style=" display:inline-block;float:right;width:100px;height:10px;border-top:1px solid #999;margin-top:15px;"></span></center><br><center><span style="font-size:14px;line-height:14px;margin-top:0;">2016-10-19</span></center>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前在做垂直居中时，无论是采用三重定位法，还是采用表格布局法。&lt;a href=&quot;http://gelory.me/2016/10/09/%E9%AB%98%E5%BA%A6%E4%B8%8D%E5%AE%9A%E7%9A%84%E5%AD%90%E5%85%83%E7%B4%A0%E5%9C%A8%E9%AB%98%E5%BA%A6%E4%B8%8D%E5%AE%9A%E7%9A%84%E7%88%B6%E5%85%83%E7%B4%A0%E4%B8%AD%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E9%97%AE%E9%A2%98/&quot;&gt;高度不定的子元素在高度不定的父元素中垂直居中&lt;/a&gt;都感觉好复杂啊，难道就没有简单的方法吗？就在昨天看教程时，学到了FlexBox布局，垂直居中，小case啦。&lt;br&gt;
    
    </summary>
    
      <category term="前端" scheme="http://gelory.me/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="http://gelory.me/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="CSS" scheme="http://gelory.me/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>伪元素与伪类，单冒号选择器和双冒号的区别与联系</title>
    <link href="http://gelory.me/2016/10/19/%E4%BC%AA%E5%85%83%E7%B4%A0%E4%B8%8E%E4%BC%AA%E7%B1%BB%EF%BC%8C%E5%8D%95%E5%86%92%E5%8F%B7%E9%80%89%E6%8B%A9%E5%99%A8%E5%92%8C%E5%8F%8C%E5%86%92%E5%8F%B7%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E8%81%94%E7%B3%BB/"/>
    <id>http://gelory.me/2016/10/19/伪元素与伪类，单冒号选择器和双冒号的区别与联系/</id>
    <published>2016-10-19T06:16:10.000Z</published>
    <updated>2016-10-20T07:05:56.123Z</updated>
    
    <content type="html"><![CDATA[<p>最近学习HTML5+CSS3时，看到一个现象,在使用<code>::selection</code>伪元素时，为什么使用两个冒号，如此奇特啊，平时看见的都只有一个冒号啊？它是皇亲国戚吗，竟有如此特权？在探究这个问题的时候，突然发现要我具体定义伪类和伪元素，我还真不知道怎么去解释，于是顺带把这个问题也解决一下。<br><a id="more"></a></p>
<h2 id="伪类"><a href="#伪类" class="headerlink" title="伪类"></a>伪类</h2><blockquote>
<p>CSS 伪类用于向某些选择器添加特殊的效果。</p>
</blockquote>
<h2 id="伪元素"><a href="#伪元素" class="headerlink" title="伪元素"></a>伪元素</h2><blockquote>
<p>CSS 伪元素用于向某些选择器设置特殊的效果。</p>
</blockquote>
<p>上面是W3C教程给的定义。不仔细看，你跟本没发现就两个字的差别，<code>添加</code>和<code>设置</code>。十分惊讶，这有什么区别吗？</p>
<p>看来我中文理解能力还不够啊！我索性跳过他给的定义，从实际运用中招区别。</p>
<p>伪类，常见的伪类有这些</p>
<pre><code>:active    向被激活的元素添加样式。
:focus    向拥有键盘输入焦点的元素添加样式。
:hover    当鼠标悬浮在元素上方时，向元素添加样式。
:link    向未被访问的链接添加样式。
:visited    向已被访问的链接添加样式。
:first-child    向元素的第一个子元素添加样式。
:lang 向带有指定 lang 属性的元素添加样式。
</code></pre><p>怎么用的呢？</p>
<pre><code>&lt;ul&gt;
&lt;li&gt;Intert Key&lt;/li&gt;
&lt;li&gt;Turn key &lt;strong&gt;clockwise&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Push accelerator&lt;/li&gt;
&lt;/ul&gt;
</code></pre><p>我想让第一个li标签的内容变绿，我就这样 <code>ul:first-child</code>指定第一个元素。</p>
<p>伪元素，常见的伪元素有这些</p>
<pre><code>:first-letter    向文本的第一个字母添加特殊样式。
:first-line    向文本的首行添加特殊样式。
:before    在元素之前添加内容。
:after    在元素之后添加内容。
</code></pre><p>怎么用？</p>
<pre><code>&lt;ul&gt;
&lt;li class=&quot;la&quot;&gt;Intert Key&lt;/li&gt;
&lt;li&gt;Turn key &lt;strong&gt;clockwise&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Push accelerator&lt;/li&gt;
&lt;/ul&gt;
</code></pre><p>我想让la类的首字母变绿，我就这样指定这个首字母。 <code>.la:first-letter</code><br>发现没有，<strong>伪类选择的是整个元素，而伪元素选择的是元素内容。</strong>你要问我元素和元素内容有什么区别？看我这篇文章：<a href="http://gelory.me/2016/10/19/little-tip3/">属性，样式，标签，元素的区别与联系</a>.</p>
<h2 id="说说单冒号与双冒号"><a href="#说说单冒号与双冒号" class="headerlink" title="说说单冒号与双冒号"></a>说说单冒号与双冒号</h2><p>刚才说到<code>::selection,它属于伪元素选择器。它的作用是设置被选择的文本的样式</code>。譬如用光标选中某一段文字后，默认显示的是蓝背景白字，你就可以把它改变为黑背景，绿字。</p>
<blockquote>
<p>那为什么同样是伪元素，差别这么大呢？</p>
<p>原来，::selection是css3新增加的伪元素，为了把伪类和伪元素区别开，从CSS3开始，伪类使用单冒号，伪元素使用双冒号。但是，由于考虑向下兼容的问题，在CSS3之前的那些伪元素，保留原来单冒号的写法。所以:after与::after没啥区别。</p>
</blockquote>
<p>那么我们在用的时候，如果要考虑所有浏览器的兼容性，还是使用单冒号来带伪元素，如果不需要考虑IE浏览器，那我们还是统一用双冒号来带伪元素。</p>
<h2 id="小样有话说："><a href="#小样有话说：" class="headerlink" title="小样有话说："></a>小样有话说：</h2><center><audio src="http://oeqcvcrxo.bkt.clouddn.com/%E6%96%B0%E5%BD%95%E9%9F%B3%202-1.m4a" controls="controls">您的浏览器不支持 audio 标签。</audio></center>

<center><div style="border: 2px solid #999;border-top:none;border-left:none;width: 20px;height:20px;transform:rotate(45deg);"></div></center><br><center style="dispaly:block;width:300px;margin:0 auto"><span style="display:inline-block;float:left;width:100px;height:10px;border-top:1px solid #999;margin-top:15px;"></span><span><a href="https://github.com/Gong-Elory" target="_blank" rel="external">龚小样</a></span><span style=" display:inline-block;float:right;width:100px;height:10px;border-top:1px solid #999;margin-top:15px;"></span></center><br><center><span style="font-size:14px;line-height:14px;margin-top:0;">2016-10-19</span></center>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近学习HTML5+CSS3时，看到一个现象,在使用&lt;code&gt;::selection&lt;/code&gt;伪元素时，为什么使用两个冒号，如此奇特啊，平时看见的都只有一个冒号啊？它是皇亲国戚吗，竟有如此特权？在探究这个问题的时候，突然发现要我具体定义伪类和伪元素，我还真不知道怎么去解释，于是顺带把这个问题也解决一下。&lt;br&gt;
    
    </summary>
    
      <category term="前端" scheme="http://gelory.me/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="http://gelory.me/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="CSS" scheme="http://gelory.me/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>属性，样式，标签，元素的区别与联系</title>
    <link href="http://gelory.me/2016/10/19/%E5%B1%9E%E6%80%A7%EF%BC%8C%E6%A0%B7%E5%BC%8F%EF%BC%8C%E6%A0%87%E7%AD%BE%EF%BC%8C%E5%85%83%E7%B4%A0%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E8%81%94%E7%B3%BB/"/>
    <id>http://gelory.me/2016/10/19/属性，样式，标签，元素的区别与联系/</id>
    <published>2016-10-19T01:43:59.000Z</published>
    <updated>2016-10-20T07:05:49.972Z</updated>
    
    <content type="html"><![CDATA[<p>今天在网易云课堂看某HTML5+CSS3教程，我突然想到一个问题，我们张口闭口所说的标签，元素具体代表的是什么?感觉一直都是模糊的。这篇文章具体的讲述这几个名词的区别与联系。</p>
<a id="more"></a>
<h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><blockquote>
<p><strong>对内容进行标记的符号</strong></p>
</blockquote>
<h3 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h3><pre><code>&lt;p&gt;&lt;/p&gt;  &lt;!-- 这就是一个标签 --&gt;
&lt;div&gt;&lt;p&gt;&lt;/p&gt;&lt;/div&gt;  &lt;!-- 这有两个标签 --&gt;
&lt;br /&gt; &lt;!-- 这也是一个标签 --&gt;
</code></pre><h2 id="元素"><a href="#元素" class="headerlink" title="元素"></a>元素</h2><blockquote>
<p><strong>元素以开始标签起，结束标签终，包含标签及其中的内容。</strong> </p>
</blockquote>
<h3 id="举个例子-1"><a href="#举个例子-1" class="headerlink" title="举个例子"></a>举个例子</h3><pre><code>&lt;p&gt;我很帅&lt;/p&gt;  &lt;!-- 这就是一个元素 --&gt;
&lt;div&gt;&lt;p&gt;我很帅&lt;/p&gt;&lt;div&gt;  &lt;!-- 这有两个元素 --&gt;
&lt;br /&gt; &lt;!-- 这是一个空元素 --&gt;
</code></pre><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><blockquote>
<p><strong>属性为元素提供更多的信息,总是以 name=“value” 出现</strong></p>
</blockquote>
<h3 id="举个例子-2"><a href="#举个例子-2" class="headerlink" title="举个例子"></a>举个例子</h3><pre><code>&lt;p class=&quot;handsome&quot;&gt;帅哥&lt;/p&gt; &lt;!-- class=&quot;handsome&quot;就是一个属性 --&gt;
</code></pre><h2 id="样式"><a href="#样式" class="headerlink" title="样式"></a>样式</h2><blockquote>
<p><strong> 存在于style属性内，用于改变元素内容的键值对，总是以 key：value 出现</strong></p>
</blockquote>
<h3 id="举个例子-3"><a href="#举个例子-3" class="headerlink" title="举个例子"></a>举个例子</h3><pre><code>&lt;p style={font-size:12px;}&gt;帅哥&lt;/p&gt;  &lt;!-- font-size:12px 就是一个样式 --&gt;
</code></pre><h3 id="属性和样式的区别与联系"><a href="#属性和样式的区别与联系" class="headerlink" title="属性和样式的区别与联系"></a>属性和样式的区别与联系</h3><p>样式大多表现在对元素内容外观的改变，譬如字体颜色是否居中，而属性大多表现在为元素定义其他的特点，譬如定义一个class，定义一个id，设置value值等。</p>
<blockquote>
<p>那有人要问了：align bgcolor color这些都是属性，为什么他们也可以定义颜色，居中？</p>
<p>没错，这些都是属性，此外，能改变元素内容外观的还有部分标签，譬如<center> <u>。但是这些东西在HTML4种已经被废弃了，他们被建议用样式代替，可以看出，样式正在慢慢统一这些规则。</u></center></p>
</blockquote>
<h2 id="小样有话说："><a href="#小样有话说：" class="headerlink" title="小样有话说："></a>小样有话说：</h2><center><audio src="http://oeqcvcrxo.bkt.clouddn.com/xyone.m4a" controls="controls">您的浏览器不支持 audio 标签。</audio></center>

<center><div style="border: 2px solid #999;border-top:none;border-left:none;width: 20px;height:20px;transform:rotate(45deg);"></div></center><br><center style="dispaly:block;width:300px;margin:0 auto"><span style="display:inline-block;float:left;width:100px;height:10px;border-top:1px solid #999;margin-top:15px;"></span><span><a href="https://github.com/Gong-Elory" target="_blank" rel="external">龚小样</a></span><span style=" display:inline-block;float:right;width:100px;height:10px;border-top:1px solid #999;margin-top:15px;"></span></center><br><center><span style="font-size:14px;line-height:14px;margin-top:0;">2016-10-19</span></center>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天在网易云课堂看某HTML5+CSS3教程，我突然想到一个问题，我们张口闭口所说的标签，元素具体代表的是什么?感觉一直都是模糊的。这篇文章具体的讲述这几个名词的区别与联系。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://gelory.me/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="http://gelory.me/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="CSS" scheme="http://gelory.me/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>Z-index与Stacking Context的那些坑</title>
    <link href="http://gelory.me/2016/10/15/Z-index%E4%B8%8EStacking%20Context%E7%9A%84%E9%82%A3%E4%BA%9B%E5%9D%91/"/>
    <id>http://gelory.me/2016/10/15/Z-index与Stacking Context的那些坑/</id>
    <published>2016-10-15T05:54:30.000Z</published>
    <updated>2016-10-20T07:05:40.604Z</updated>
    
    <content type="html"><![CDATA[<center>Z-index的罪与罚，噗！手动喷血</center>

 <a id="more"></a>
<h2 id="Z-index的黄金准则两条："><a href="#Z-index的黄金准则两条：" class="headerlink" title="Z-index的黄金准则两条："></a>Z-index的黄金准则两条：</h2><blockquote>
<ul>
<li>Z-index值谁大谁在上</li>
<li>层叠水平，层叠顺序相同时，谁后来谁在上</li>
</ul>
</blockquote>
<h2 id="层叠顺序"><a href="#层叠顺序" class="headerlink" title="层叠顺序"></a>层叠顺序</h2><p>先来了解层叠顺序，所谓的层叠顺序就是：两个元素，谁在上谁在下的问题。</p>
<h3 id="元素系列"><a href="#元素系列" class="headerlink" title="元素系列"></a>元素系列</h3><blockquote>
<ul>
<li>两个元素为正常流时，默认情况是后一个元素覆盖前面一个元素。并且允许后面的元素透上来。</li>
<li>如果两个都是块级元素，文字比背景层级高（因此不管是否设置背景，文字始终会透上来）</li>
<li>如果是行内元素或者行内-块状元素，背景比文字层级高。（因此只要设置了背景，后面元素将透不上来）</li>
</ul>
</blockquote>
<h3 id="浮动系列"><a href="#浮动系列" class="headerlink" title="浮动系列"></a>浮动系列</h3><blockquote>
<ul>
<li>浮动和浮动 后来居上</li>
<li>浮动和块状元素 浮动层级高</li>
<li>浮动和行内块，行内元素 行内块 行内元素层级高</li>
</ul>
</blockquote>
<h3 id="定位系列"><a href="#定位系列" class="headerlink" title="定位系列"></a>定位系列</h3><blockquote>
<ul>
<li>绝对定位和绝对定位 后来居上</li>
<li>绝对定位和相对定位 后来居上</li>
<li>绝对定位和规定定位 后来居上</li>
<li>固定定位和相对定位 后来居上</li>
<li>绝对定位和块元素，行内元素，行内块元素，绝对定位层级高</li>
<li>绝对定位等其他定位效果和浮动元素， 前者高</li>
</ul>
</blockquote>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote>
<ul>
<li>类型相同，后来居上</li>
<li>块元素和定位元素以外的其他元素，文字层级比背景层级高。</li>
<li>浮动和块元素 浮动元素层级高</li>
<li>浮动和行内快，行内元素  后者高</li>
<li>定位比所有元素层级高 </li>
</ul>
</blockquote>
<h2 id="Z-index的家事"><a href="#Z-index的家事" class="headerlink" title="Z-index的家事"></a>Z-index的家事</h2><blockquote>
<ul>
<li>Z-index只能工作在明确定义了定位属性为absolute fixed relative的元素中</li>
<li>Z-index相同的话，后来居上</li>
<li>父元素Z-index有效，子元素无论是否设置都与父元素保持一致。在父元素上方，即使子元素Z-index比父元素小，也在上方。</li>
<li>如果父元素Z-index失效，子元素设置就生效，这样就可以让子元素在父元素下面了。</li>
<li>兄弟父元素之间，父元素Z-index决定其子元素的地位，父元素Z-index低，即使子元素很高，也会跟着他的父元素一起，被压在其他<code>父元素Z-index高，子元素Z-index低的</code>元素底下。</li>
</ul>
</blockquote>
<h2 id="层叠上下文stacking-context"><a href="#层叠上下文stacking-context" class="headerlink" title="层叠上下文stacking context"></a>层叠上下文stacking context</h2><h3 id="产生层叠上下文的条件"><a href="#产生层叠上下文的条件" class="headerlink" title="产生层叠上下文的条件"></a>产生层叠上下文的条件</h3><blockquote>
<ul>
<li>根元素 HTML标签</li>
<li>绝对或者相对定位并且Z-index值不为auto</li>
<li>一个伸缩项目 Flex Item，且Z-index值不为auto，即父元素：display: flex|inline-flex</li>
<li>元素的opacity值小于1</li>
<li>元素的transform值不为none</li>
<li>元素的mix-blend-mode值不为normal</li>
<li>元素的filter值不为normal</li>
<li>元素的isolation值不为isolate</li>
<li>position：fixed</li>
<li>will-change中指定了上述任意属性，几遍没有直接定义这些属性</li>
<li>元素的-webkit-overflow-scrolling 属性值为 touch</li>
</ul>
</blockquote>
<h3 id="opacity可以产生层叠上下文"><a href="#opacity可以产生层叠上下文" class="headerlink" title="opacity可以产生层叠上下文"></a>opacity可以产生层叠上下文</h3><blockquote>
<p>兄弟层叠上下文的子元素无论Z-index有多大，都不会对排序产生影响，按照后来居上的原则进行排列。<br>举一个板栗：<br>a的父元素A<br>b的父元素B<br>c的父元素C</p>
<ul>
<li><p>如果A,B,C都产生了层叠上下文，假设都是用opacity产生的。那么无论a的index是10000也好还是1也好，他都被盖在b，c底下，遵循的后来居上原则</p>
</li>
<li><p>如果A,B生成了层叠上下文，假设都是用opacity产生的。小c（C的子元素）也产生了层叠上下文。那么现在A,B,小c是同级的了。只要c的index不是0或者负数， auto。那么c一定在上面。如果A,B的层叠上下文不是由opacity生成的  只要他们的index比小c大，谁就在上层。</p>
</li>
</ul>
</blockquote>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><blockquote>
<ul>
<li><p>父元素都是层叠上下文元素，那么与子元素的Z-index无关，与本身Z-index有关。如果父元素没有设置Z-index属性，或者相同。按照DOM流顺序，后来居上。如果设置了且不同，就按照Z-index大小排序。</p>
</li>
<li><p>如果某子元素是层叠上下文，其父元素不是，但是父元素的兄弟元素是。那么该子元素自动升级，和其父元素的兄弟元素同级，进行Z-index比较，此时参考第一条。</p>
</li>
</ul>
</blockquote>
<h2 id="多说一句"><a href="#多说一句" class="headerlink" title="多说一句"></a>多说一句</h2><p>同时设置opacity与Z-index，Z-index是失效的。原因是Z-index只能工作在明确定义了定位属性为absolute fixed relative的元素中。</p>
<p>不要想着我用opacity把元素弄成层叠上下文元素，然后用Z-index给他设置顺序。别多想了，不可能。Z-index只认定位属性为absolute fixed relative的元素。不认得层叠上下文。</p>
<h3 id="小样有话说："><a href="#小样有话说：" class="headerlink" title="小样有话说："></a>小样有话说：</h3><center style="color:green;font-weight: Bold;border:1px dotted #999">Z-index的坑太多，先总结到这里，以后遇到了问题再来继续完善。</center>

<center><div style="border: 2px solid #999;border-top:none;border-left:none;width: 20px;height:20px;transform:rotate(45deg);"></div></center><br><center style="dispaly:block;width:300px;margin:0 auto"><span style="display:inline-block;float:left;width:100px;height:10px;border-top:1px solid #999;margin-top:15px;"></span><span><a href="https://github.com/Gong-Elory" target="_blank" rel="external">龚小样</a></span><span style=" display:inline-block;float:right;width:100px;height:10px;border-top:1px solid #999;margin-top:15px;"></span></center><br><center><span style="font-size:14px;line-height:14px;margin-top:0;">2016-10-15</span></center>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;Z-index的罪与罚，噗！手动喷血&lt;/center&gt;
    
    </summary>
    
      <category term="前端" scheme="http://gelory.me/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="http://gelory.me/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="CSS" scheme="http://gelory.me/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>Relative与Absolute的爱恨纠葛</title>
    <link href="http://gelory.me/2016/10/14/Relative%E4%B8%8EAbsolute%E7%9A%84%E7%88%B1%E6%81%A8%E7%BA%A0%E8%91%9B/"/>
    <id>http://gelory.me/2016/10/14/Relative与Absolute的爱恨纠葛/</id>
    <published>2016-10-14T12:06:25.000Z</published>
    <updated>2016-10-20T07:05:34.210Z</updated>
    
    <content type="html"><![CDATA[ <center> 关于relative与absolute区别的反思回顾。</center>

<a id="more"></a>
<p>position属性有如下几种状态：</p>
<blockquote>
<ul>
<li>static 默认状态。</li>
<li>inherit 继承其父元素的position属性。</li>
<li>fixed 相对于浏览器窗口进行绝对定位。</li>
<li>absolute 相对于非static状态的祖先元素进行定位。脱离文档流后，其他元素会把空隙给填掉。</li>
<li>relative 通过left，top等属性偏移其原来位置，没有的话位置不变。脱离文档流后，其他元素不会填掉其空隙。</li>
</ul>
</blockquote>
<p>常用的relative和absolute经常配合在一起使用。</p>
<p>譬如要像使子元素相对于父元素进行定位。通常的手段就是设置父元素为relative，子元素为absolute。假设不设置父元素为relative的话，子元素就会一直向上寻找一个非static状态的元素。直到遇到body元素。</p>
<h3 id="小样有话说："><a href="#小样有话说：" class="headerlink" title="小样有话说："></a>小样有话说：</h3><center style="color:green;font-weight: Bold;border:1px dotted #999">哈哈，多么悲惨的故事，子元素也真是够执着。</center>

<center><div style="border: 2px solid #999;border-top:none;border-left:none;width: 20px;height:20px;transform:rotate(45deg);"></div></center><br><center style="dispaly:block;width:300px;margin:0 auto"><span style="display:inline-block;float:left;width:100px;height:10px;border-top:1px solid #999;margin-top:15px;"></span><span><a href="https://github.com/Gong-Elory" target="_blank" rel="external">龚小样</a></span><span style=" display:inline-block;float:right;width:100px;height:10px;border-top:1px solid #999;margin-top:15px;"></span></center><br><center><span style="font-size:14px;line-height:14px;margin-top:0;">2016-10-14</span></center>]]></content>
    
    <summary type="html">
    
      &lt;center&gt; 关于relative与absolute区别的反思回顾。&lt;/center&gt;
    
    </summary>
    
      <category term="前端" scheme="http://gelory.me/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="http://gelory.me/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="CSS" scheme="http://gelory.me/tags/CSS/"/>
    
  </entry>
  
</feed>
